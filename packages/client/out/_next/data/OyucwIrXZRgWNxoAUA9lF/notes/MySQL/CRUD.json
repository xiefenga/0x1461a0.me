{"pageProps":{"metaTitle":"CRUD","article":{"title":"CRUD","content":"# 基础查询\r\n\r\n通过 `SELECT` 语句进行查询：\r\n\r\n```mysql\r\nSELECT\r\n\tprod_name\r\nFROM\r\n\tproducts;\r\n```\r\n\r\n- 查询列表可以是：表中的字段、常量值、表达式、函数\r\n- 查询的结果是一个虚拟的表格\r\n\r\n## 字段查询\r\n\r\n查询多个字段，使用 `,` 分隔\r\n\r\n```mysql\r\nSELECT\r\n\tprod_id,\r\n\tprod_name,\r\n\tprod_price \r\nFROM\r\n\tproducts;\r\n```\r\n\r\n使用通配符 `*` 查询所有字段\r\n\r\n```mysql\r\nSELECT * FROM products;\r\n```\r\n\r\n## 去重查询\r\n\r\n使用关键字 `DISTINCT`，将其直接放在列名之前。\r\n\r\n```mysql\r\nSELECT DISTINCT vend_id FROM products;\r\n```\r\n\r\n不能部分使用 `DISTINCT`，该关键字应用于**所有列**而不仅仅是前置它的列。\r\n\r\n所以如果给出了多个列，只有这些列都相同才好使，但是不会报错会列出所有的行。\r\n\r\n## 查询别名\r\n\r\n使用 `AS` 关键词起别名，`AS` 也可省略用空格代替。\r\n\r\n  ```mysql\r\nSELECT\r\n\tprod_name AS 名称,\r\n\tprod_price  AS 价格\r\nFROM\r\n\tproducts;\r\n  ```\r\n\r\n## 完全限定\r\n\r\n1. 完全限定列\r\n\r\n\t可以使用完全限定的名字来引用列，也就是同时使用表名和列名\r\n\r\n\t```mysql\r\n\tSELECT\r\n\t\tproducts.prod_name \r\n\tFROM\r\n\t\tproducts;\r\n\t```\r\n\r\n2. 完全限定表\r\n\r\n\t表名也是可以完全限定的，即使用数据库名和表名\r\n\r\n\t```mysql\r\n\tSELECT\r\n\t\tproducts.prod_name \r\n\tFROM\r\n\t\tcrashcourse.products;\r\n\t```\r\n\r\n## 其他查询\r\n\r\n1. 查询常量\r\n2. 查询表达式\r\n3. 查询函数\r\n\r\n```mysql\r\n-- 常量\r\nSELECT 100;\r\n-- 表达式\r\nSELECT 100 % 98;\r\n-- 函数\r\nSELECT VERSION();\r\n```\r\n\r\n# 分页查询\r\n\r\n使用 `LIMIT` 子句进行对于查询的结果数量进行限制：\r\n\r\n```mysql\r\nSELECT\r\n\tprod_name\r\nFROM\r\n\tproducts\r\nLIMIT 5;\r\n```\r\n\r\n- 查询结果的行数是从第 0 行开始计算\r\n\r\n- `LIMIT 5` 指示返回的结果不多于 5 行\r\n- `LIMIT 5, 5` 指示返回从第 5 行开始 5 行的数据\r\n- MySQL 5 添加了 `LIMIT 4 OFFSET 3` 的语法，相当于 `LIMIT 3, 4`\r\n\r\n# 过滤数据\r\n\r\n使用 `WHERE` 子句进行数据过滤：\r\n\r\n```mysql\r\nSELECT\r\n\tprod_name,\r\n\tprod_price \r\nFROM\r\n\tproducts \r\nWHERE\r\n\tprod_price = 2.50;\r\n```\r\n\r\n## 范围操作符\r\n\r\n- `>`、` =`、`!=`、`<>`、`<=>`、`>=`、`<=`\r\n\r\n  - `<>` 和 `!=` 相同，没有区别，都是不等于\r\n  - `<=>` 安全等于，`!=` 和 `=` 无法判断 `null`，`<=>` 可以判断 `null`\r\n  - 执行匹配时默认不区分大小写（字符串）\r\n\r\n- `BETWEEN ... AND ...`\r\n- 相当于 `>= ... AND  <= ...`\r\n  - 可以用于日期类型数据\r\n\r\n## 空值查询\r\n\r\n使用 `IS`、`IS NOT` 操作符来判空 `NULL`，`=` 无法判断 `NULL` \r\n\r\n```mysql\r\nSELECT\r\n\tprod_name \r\nFROM\r\n\tproducts \r\nWHERE\r\n\tprod_price IS NULL;\r\n```\r\n\r\n## 逻辑操作符\r\n\r\n`AND`、`OR`、`NOT`\r\n\r\n```mysql\r\nSELECT\r\n\tlast_name,\r\n\tsalary,\r\n\tcommission_pct \r\nFROM\r\n\temployees \r\nWHERE\r\n\tsalary >= 10000 AND salary <= 20000;\r\n```\r\n\r\n优先级：`AND` 优先级比 `OR` 高，判断比较复杂的时候可以加上 `()`\r\n\r\n## IN操作符\r\n\r\n判断某字段的值是否属于 `IN` 列表中的某一项，列表的值类型必须一致或兼容，列表中不支持通配符\r\n\r\n```mysql\r\nSELECT\r\n\tprod_name,\r\n\tprod_price \r\nFROM\r\n\tproducts \r\nWHERE\r\n\tvend_id IN ( 1002, 1003 );\r\n```\r\n\r\n- 语法更清晰直观\r\n- 查询速度更快\r\n- 可以包含其他 `SELECT` 语句\r\n\r\n## LIKE操作符\r\n\r\n使用 `LIKE` 可以进行模糊查询，`%` 表示任意个字符（包括0个），`_` 表示单个任意字符\r\n\r\n```mysql\r\nSELECT\r\n\tprod_id,\r\n\tprod_name \r\nFROM\r\n\tproducts \r\nWHERE\r\n\tprod_name LIKE 'jet%'\r\n```\r\n\r\n## 正则查询\r\n\r\n使用 `REGEXP` 关键字代替 `LIKE` 可以使用正则表达式匹配来进行数据过滤。\r\n\r\nMySQL 仅支持多数正则表达式实现的一个**很小**的子集。\r\n\r\n```mysql\r\nSELECT\r\n\tprod_name \r\nFROM\r\n\tproducts \r\nWHERE\r\n\tprod_name REGEXP '1000';\r\n```\r\n\r\nMySQL 中正则表达式的匹配不区分大小写，需要区分大小写需要使用 `REGEXP BINAR` 关键字\r\n\r\n# 排序查询\r\n\r\n使用 `ORDER BY` 语句进行排序：\r\n\r\n```mysql\r\nSELECT\r\n\tprod_name \r\nFROM\r\n\tproducts \r\nORDER BY\r\n\tprod_name ASC;\r\n```\r\n\r\n- `ASC` 升序，`DESC` 降序，默认升序\r\n- `ORDER BY` 子句支持单个字段、别名、表达式、函数、多个字段排序\r\n- `ORDER BY` 子句在查询语句的最后面，除了 `LIMIT` 子句\r\n\r\n## 按单个字段排序\r\n\r\n```mysql\r\nSELECT\r\n\t* \r\nFROM\r\n\temployees \r\nORDER BY\r\n\tsalary DESC;\r\n```\r\n\r\n## 按表达式排序\r\n\r\n```mysql\r\nSELECT\r\n\tsalary * 12 * ( 1 + IFNULL( commission_pct, 0 ) ) AS 年薪 \r\nFROM\r\n\temployees \r\nORDER BY\r\n\tsalary * 12 *( 1 + IFNULL( commission_pct, 0 ) ) DESC;\r\n```\r\n\r\n## 按别名排序\r\n\r\n```mysql\r\nSELECT\r\n\tsalary * 12 * ( 1 + IFNULL( commission_pct, 0 ) ) AS 年薪\r\nFROM\r\n\temployees \r\nORDER BY\r\n\t年薪 ASC;\r\n```\r\n\r\n## 按函数排序\r\n\r\n```mysql\r\nSELECT\r\n\tlast_name \r\nFROM\r\n\temployees \r\nORDER BY\r\n\tLENGTH( last_name ) DESC;\r\n```\r\n\r\n## 按多个字段排序\r\n\r\n```mysql\r\nSELECT\r\n\t* \r\nFROM\r\n\temployees \r\nORDER BY\r\n\tsalary DESC,\r\n\temployee_id ASC;\r\n```\r\n\r\n# CASE语句\r\n\r\n条件可以写在 `CASE` 后面也可以写在 `WHEN` 后面，`END` 代表这个 `CASE` 结束了，可以在 `END` 后使用别名\r\n\r\n两种用法类似于 `switch..case..` 和 `if..else if ..` 的区别\r\n\r\n**第一种用法**\r\n\r\n```mysql\r\nSELECT salary AS 原始工资, department_id,\r\n\tCASE department_id \r\n\t\tWHEN 30 THEN salary * 1.1 \r\n\t\tWHEN 40 THEN salary * 1.2 \r\n\t\tWHEN 50 THEN salary * 1.3\r\n\t\tELSE salary \r\n\tEND AS 新工资 \r\nFROM\r\n\temployees;\r\n```\r\n\r\n**第二种用法**\r\n\r\n```mysql\r\nSELECT salary,\r\n\tCASE\r\n\t\tWHEN salary > 20000 THEN 'A' \r\n\t\tWHEN salary > 15000 THEN 'B' \r\n\t\tWHEN salary > 10000 THEN 'C'\r\n\t\tELSE 'D' \r\n\tEND AS 工资级别 \r\nFROM\r\n\temployees;\r\n```\r\n\r\n# 分组查询\r\n\r\n使用 `GROUP BY` 子句进行分组：\r\n\r\n```mysql\r\nSELECT 查询列表\r\nFROM 表\r\nWHERE 筛选条件\r\nGROUP BY 分组的依据\r\nORDER BY 排序的字段;\r\n```\r\n\r\n- `GROUP BY` 子句指示 MySQL 分组数据，然后对每个组而不是整个结果进行聚集\r\n- `GROUP BY` 子句必须在 `WHERE` 子句之后，`ORDER BY` 子句之前\r\n\r\n## 简单分组\r\n\r\n```mysql\r\nSELECT\r\n\tMAX( salary ) \r\nFROM\r\n\temployees \r\nWHERE\r\n\temail LIKE '%a%' \r\nGROUP BY\r\n\tdepartment_id;\r\n```\r\n\r\n## 过滤分组\r\n\r\n当分组查询后需要继续过滤数据，就需要用到 `HAVING` 语句：\r\n\r\n```mysql\r\n-- 查询部门员工数量大于5的部门id和员工数量\r\nSELECT\r\n\tCOUNT(*),\r\n\tdepartment_id \r\nFROM\r\n\temployees \r\nGROUP BY\r\n\tdepartment_id \r\nHAVING\r\n\tCOUNT(*)> 5;\r\n```\r\n\r\n`HAVING` 子句和 `WHERE` 子句的区别：\r\n\r\n- `WHERE` 过滤行，`HAVING` 过滤分组\r\n- `WHERE` 分组前过滤，`HAVING` 分组后过滤\r\n\r\n## 多个字段分组\r\n\r\n将多个字段都相同的分为一组\r\n\r\n```mysql\r\nSELECT\r\n\tMIN( salary ) \r\nFROM\r\n\temployees \r\nGROUP BY\r\n\tdepartment_id,\r\n\tjob_id \r\nORDER BY\r\n\tMIN( salary ) DESC;\r\n```\r\n\r\n# 子句顺序\r\n\r\n`SELECT` 子句使用顺序：\r\n\r\n1. `SELECT`\r\n2. `FROM`\r\n3. `WHERE`\r\n4. `GROUP BY`\r\n5. `HAVING`\r\n6. `ORDER BY`\r\n7. `LIMIT`\r\n\r\n# 连接查询\r\n\r\n当查询的字段来自于多个表时，就可以使用连接查询。\r\n\r\n## 笛卡尔积\r\n\r\n在连接两个表时，实际上做的是将第一个表的每一行与第二个表中的每一行配对。\r\n\r\n`WHERE` 子句可以将不需要的行过滤掉，在连接查询时这个条件叫做连接条件。\r\n\r\n当没有连接条件时连接查询返回的结果就是**笛卡尔积**，检索出的行数时两表行数的乘积。\r\n\r\n为了避免笛卡尔集，可以在 `WHERE` 加入有效的连接条件。\r\n\r\n## 内连接\r\n\r\n内连接查询操作只列出与连接条件匹配的数据行，也就是交集\r\n\r\n- 根据所使用的**比较方式**不同，分为等值连接、非等值连接。\r\n\r\n- n表连接，至少需要n-1个连接条件\r\n- 一般需要为表起别名\r\n\r\n### SQL92\r\n\r\n将连接条件写在 `WHERE` 后进行过滤的是 SQL92 语法\r\n\r\n```mysql\r\nSELECT\r\n\tvend_name,\r\n\tprod_name,\r\n\tprod_price \r\nFROM\r\n\tvendors,\r\n\tproducts \r\nWHERE\r\n\tvendors.vend_id = products.vend_id;\r\n```\r\n\r\n### SQL99\r\n\r\nSQL99 语法使用 `INNER JOIN` 语法来实现表的内连接\r\n\r\n```mysql\r\nSELECT\r\n\tvend_name,\r\n\tprod_name,\r\n\tprod_price \r\nFROM\r\n\tvendors\r\n\tINNER JOIN products ON vendors.vend_id = products.vend_id;\r\n```\r\n\r\n- `INNER` 关键字可以省略\r\n- 连接条件在 `ON` 后面\r\n- 可以接着使用 `WHERE` 进行过滤\r\n- 筛选条件放在 `WHERE` 后面，连接条件放在 `ON` 后面，提高分离性，便于阅读\r\n\r\n**区别**\r\n\r\n- **WHERE 没有 ON 效率高**\r\n- ON 匹配到第一条成功的就结束，其他不匹配；若没有，不进行匹配\r\n-  WHERE 会一直匹配，进行判断\r\n\r\n## 自然连接\r\n\r\n在返回所有结果的等值连接中，必然至少有一个列是重复的，自然连接就是自己选择结果集合中所包括的列。\r\n\r\n## 自连接\r\n\r\n自连接就是同一张表和同一张表进行连接，当一张表中有两个以上的字段有一定的关系时就可能用到自连接。\r\n\r\n```mysql\r\n-- mysql92\r\nSELECT\r\n\te.last_name,\r\n\tm.last_name \r\nFROM\r\n\temployees e,\r\n\temployees m \r\nWHERE\r\n\te.`manager_id` = m.`employee_id`;\r\n\r\n-- mysql99\r\nSELECT\r\n\te.last_name,\r\n\tm.last_name \r\nFROM\r\n\temployees e\r\n\tJOIN employees m ON e.`manager_id` = m.`employee_id`;\r\n```\r\n\r\n## 外连接\r\n\r\n外连接不只列出与连接条件相匹配的行，而且还加上左表(左外连接时)或右表(右外连接时)或两个表(全外连接时)中所有符合搜索条件的数据行\r\n\r\n外连接只有 SQL99 支持，SQL92 不支持。\r\n\r\n### 左外连接\r\n\r\n左外连接从左边表（`FROM`）中选择所有行，另一个表中没有的数据则显示 `NULL`\r\n\r\n```mysql\r\nSELECT\r\n\tcustomers.cust_id,\r\n\torders.order_num \r\nFROM\r\n\tcustomers\r\n\tLEFT OUTER JOIN orders ON customers.cust_id = orders.cust_id;\r\n```\r\n\r\n- `OUTER` 关键字可以省略\r\n- 可以多表连接\r\n- 多表连接时先连接成一个大表再和后面的表依次进行连接，主表在左边\r\n\r\n### 右外连接\r\n\r\n右外连接从右边表（`FROM`）中选择所有行，另一个表中没有的数据则显示 `NULL` \r\n\r\n```mysql\r\nSELECT\r\n\tcustomers.cust_id,\r\n\torders.order_num \r\nFROM\r\n\torders\r\n\tRIGHT OUTER JOIN customers ON customers.cust_id = orders.cust_id;\r\n```\r\n\r\n### 全外连接\r\n\r\n全外连接就是两个表中的行都有，每一个表中不匹配的行列的数据为 `NULL`\r\n\r\n全外连接使用 `FULL OUTER JOIN` 关键字MySQL 不支持全外连接\r\n\r\n```mysql\r\nSELECT\r\n\tb.*,\r\n\tbo.* \r\nFROM\r\n\tbeauty b\r\n\tFULL OUTER JOIN boys bo ON b.`boyfriend_id` = bo.id;\r\n```\r\n\r\n## 交叉连接\r\n\r\n交叉连接就是笛卡尔积，交叉连接使用 `CROSS JOIN` 关键字\r\n\r\n```mysql\r\nSELECT\r\n\tb.*,\r\n\tbo.* \r\nFROM\r\n\tbeauty b\r\n\tCROSS JOIN boys bo;\r\n```\r\n\r\n# 子查询\r\n\r\n子查询就是嵌套在其他查询中的查询（出现在其他语句中的 `SELECT`语句）\r\n\r\n子查询可以出现的位置：\r\n\r\n- `SELECT` 之后\r\n- `FROM` 之后\r\n- `WHERE` 之后\r\n- `HAVING` 之后\r\n- `EXISTS` 之后\r\n\r\n子查询的结果的行和列的数量必须要合法，要和使用的位置所需要的格式相匹配。\r\n\r\n```mysql\r\nSELECT\r\n\tcust_id \r\nFROM\r\n\torders \r\nWHERE\r\n\torder_num IN ( SELECT order_num FROM orderitems WHERE prod_id = 'TNT2' );\r\n```\r\n\r\n在 `SELECT` 语句中，子查询总是由内向外处理，先运行子查询再运行主查询。\r\n\r\n对于 `IN` 操作符内部的子查询，查询出来的多行单列的结果会以 `IN` 操作符要求的逗号分隔的格式传递给外部。\r\n\r\n## 相关子查询\r\n\r\n当**子查询中**涉及到**外部查询**的子查询称之为相关子查询\r\n\r\n`SELECT` 之后的子查询会在检索每一行时都会执行一遍，对于每个 customer 都会在执行一边子查询。\r\n\r\n```mysql\r\nSELECT\r\n\tcust_name,\r\n\tcust_state,\r\n\t( SELECT count(*) FROM orders WHERE orders.cust_id = customers.cust_id ) AS orders \r\nFROM\r\n\tcustomers \r\nORDER BY\r\n\tcust_name;\r\n```\r\n\r\n## EXISTS\r\n\r\n当 `EXISTS` 子句中的子查询有结果返回 1，否则返回 0\r\n\r\n```mysql\r\nSELECT EXISTS ( SELECT * FROM products WHERE vend_id IS NULL );\r\n```\r\n\r\n## ANY/SOME/ALL\r\n\r\n`ANY`、`SOME` 和 `ALL`  中只能放子查询，和 `IN`、`NOT IN` 子句一样后面放的是多行单列的子查询\r\n\r\n- `ANY`、`SOME` 是一样的，只要和其中的任意一个数据比较满足就可以。\r\n\r\n- `ALL` 则是和其中所有的进行比较满足才可以。\r\n\r\n```mysql\r\nSELECT\r\n\tprod_name,\r\n\tvend_id \r\nFROM\r\n\tproducts \r\nWHERE\r\n\tvend_id > ALL ( SELECT DISTINCT vend_id FROM products WHERE vend_id IN ( 1001, 1002 ) );\r\n```\r\n\r\n# 联合查询\r\n\r\n联合查询就是将多条查询语句的结果合并成一个结果。\r\n\r\n```mysql\r\nSELECT\r\n\tvend_id,\r\n\tprod_id,\r\n\tprod_price \r\nFROM\r\n\tproducts \r\nWHERE\r\n\tprod_price <= 5\r\nUNION\r\nSELECT\r\n\tvend_id,\r\n\tprod_id,\r\n\tprod_price \r\nFROM\r\n\tproducts \r\nWHERE\r\n\tvend_id IN ( 1001, 1002 );\r\n```\r\n\r\n- `UNION` 必须由两条或两条以上的 `SELECT` 语句组成\r\n- `UNION` 中的每个查询必须包含**相同的列**\r\n- `UNION` 从查询结果中自动去除了的**重复的行**\r\n- 想返回所有匹配的行，使用 `UNION ALL`\r\n- 只能使用一条 `ORDER BY` 子句，必须出现在最后一条 `SELECT` 语句之后，MySQL 使用它来给整个结果排序\r\n- `UNION` 几乎总是完成与多个 `WHERE` 条件相同的工作\r\n\r\n# 插入数据\r\n\r\n使用 `SELECT INTO` + 表名向表中插入一行数据：\r\n\r\n```mysql\r\nINSERT INTO customers\r\nVALUES\r\n\t( NULL, 'Prp E. LaPew', '100 Main Street', 'Los Angeles', 'CA', '90046', 'USA', NULL, NULL );\r\n```\r\n\r\n- 这种方式需要传入所有的字段，以及顺序高度依赖表中列定义的次序\r\n- `NULL` 可以传递给主键，MySQL 会忽略该值自动插入递增的值\r\n\r\n比较安全的 `INSERT` 语句是写出插入的字段：\r\n\r\n```mysql\r\nINSERT INTO customers ( cust_name, \r\n\tcust_address, \r\n\tcust_city, \r\n\tcust_state,\r\n\tcust_zip, \r\n\tcust_country, \r\n\tcust_contact, \r\n\tcust_email )\r\nVALUES\r\n\t( 'Prp E. LaPew', '100 Main Street', 'Los Angeles', 'CA', '90046', 'USA', NULL, NULL );\r\n```\r\n\r\n- 可以省略允许定义为 `NULL` 或有默认值的列\r\n- 列的顺序随意\r\n\r\n## 多行插入\r\n\r\n插入多行可以使用多条 `INSERT` 语句，也可以使用 `,` 分隔多组值：\r\n\r\n```mysql\r\nINSERT INTO customers ( cust_name, \r\n\tcust_address, \r\n\tcust_city, \r\n\tcust_state,\r\n\tcust_zip, \r\n\tcust_country, \r\n\tcust_contact, \r\n\tcust_email )\r\nVALUES\r\n\t( 'Prp E. LaPew', '100 Main Street', 'Los Angeles', 'CA', '90046', 'USA', NULL, NULL ),\r\n\t( 'M. Martain', '42 Galaxy Way', 'New York', 'NY', '11213', 'USA' );\r\n```\r\n\r\n## 检索插入\r\n\r\n可以使用 `INSERT SELECT` 插入查询出来的数据：\r\n\r\n```mysql\r\nINSERT INTO customers ( cust_contact, \r\n\tcust_email, \r\n\tcust_name, \r\n\tcust_address, \r\n\tcust_city, \r\n\tcust_state, \r\n\tcust_zip, \r\n\tcust_country ) \r\nSELECT\r\n    cust_contact,\r\n    cust_email,\r\n    cust_name,\r\n    cust_address,\r\n    cust_city,\r\n    cust_state,\r\n    cust_zip,\r\n    cust_country \r\nFROM\r\n\tcustomers \r\nWHERE\r\n\tcust_contact IS NOT NULL;\r\n```\r\n\r\n`INSERT` 和 `SELECT` 中的列名不要求相同，MySQL 不关心列名只关心位置\r\n\r\n# 更新数据\r\n\r\n使用 `UPDATE` 语句更新表中的数据，\r\n\r\n```mysql\r\nUPDATE customers \r\nSET cust_email = 'elmer@fudd.com' \r\nWHERE\r\n\tcust_id = 10005;\r\n```\r\n\r\n- `UPDATE` 会更新符合条件的行，没有条件则会更行所有行\r\n- 通过 `SET` 改变字段的值\r\n\r\n## 更新多个列\r\n\r\n在更新多个列时只需要使用单个 `SET` ，每个 `列=值` 之间使用 `,` 分隔，最后一列不需要。\r\n\r\n```mysql\r\nUPDATE customers \r\nSET cust_email = 'elmer@fudd.com',\r\n\tcust_name = 'The Fudds' \r\nWHERE\r\n\tcust_id = 10005;\r\n```\r\n\r\n## IGNORE\r\n\r\n当使用 `UPDATE` 语句更新多个行时，当在更新过程中出现错误，则整个 `UPDATE` 操作会被取消，数据会恢复到之前的值。\r\n\r\n使用 `IGNORE` 关键字可以即使发生错误也继续更新。\r\n\r\n```mysql\r\nUPDATE IGNORE customers ...\r\n```\r\n\r\n## 更新多表\r\n\r\n```mysql\r\nUPDATE products\r\nINNER JOIN vendors ON products.vend_id = vendors.vend_id \r\nSET vendors.vend_name = 'The Fudds',\r\n\tproducts.prod_name = 'Wascals' \r\nWHERE\r\n\tproducts.prod_id = 'FC';\r\n```\r\n\r\n# 删除数据\r\n\r\n使用 `DELETE` 语句删除特定的行：\r\n\r\n```mysql\r\nDELETE \r\nFROM\r\n\tcustomers \r\nWHERE\r\n\tcust_id = 10006;\r\n```\r\n\r\n- `DELETE` 会删除符合条件的行，没有条件则会删除所有行\r\n- `DELETE FROM` 指定删除数据的表名\r\n- 可以和 `UPDATE` 一样删除多个表\r\n\r\n## 删除多表\r\n\r\n`DELETE` 后面跟的是要删除的表，`FROME` 后面跟的是连接的主表\r\n\r\n```mysql\r\nDELETE b, bo \r\nFROM\r\n\tbeauty b\r\n\tINNER JOIN boys bo ON b.`boyfriend_id` = bo.`id` \r\nWHERE\r\n\tbo.`boyName` = '黄晓明';\r\n```\r\n\r\n## 更快的删除\r\n\r\n如果要从表中删除所有的行，使用 `TRUNCATE TABLE` 语句更合适：\r\n\r\n```mysql\r\nTRUNCATE TABLE customers ;\r\n```\r\n\r\n- `TRUNCATE TABLE` 的速度比 `DELETE` 更快\r\n- `TRUNCATE` 的本质是删除原来的表然后重新创建一个表\r\n\r\n\r\n\r\n","meta":{"size":16857,"birthTime":1663496641411.9246,"updateTime":1663496641412.2349}}},"__N_SSG":true}
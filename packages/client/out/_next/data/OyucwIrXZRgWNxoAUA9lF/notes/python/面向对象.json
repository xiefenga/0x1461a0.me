{"pageProps":{"metaTitle":"面向对象","article":{"title":"面向对象","content":"```python\r\nclass User : \r\n    def __init(self, name, age):\r\n        self.name = name\r\n        self.age = age\r\n    def print(self):\r\n        print(self.name, self.age)\r\n    \r\n```\r\n\r\n# 实例方法\r\n\r\n实例方法（包括构造函数）会自动绑定第一个参数 `self`：\r\n\r\n1. 在构造函数中指向正在初始化的对象\r\n2. 在实例方法中指向正在调用的方法的对象\r\n\r\n即使将该实例方法赋值给一个变量，直接调用也无需手动绑定 `self`\r\n\r\n```python\r\nclass Test: \r\n    def test(self):\r\n        print(self)\r\ntest = Test().test\r\ntest()\r\nTest().test()\r\n```\r\n\r\n通过类调用实例方法，不会执行自动绑定 self，需要手动传入\r\n\r\n```python\r\nTest.test('test')\r\n```\r\n\r\n# 类方法、静态方法\r\n\r\n## 类方法\r\n\r\n`@classmethod` 修饰的函数就是类方法，会自动绑定第一个参数 `cls` 为类本身\r\n\r\n```python\r\nclass Test:\r\n    @classmethod\r\n    def classTestMethod(cls):\r\n        print(cls)\r\nm = Test.classTestMethod\r\nm()\r\nTest.classTestMethod()\r\n```\r\n\r\n和实例方法类似，在通过类调用 / 赋值再调用会自动绑定 `cls` ，通过实例调用，也不需要传入第一参数，也会自动绑定为当前类\r\n\r\n## 静态方法\r\n\r\n`@staticmethod` 修饰的函数是静态方法，不会自动绑定第一个参数\r\n\r\n既可以通过类，也可以通过实例调用\r\n\r\n```python\r\nclass Test:\r\n    @staticmethod\r\n    def staticTestMethod(value):\r\n        print(value)\r\nTest.staticTestMethod('Test')\r\nTest().staticTestMethod('test')\r\n```\r\n\r\n# 装饰器\r\n\r\n通过 @ + 函数可用于修饰其他函数：\r\n\r\n1. 将被修饰的函数作为参数传递给@后面的函数\r\n2. 将被修饰的函数替换为@后面的函数的返回值\r\n\r\n```python\r\ndef funA(fn):\r\n    print('执行funA')\r\n    fn()\r\n    return 'AAAA'\r\n@funA\r\ndef funB():\r\n    print('执行funB')\r\n#执行funA\r\n#执行funB\r\nprint(funB) # AAAA\r\n```\r\n\r\n# 存取器\r\n\r\n通过 `property` 函数： `property(getter=None, setter=None, delete=None, doc=None)`\r\n\r\n```python\r\n\r\n```\r\n\r\n通过 `@property` 装饰器\r\n\r\n```python\r\n\r\n```\r\n\r\n","meta":{"size":2075,"birthTime":1663496641422.1567,"updateTime":1663496641422.2761}}},"__N_SSG":true}
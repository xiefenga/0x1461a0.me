{"pageProps":{"metaTitle":"多路分解","article":{"title":"多路分解","content":"# 运输层的作用\r\n\r\n运输层将网络层在两个**端系统**之间的交付扩展到了运行在两个端系统上的**应用进程**之间的交付。\r\n\r\n或者说运输层的协议为运行在不同主机上的**应用进程**提供了**逻辑通信**的能力。\r\n\r\n运输层提供的最低限度的服务有两种：\r\n\r\n- 进程到进程的数据交付\r\n- 差错检查\r\n\r\n因特网中的运输层协议有两种：UDP（用户数据报协议） 和 TCP（传输控制协议）\r\n\r\nRFC 文档将 TCP 的分组称为报文段（segment），将 UDP 的分组称为数据报，将网络层的分为也称为数据报（datagram）。\r\n\r\n这是比较严谨的，本质上 UDP 在网络层协议 IP 的基础上没有提供什么能力，就是将数据交给 UDP，UDP 立马交给 IP 协议进行发送。\r\n\r\n应用进程和运输层之间不会直接打交道，而是通过套接字来进行数据的传输，所以当运输层收到另一个端系统的某个应用进程发来的数据时，会将该数据交给上层对应的套接字，而非应用进程。\r\n\r\n## 多路分解和复用\r\n\r\n一台主机上会运行很多的应用进程，每个应用进程又可能会有一个或多个套接字，所以套接字需要有唯一的**标识符**来让运输层可以准确的交付。\r\n\r\n**多路分解：** 运输层将报文段中的数据交付到正确的套接字的工作\r\n\r\n**多路复用：** 运输层从上层不同的套接字收集数据并生成报文段，接着将报文段传递到网络层\r\n\r\n实现多路分解和复用的要求：\r\n\r\n1. 套接字有唯一的标识符\r\n2. 每个报文字段有特殊字段（目的端口号、源端口号）来指示该报文字段所要交付的套接字\r\n\r\n## 端口\r\n\r\n端口号是一个 16 bit 的数，大小在 0 ~ 65535 之间。\r\n\r\n0 ~ 1023 号端口被称为**周知端口号**，也就是说它们是给特定应用层协议所使用，例如：HTTP 对应的是 80，FTP 对应的是 21\r\n\r\n当我们在开发网络应用程序时必须要为其分配一个端口号（严格来说是分配给该程序所使用的套接字），这是运输层为了实现多路分解和复用所必须的。\r\n\r\n简单来说运输层会根据套接字所对应的端口号，以及其他的一些信息来判断该将数据交给哪一个套接字。\r\n\r\n# UDP的多路分解\r\n\r\n一个 UDP 套接字是由一个二元组进行标识，该二元组是：（目的 IP 地址, 目的端口号）\r\n\r\n因为传输层是分析接收到的数据报来进行套接字的定位，所以所谓地目的就是本机。\r\n\r\n严格来说，在一台主机上所有的的 UDP 套接字具有相同的 IP 地址，传输层只需要根据目的端口号就可以准确定位套接字。\r\n\r\n由于 UDP 套接字仅由目的 IP 和目的端口进行标识，所以只要是发送到该主机的相同端口号的 UDP 报文，都会被交付到相同的进程（套接字）。\r\n\r\n通过简单地写一个 UDP 的例子可以明显的看出来，创建的 UDP 套接字是被复用的，或者严格来说相同端口的请求使用的是同一个 UDP 套接字。\r\n\r\n**server.py**\r\n\r\n```python\r\nserver = socket(AF_INET,  SOCK_DGRAM) # UDP 套接字\r\n\r\nserver.bind(('', 8080))\r\n\r\nprint('server is listening 8080')\r\n\r\nwhile True:\r\n    message, addr = server.recvfrom(2048)\r\n    message = message.decode()\r\n    print('from client', message)\r\n    print('client addr', addr)\r\n    server.sendto(message.upper().encode(), addr)\r\n```\r\n\r\n**client.ts**\r\n\r\n```typescript\r\nconst client = createSocket('udp4');\r\n\r\nclient.on('message', (msg, info) => {\r\n  console.log('from server', msg.toString());\r\n  console.log('server info', info);\r\n  client.close();\r\n});\r\n\r\nclient.send('hello', 8080);\r\n```\r\n\r\n一个容易忽略的点，当我们在创建 UDP 客户端套接字时，往往都是没有分配端口的，这时运输层（操作系统）会自动地为该套接字分配一个端口号，我们也可以手动的 `bind` 一个端口。\r\n\r\n```typescript\r\nclient.bind(12345);\r\n```\r\n\r\n![](http://oss.xiefeng.tech/img/20210629204016.png)\r\n\r\n# TCP的多路分解\r\n\r\nTCP 套接字由一个四元组标识：（源 IP, 源端口,  目的 IP, 目的端口）\r\n\r\n这意味着只要有一个是不同的就不会定向到同一个套接字，和 UDP 更加不同的是一开始并不会创建一个 TCP 套接字。\r\n\r\n因为每一个套接字需要依赖四元组，而一开始是没有办法创建一个 TCP 套接字的，因为缺少客户端的信息（源 IP 和源端口），不像 UDP 只要是请求这个端口的都会走这个套接字。\r\n\r\n- 当我们使用 TCP 服务器时会先创建一个 “欢迎套接字”，让它监听端口\r\n- 当主机接收到该端口的建立连接的报文时，会定位到该进程（该进程在等待连接）\r\n- 然后该进程就会创建一个新的 TCP 套接字，运输层则使用四元组标识该套接字\r\n- 套接字可以和一个进程关联，也可以和进程的某个线程相关联\r\n\r\n**server.py**\r\n\r\n```python\r\nserver = socket(AF_INET, SOCK_STREAM) # TCP 服务器，欢迎套接字\r\n\r\nserver.bind(('', 8080))\r\n\r\nserver.listen()\r\n\r\nprint('server is listening 8080')\r\n\r\ndef handleConnection(connectionSocket):\r\n    current = threading.current_thread()\r\n    handleMsg = 'thread: ' + current.name + ' ' + str(current.native_id)\r\n    connectionSocket.send(handleMsg.encode())\r\n    connectionSocket.close()\r\n\r\nwhile True:\r\n    connectionSocket, addr = server.accept() # 来新的连接，创建一个新的 TCP 套接字\r\n    # 让每个连接对应一个线程来处理\r\n    threading.Thread(target=handleConnection, args=(connectionSocket,)).start()\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","meta":{"size":5664,"birthTime":1663496641447.0618,"updateTime":1663496641447.1685}}},"__N_SSG":true}
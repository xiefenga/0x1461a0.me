{"pageProps":{"metaTitle":"数据的存储","article":{"title":"数据的存储","content":"## 定点数编码\n\n定点数表示小数点位置固定，定点数分为定点整数和定点小数\n\n### 原码\n\n第一位是符号位，其余是数值部分，小数点的位置固定\n\n```c\n10010.10100\n```\n\n- 0 的表示不唯一\n- 加、减运算方式不统一，需额外对符号位进行处理，不利于硬件设计\n\n从 50年代开始，整数都采用**补码**来表示，但浮点数的**尾数**用原码定点小数表示\n\n十进制小数转二进制：\n\n```c\n0.625 // 十进制转二进制\n0.625 * 2 = 1.25 --- 1\n0.25 * 2  = 0.5  --- 0\n0.5 * 2   = 1.0  --- 1\n\n0.625 --->  0.101\n```\n\n### 补码\n\n补码本质上利用了**模运算**，实现了正负号的统一，在一个模运算系统中，一个数与它除以“模”后的余数等价\n\n$[X]_补= (2^n + X) \\mod 2^n$\n\n计算机的运算器适合用补码表示和运算，运算器具有有限位（假设 n 位），可看成是个只有 n 档的二进制算盘，因此，其模为 $2^n$ \n\n例如：机器数 8 位，-10 的补码为 `(256 - 10) % 256 = 246 = 11110110`\n\n补码的特点：\n\n- 0 的表示唯一，不存在 +0 和 -0\n- 加、减运算方式统一，硬件设计简单只需要设计加法器\n\n快速求补码的方式：相反数的补码取反 + 1（反码 + 1），简便方法：从右向左遇到第一个1的后面各位取反\n\n**变形补码**：双符号，用于存放可能溢出的中间结果\n\n![](https://oss.xiefeng.tech/images/20211005155342.png)\n\n### 移码\n\n移码表示即给每一个数值加上一个偏置常数\n\n例如：编码位数为 n，偏置常数取 $2^{n-1}$，当 n = 4 时，偏置常数为 8\n\n移码表示则为：\n\n- -8 (+8) ~ 0000B\n- 0 (+8) ~ 1000B\n- ......\n\n在计算机中移码一般用来表示**浮点数**的阶（指数）\n\n**移码的意义：**便于浮点数加减运算时的**对阶**操作（比较大小）\n\n![](https://oss.xiefeng.tech/images/20211005160454.png)\n\n## 浮点数表示\n\n科学计数法将一个数表示为：$尾数 * 基^{阶}$，例如：$6.02 * 10^{21}$ \n\n对于一个数，使用科学计数法具有多种表示形式，可以将其分为**规格化**形式和**非规格化**形式\n\n**规格化表示**：小数点前只有一位非 0 数，所以规格化的**表示唯一**，例如：$1.0 * 10^{13}$\n\n### 存储形式\n\n计算机中浮点数的表示类似于科学计数法，主要思路是对尾数和指数分别编码来表示一个浮点数\n\n![image-20211005195055274](https://oss.xiefeng.tech/images/20211005195055.png)\n\n- 第一位为符号位，1 表示负数，0 表示正数\n- 使用移码表示阶码，偏置常数可能为 128，和阶码所占的位数相关\n- 尾数使用二进制原码小数表示，基数可能为 2 / 4 / 8 / 16\n\n因为采用原码表示，而原码是对称的，故浮点数的表示范围关于原点对称\n\n![](https://oss.xiefeng.tech/images/20211005194455.png)\n\n### IEEE 754\n\n早期的计算机，各自定义自己的浮点数格式（包括阶码的偏置，每个部分所占的位数，以及尾数的基数），因而相互不兼容\n\n现在所有通用计算机都采用**IEEE 754 标准**来表示浮点数\n\n#### 规格化数\n\n- 单精度 32 bits，双精度 64 bits\n\n- 阶码部分\n  - 全 0 和全 1 用来表示特殊值\n  - 单精度为 8 bits，双精度为 11 bits\n  - 偏置值为 $2^{n-1} - 1$，则单精度偏置为 127，双精度偏置为 1023\n- 尾数部分\n  - 规格化数为：$+/-(1.xxxx)_2 * 2^{e}$\n  - 规格化尾数最高位总是 1，所以隐含表示，扩大了表示范围\n  - 单精度：23 bits，双精度：52 bits\n\n![](https://oss.xiefeng.tech/img/20210201155344.png)\n\n规格化单精度浮点数表示为：$(-1)^S * (1 + M) * 2^{E - 127}$ \n\n规格化双精度浮点数表示为：$(-1)^S * (1 + M) * 2^{E - 1024}$ \n\n#### 特殊值\n\n阶码部分全 0 和全 1 用来表示特殊值，一共具有四种情况：\n\n1. 阶码全 0，尾数全 0：表示 0，所以浮点数存在 +0 和 -0 两种值\n2. 阶码全 0，尾数不为 0：表示非规格化的浮点数\n3. 阶码全 1，尾数全 0：表示 infinity\n4. 阶码全 1，尾数不为 0：表示 NaN\n\n**infinity**\n\n浮点数除以0不会产生异常（整数除以0为异常），结果为±infinity\n\n这样处理的意义是可以利用+∞/-∞作比较，例如：`X / 0 > Y` 可作为有效比较\n\n在 JavaScript 和 C 语言中都可以得出该结果：\n\n```c\n#include <stdio.h>\n\nint main(int argc, char const* argv[]) {\n  printf(\"%lf\\n\", 1.0 / 0.0);\t\t\t// inf\n  printf(\"%lf\\n\", -1.0 / 0.0);\t\t// -inf\n  return 0;\n}\n```\n\n**非数**\n\n对于有些操作返回的结果应当表示为不是一个数字，需要一种特殊的表示\n\n例如：`Sqrt (- 4.0)`、`0.0 / 0.0`、`infinity + -infinity`\n\n当一个浮点数的阶码全为 1 尾数不为 0 时，这时候表示这是一个非数\n\n```c\n#include <stdio.h>\n\nint main(int argc, char const* argv[]) {\n  printf(\"%lf\", 0.0 / 0.0);\t\t// nan\n  return 0;\n}\n```\n\n**非规格化数**\n\n当阶码全为 0，尾数不为 0 时，就不会像规格化数那样默认尾数隐含着小数点前的 1\n\n 非规格化数用于表示非常靠近0的数，**非规格数的指数固定为-126 / - 1024**\n\n![](https://oss.xiefeng.tech/images/20211005203652.png)\n\n### 精度\n\n浮点数使用有限的数表示无限的数，使用离散的数表示连续的实数，必然是无法完全表示的\n\n浮点数存在着精度问题，因为无法表示所有的数，对于无法准确表示的数会利用近似的数表示\n\n浮点数的精度由**尾数**的**位数**来决定\n\nfloat 的最大值为 2^23 = 8388608，这意味着最多能表示 7 位有效数字，即 float 的精度为 7 位\n\ndouble 的最大值为 2^52 = 4503599627370496，一共16位，即 double 的精度为 16 位\n\n## 字节排列\n\n80年代开始，几乎所有通用计算机都采用**字节编址**\n\n在高级语言中往往一个基本数据会占用多个存储单元，则需要考虑一些问题：\n\n- 变量的地址是其最大地址还是最小地址：**采用低地址代表变量的地址**\n- 多个字节在存储单元中存放的顺序如何\n  - 大端方式\n  - 小端方式\n\n### 大小端\n\nMSB：最高有效位，Most Significant Bit\n\nLSB：最低有效位，Least Significant Byte\n\n**大端方式（Big Endian）**：MSB所在的地址是数的地址\n\n**小端方式（Little Endian）**：LSB所在的地址是数的地址\n\n![](https://oss.xiefeng.tech/images/20211005213033.png)\n\n假定机器中某条指令的地址为 1000，该指令汇编形式为：`mov AX, 0x12345(BX)`\n\n其中操作码 mov 为 40H，寄存器 AX 和 BX 的编号分别为 0001B和 0010B，立即数占32位\n\n字节序列只需要考虑指令中**立即数**的顺序\n\n![](https://oss.xiefeng.tech/images/20211005215334.png)\n\n### 检测序列\n\n使用 C 语言的 Union 可以检测系统的字节序列是大段还是小端\n\n```c\n#include <stdio.h>\n\nchar* detect_endian() {\n  union NUM {\n    int a;\n    char b;\n  } num;\n\n  num.a = 0x123456;\n\n  return num.b == 0x12 ? \"big endian\" : \"little endian\";\n}\n\nint main(int argc, char const* argv[]) {\n  printf(\"%s\", detect_endian());\n  return 0;\n}\n```\n\n## 存储单位\n\n- **比特**是计算机中处理、存储、传输信息的最小单位\n- 二进制信息最基本的计量单位是**字节**\n\n  - 现代计算机中，存储器**按字节编址**\n  - 字节是**最小可寻址单位**\n- **字长**表示计算机的数据通路的宽度\n  - CPU内部总线的宽度\n  - CPU 运算器的位数\n  - CPU 中通用寄存器的宽度\n- **字**表示被处理信息的单位\n  - 度量数据类型的宽度\n  - 字和字长的宽度可以一样，也可不同\n  - x86体系结构，不管字长多少，**字**的宽度都为16位，而从80386开始**字长**就是32位了\n  - MIPS 32体系结构，其字和字长都是32位\n\n\n\n\n\n\n\n","meta":{"size":7786,"birthTime":1663496641437.8691,"updateTime":1663496641438.054}}},"__N_SSG":true}
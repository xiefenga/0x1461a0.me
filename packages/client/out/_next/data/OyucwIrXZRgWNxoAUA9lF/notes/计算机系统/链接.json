{"pageProps":{"metaTitle":"链接","article":{"title":"链接","content":"## C 语言转换过程\n\n用 GCC 编译器套件进行转换的过程：\n\n1. 预处理：在高级语言源程序中插入所有用 `#include` 命令指定的文件和用 `#define` 声明指定的宏\n\n2. 编译：将预处理后的源程序文件编译生成相应的汇编语言程序\n\n3. 汇编：由汇编程序将汇编语言源程序文件转换为**可重定位的机器语言目标代码文件**\n\n4. 链接：由**链接器**将多个可重定位的机器语言目标文件以及库例程（如 `printf` 库函数）链接起来，生成最终的**可执行目标文件**\n\n\n![](https://oss.xiefeng.tech/images/20211026231522.png)\n\n### 预处理\n\n处理源文件中以“#”开头的预编译指令\n\n- 删除 `#define` 并展开所定义的宏\n- 处理所有条件预编译指令，如 `#if`、`#ifdef`、`#endif` 等\n- 插入头文件到 `#include` 处，并递归的处理\n- ......\n\n使用 cpp 程序可以得到源文件预处理之后的结果，gcc 实际上是具体程序（如ccp、cc1、as等）的包装命令\n\n```shell\n$ cpp hello.c > hello.i\n$ gcc –E hello.c –o hello.i\n```\n\n经过预编译处理后，得到的预处理文件还是一个可读的文本文件 ，但不包含任何的宏定义\n\n### 编译\n\n编译过程就是将预处理后得到的预处理文件进行词法分析、语法分析、语义分析，优化后生成汇编代码文件\n\n使用 gcc 可以得到经过编译之后的文件\n\n```shell\n$ gcc –S hello.i –o hello.s\n# 也可以直接通过源文件得到编译之后的文件\n$ gcc –S hello.c –o hello.s\n```\n\n经过编译后，得到的汇编代码文件依旧是可读的文本文件，但是 CPU 无法理解和执行它\n\n### 汇编\n\n汇编程序用来将汇编语言源程序转换为机器指令序列\n\n汇编结果是一个**可重定位目标文件**，其中包含的是不可读的二进制代码，必须用相应的工具软件来查看其内容\n\n可以通过 as 程序进行汇编操作\n\n```shell\n$ gcc –c hello.c –o hello.o\n$ gcc –c hello.s –o hello.o\n$ as hello.s -o hello.o\n```\n\n### 链接\n\n预处理、编译和汇编三个阶段针对一个模块进行处理，得到对应的一个可重定位目标文件\n\n链接过程将多个可重定位目标文件合并以生成一个**可执行目标文件**\n\n`–static` 表示执行静态链接操作\n\n```shell\n$ gcc –static –o myproc main.o test.o\n$ ld –static –o myproc main.o test.o\n```\n\n## 链接\n\n最早程序员用机器语言编写程序，并记录在纸带或卡片上，当增加或删除某一条指令时则，则需要修改其中的 jump 指令的目标地址，以及需要重新打孔，这是非常麻烦的\n\n原始的链接概念早在高级编程语言出现之前就已存在，在使用汇编进行编程时往往会使用符号表示跳转和变量的位置，这样即使需要修改程序这些也不会受影响，只需要最终将符号替换为该符号定义的地址即可，这个替换过程就称为**链接**\n\n链接可以带来一些好处\n\n- 一个程序可以分成很多源程序文件，实现模块化\n  - 可以构建公共的函数库\n- 可以将源文件分开编译，最后将它们链接即可\n  - 只需重新编译被修改的源程序文件，然后重新链接\n- 源文件中无需包含共享库函数的源码，只要直接调用即可\n\n## 目标文件\n\n所谓的目标文件就是\n\n最早的目标文件格式是自有格式，非标准的，标准的几种目标文件格式\n\n- DOS操作系统(最简单) :COM格式，文件中仅包含代码和数据，且被加载到固定位置\n\n\n\n## ELF 目标文件\n\nELF 称为可执行可链接（Executable and Linkable Format），ELF 文件具有两种视图，也就是说有两种不同的文件都采用该种格式\n\nELF 具有两种视图：\n\n- 链接视图：可重定位目标文件\n- 执行视图：可执行目标文件\n\n### ELF头\n\nELF头位于文件的开始位置，它的主要目的是定位文件的其他部分\n\nELF32 header的类型定义为 [`elf32_hdr`](https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h#L205)，ELF64 header 的类型定义为 [`elf64_hdr`](https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h#L220)\n\n通过 `readelf` 程序可以查看 EFL 文件的各部分信息\n\n```shell\n$ readelf -h hello.o\n```\n\n![](https://oss.xiefeng.tech/images/20211106183508.png)\n\n### 链接视图\n\n链接视图所对应的文件为**可重定位目标文件**，其中包含的内容为：\n\n- ELF 头：位于文件的开始位置，主要目的是定位文件的其他部分\n- 节（section）：程序编译后的代码和数据等信息都存储在各种节中\n  - .text 节中存储的是编译后的代码部分（一条一条的指令）\n  - .rodata 节中存储的是只读数据，如字符串字面量、switch 跳转表等\n  - .data 节中存储的是已初始化的全局变量\n  - .bss 节中存储的是未初始化全局变量\n    - 在磁盘空间层面不存在该部分，该部分存在于逻辑上\n    - 主要目的是优化空间效率，将初始化和未初始化的变量分开\n  - .symtab 节：存放函数和全局变量（符号表）信息\n  - .rel.text 节：.text 节的重定位信息，用于重新修改代码段的指令中的地址信息\n  - .rel.data 节： .data节的重定位信息，用于对被模块使用或定义的全局变量进行重定位的信息\n  - .debug 节：调试用符号表 (gcc -g)\n  - strtab 节：包含 symtab 和 debug 节中符号及节名\n- 节头表：存储了每个节的节名、偏移和大小\n\n\n\n\n\n\n\n\n\n\n\n","meta":{"size":5556,"birthTime":1663496641438.482,"updateTime":1663496641438.6865}}},"__N_SSG":true}
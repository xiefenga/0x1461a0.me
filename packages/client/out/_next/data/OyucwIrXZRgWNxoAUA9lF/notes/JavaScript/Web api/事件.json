{"pageProps":{"metaTitle":"事件","article":{"title":"事件","content":"# 事件注册\r\n\r\n- `dom.onxxx = function () {}`\r\n  - dom0 的方式\r\n  - 移除事件：`dom.onxxx = null / undefined`\r\n  - 对于同一个元素同一个事件只能绑定一个事件处理程序，同一个事件的后绑定的事件处理程序覆盖前一个\r\n- `dom.addEventListener(type, handle, false)`\r\n  - dom2的方式\r\n  - 移除事件：`dom.removeEventListener(type, handle, false)` \r\n  - 第三个参数用于控制该事件处理函数是否属于事件捕获阶段\r\n  - 对同一事件注册多个处理程序（不可为同一函数），触发顺序和绑定顺序吻合\r\n- `dom.attachEvent('on'+type, handle)`\r\n  - IE8及以下得用这种方式注册事件替代 dom2 的方式\r\n  - 这也可以注册多个处理程序\r\n  - 移除事件：`detachEvent('on'+type, handle)`\r\n\r\n# 事件流\r\n\r\n当一个元素发生了某个事件时，那该元素的所有**祖先元素**及**整个页面**都发生了该事件，事件流即描述页面接收事件的顺序\r\n\r\n1. 事件冒泡\r\n\r\n2. 事件捕获\r\n\r\n通过 `addEventListenr(type, handle, true)` 可将事件注册为事件捕获阶段发生\r\n\r\n对于事件源来说不存在事件捕获和事件冒泡，都是事件执行\r\n\r\n**对于同一事件这两种处理模型的触发顺序：**先捕获，后冒泡\r\n\r\n# 事件对象\r\n\r\n1. 事件源对象：`event.target || event.srcElement`\r\n2. 事件类型：`event.type`\r\n3. 事件所处阶段（冒泡、捕获）：`event.eventPhase`\r\n4. 当前绑定事件的元素：`event.currentTarget`  等效于 `this`\r\n\r\n## 事件委托\r\n\r\n通过事件冒泡和事件源对象可以实现事件委托\r\n\r\n即通过给祖先元素注册事件，在程序处理程序中判断事件源进行不同的处理\r\n\r\n## 阻止默认事件\r\n\r\n- `return false` dom 0 的方式才有效\r\n- `event.preventDefault()` 标准，ie8-\r\n- `event.returnValue = false`  兼容IE\r\n\r\n## 阻止事件冒泡\r\n\r\n- `event.stopPropagation()` 标准\r\n- `event.cancelBubble = true` IE\r\n\r\n# 事件类型\r\n\r\n浏览器中可以发生很多种事件，所发生事件的类型决定了事件对象中会保存什么信息\r\n\r\nDOM3 Events 定义的事件类型：\r\n\r\n- 用户界面事件：涉及与 BOM 交互的通用浏览器事件\r\n- 焦点事件：在元素获得和失去焦点时触发\r\n- 鼠标事件：使用鼠标在页面上执行某些操作时触发\r\n- 滚轮事件：使用鼠标滚轮（或类似设备）时触发\r\n- 输入事件：向文档中输入文本时触发\r\n- 键盘事件：使用键盘在页面上执行某些操作时触发\r\n- 合成事件：在使用某种 IME（Input Method Editor，输入法编辑器）输入字符时触发\r\n\r\n## UI事件\r\n\r\nUI 事件不一定跟用户操作有关，在 DOM 规范出现之前就已经以某种形式存在了，保留它们是为了向后兼容\r\n\r\n- `load`\r\n\t- 当一个资源及其依赖**资源**已**完成加载**时触发load事件\r\n\t- 在 window 上当页面加载完成后触发\r\n\t- 在 `img` 元素上当图片加载完成后触发\r\n\t- 根据 DOM2 Events，load 事件应该在 document 上触发\r\n\t- 为了向后兼容，所有浏览器都在 window 上实现了该事件\r\n\t\r\n- `beforeunload`\r\n\r\n\t- 该事件在 window 上触发，用意是给开发者提供阻止页面被卸载的机会\r\n\t- 在页面即将从浏览器中卸载时触发（关闭、刷新）\r\n\t- 这个事件会向用户显示一个确认框，请用户确认是关闭页还是取消关闭\r\n\t- `event.returnValue` 设置为要提示的字符串，函数返回该字符串（对于 Chrome 和 Safari）\r\n\t\r\n- `unload`\r\n\r\n\t- 在 window 上当页面完全卸载后触发\r\n\t- 一般是在从一个页面导航到另一个页面时触发\r\n\t- 它在 `beforeunload` 和 `pagehide`（例如回退）后被触发\r\n\t\r\n- `error`\r\n\r\n  - 在 window 上当 JavaScript 报错时触发\r\n  - 在 `img` 元素上当图片加载失败时触发\r\n  \r\n- `resize`\r\n\t- 在 window 或窗格上当窗口或窗格被缩放时触发\r\n\t- 最大化、最小化也会触发该事件\r\n\t\r\n- `scroll`\r\n\r\n\t- 当用户滚动包含滚动条的元素时在元素上触发\r\n\t- `body` 元素包含整个页面的滚动条\r\n\t\r\n- `contextmenu`\r\n\r\n\t- 专门用于表示何时该显示上下文菜单\r\n\t- 允许开发者取消默认的上下文菜单并提供自定义菜单\r\n\t- 该事件冒泡，只要给 document 指定一个事件处理程序就可以处理页面上的所有同类事件\r\n\t\r\n- `DOMContentLoaded`\r\n  - DOM 树构建完成后立即触发\r\n  - `document`、`window` 都能触发（实际是 `document`，冒泡到 `window`）\r\n  - 对于不支持该事件的浏览器，可以通过 `setTimout` 0 来实现\r\n  \r\n- `readystatechange`\r\n\r\n  - 支持该事件的每个对象都有一个 `readyState` 属性，该属性可能具有的值：\r\n  \t- `uninitialized`：对象存在并尚未初始化\r\n  \t- `loading`：对象正在加载数据\r\n  \t- `loaded`：对象已经加载完数据\r\n  \t- `interactive`：对象可以交互，但尚未加载完成\r\n  \t- `complete`：对象加载完成\r\n  - 并非所有对象都会经历所有 readystate 阶段\r\n  - document 上触发时，readyState 的值首先为 `interactive`\r\n  - `document.readyState` 属性描述了文档的加载状态\r\n  \t1. `loading`：document 仍在加载\r\n  \t2. `interactive`：文档**解析**完成，先于 `DOMContentLoaded` 事件触发\r\n  \t3. `complete`：文档和所有子资源已完成加载，`load` 事件即将被触发\r\n  \r\n- `pageshow`、`pagehide`\r\n\r\n  - Firefox 和 Opera 开发了一个名为往返缓存功能，旨在使用浏览器“前进”和“后退”时加快页面之间的切换\r\n- 如果页面在缓存中，那么导航到这个页面时就 不会触发 load 事件\r\n  - Firefx 决定提供一些事件，把往返缓存的行为暴露出来\r\n- `pageshow` 会在页面显示时触发，无论是否来自往返缓存\r\n  \r\n  - 在新加载的页面上， pageshow 会在 load 事件之后触发\r\n  \r\n  - 在来自往返缓存的页面上，pageshow 会在页面状态完全恢复后触发\r\n  \r\n- 这个事件的目标是 document，但事件处理程序必须添加到 window 上\r\n  - pagehide 事件会在页面从浏览器中卸载后，在 unload 事件之前触发\r\n-  event 对象中有一个 persisted 属性，该属性指示页面是否存储在往返缓存中\r\n    - pageshow 事件表明页面是从往返缓存中加载的\r\n  - pagehide 事件表明页面卸载之后会被保存在往返缓存中\r\n  - 注册了onunload 事件处理程序(即使是空函数)的页面会自动排除在往返缓存之外\r\n\r\n- `hashchange`\r\n  \r\n  - 在 URL hash 发生变化时通知开发者\r\n  - hashchange 事件处理程序必须添加给 window\r\n  - event 对象有两个新属性：oldURL 和 newURL，是包含散列值的完整 URL\r\n\r\n## 焦点事件\r\n\r\n焦点事件在页面元素获得或失去焦点时触发，\r\n\r\n- `blur`：当元素失去焦点时触发，这个事件不冒泡\r\n- `focus`：当元素获得焦点时触发，这个事件不冒泡\r\n- `focusin`：当元素获得焦点时触发，这个事件是 focus 的冒泡版\r\n- `focusout`：当元素失去焦点时触发，这个事件是 blur 的通用版\r\n\r\n## 鼠标事件\r\n\r\n### 移动事件\r\n\r\n- `mouseover`、`mouseout`\r\n\t- 从父元素移动到子元素，对于父元素而言，仍然算作离开\r\n\t- 这两个事件冒泡\r\n- `mouseenter`、`mouseleave`\r\n\t- 子元素仍然是父元素的一部分，从父元素到子元素不算离开\r\n\t- 这两个事件不冒泡\r\n\r\n除了 `mouseenter` 和 `mouseleave`，所有的鼠标事件都会冒泡。\r\n\r\n### 点击事件\r\n\r\n点击事件的执行顺序： `mousedown`、`mouseup`、`click`、`mousedown`、`mouseup`、`click`、`dbclick`\r\n\r\n事件之间存在关系，取消鼠标事件的默认行为会影响其他事件：\r\n\r\n- `mousedown` 和 `mouseup` 中的任意一个事件被取消，`click` 事件就不会触发\r\n\r\n- `mousedown`、`mouseup` 、`click` 中任意被取消，`dbclick` 不会触发\r\n\r\n### 事件对象\r\n\r\n所有的鼠标事件，都为 `MouseEvent` 类型对象\r\n\r\n- `e.button` 可以区分鼠标按键\r\n\t- 0 主键、1 中键、2 次键\r\n- `e.detail` \r\n\t- 表示在该位置发生多少次点击\r\n\t- 如果 `mousedown` 和 `mouseup` 的位置不同，则重新开始计数\r\n- 坐标\r\n\t- `pageX`、`pageY`  当前鼠标距离页面的坐标\r\n\t- `clientX`、`clientY`  当前鼠标相对于视口的坐标\r\n\t- `offsetX`、`offsetY`  鼠标相对于**事件源**的**内边距**的坐标\r\n\t- `screenX`、`screenY` / `x`、`y`  鼠标相对于屏幕的坐标\r\n\t- `movementX`、`movementY`  只在 `mousemove` 中有效，相对于**上一次鼠标位置偏移**的距离\r\n- 按键\r\n\t- `altKey`  触发事件时，是否按下了键盘的alt键\r\n\t- `ctrlKey`  触发事件时，是否按下了键盘的ctrl键\r\n\t- `shiftKey`  触发事件时，是否按下了键盘的shift键\r\n\r\n- `e.wheelData`\r\n\t- `mousewheel` 事件\r\n\t- 向前滚动，`e.wheelData` 是 120 的倍数\r\n\t- 向后滚动，`e.wheelData` 是 -120 的倍数\r\n\r\n## 键盘事件\r\n\r\n- `keydown`\r\n\t- 按下键盘上任意键触发\r\n\t- 按住不放，会重复触发此事件\r\n- `keypress`\r\n\t- 按下键盘上一个**字符键**时触发，包括 ESC\r\n\t- DOM3 Events 废弃了 该事件，推荐 textInput 事件\r\n- `keyup`\r\n\t- 抬起键盘上任意键触发\r\n\r\n响应顺序：`keydown` 、`keypress` 、`keyup` \r\n\r\n区别：`keydown`、`keypress` 如果阻止了事件默认行为，文本不会显示\r\n\r\n事件对象为 `KeyboardEvent` 类型\r\n\r\n- `event.code`  得到按键字符串，适配键盘布局\r\n- `event.key`  得到按键字符串，不适配键盘布局\r\n\r\n## 表单事件\r\n\r\n- `submit`  提交表单事件，仅在 form 元素上有效\r\n- `change`  域的内容改变并且失去焦点时事件会触发\r\n- `input`  文本改变事件，即时触发\r\n- `select`：在文本框上当用户选择了一个或多个字符时触发\r\n\r\n## 设备事件\r\n\r\n- `deviceorientationchange`：检测设备的方向变化\r\n\t- `e.alpha`    围绕 z 轴旋转是，y 轴的度数差\r\n\t- `e.beta`     围绕 x 轴旋转时，z 轴的度数差\r\n\t- `e.gamma`   围绕 y 轴旋转时，z 轴的度数差\r\n\t- `e.absolute ` 表示设备是否返回一个绝对值\r\n\t- `e.compassCalibrated `  设备的指南针是否校准过\r\n- `devicemotion`：设备移动\r\n  - `e.acceleration`  x y z 每个方向上的加速度\r\n  - `e.accelerationIncludingGravity `  在考虑 z 轴自然重力加速度的情况下，x y z 每个方向上的加速度\r\n  - `e.interval `\r\n  - `e.rotationRate ` 一个包含 alpha beta gamma 的对象\r\n\r\n# 事件模拟\r\n\r\n1. 使用 `document.createEvent()` 方法创建一个 event 对象\r\n   - `'UIEvents'`：通用用户界面事件(鼠标事件和键盘事件都继承自这 个事件)\r\n   - `'MouseEvents'`：通用鼠标事件\r\n   - `'HTMLEvents'`：通用 HTML 事件(HTML 事件已经分散到了其他事件大类中，DOM3中没有该类事件)\r\n   - 在 DOM2 中，所有这些字符串都是英文复数形式，但在 DOM3 中，又把它们改成了英文单数形式\r\n2. 初始化事件，每种类型的 event 对象都有特定的方法\r\n3. 使用 `dom.dispatchEvent()` 分发事件\r\n\r\n通过手动分发 input 事件来触发 react onChange 事件：\r\n\r\n```javascript\r\n// init 事件\r\nconst event = document.createEvent('UIEvent')\r\nevent.initEvent('input', true, true)\r\n\r\n// 原生 set ，清空\r\nnativeInputValueSetter!.call(inputRef.current, '')\r\n\r\n// 手动分发事件，触发 react onChange\r\ninputRef.current.dispatchEvent(event)\r\n```\r\n\r\n","meta":{"size":11459,"birthTime":1663496641400.5376,"updateTime":1663496641400.7612}}},"__N_SSG":true}
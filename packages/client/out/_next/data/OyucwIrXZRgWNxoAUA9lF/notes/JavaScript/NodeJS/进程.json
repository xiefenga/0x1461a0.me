{"pageProps":{"metaTitle":"进程","article":{"title":"进程","content":"# 进程\r\n\r\n`process` 提供有关当前 Node.js 进程的信息并对其进行控制\r\n\r\n## 信息\r\n\r\n- `argv`：返回启动 Node.js 进程时传入的命令行参数组成的数组\r\n- `channel`：如果该进程是被创建的子进程，则该属性是对 IPC 通道的引用\r\n- `env`：返回包含用户环境的对象\r\n- `pid`：返回当前进程的进程 id\r\n- `ppid`：返回父进程的 id\r\n\r\n## 事件\r\n\r\n- `message`：收到父进程通过 IPC 发送的消息时触发\r\n- `unhandledRejection`：`Promise` 被拒绝并且在事件循环的一个轮询内没有添加错误句柄处理时触发\r\n- `rejectionHandled`：每当 `Promise` 被拒绝并且错误句柄被附加时晚于一轮事件循环时触发\r\n- `exit`：进程退出时触发，进程退出时机：\r\n\t-  `process.exit()` 方法被显式调用\r\n\t- 事件循环不再需要执行任何额外的工作\r\n\r\n## 方法\r\n\r\n- `exit`：指示 Node.js 以指定的退出状态同步终止进程，默认为 0 （成功）\r\n- `cwd`：返回 Node.js 进程的当前工作目录\r\n- `kill`：杀死指定 id 的进程，实际上只是一个信号发送者，就像 `kill` 系统调用一样\r\n\r\n# 子进程\r\n\r\n通过 `child_process` 模块可以创建子进程，并可以通过 IPC 与子进程进行通信。\r\n\r\n## 创建\r\n\r\n异步创建方式：\r\n\r\n- `exec`：创建一个子进程（shell）执行命令，通过回调（子进程退出时调用）可以获取 shell 的输出\r\n- `spawn`：创建一个子进程（shell）执行命令，但是没有回调去获取输出\r\n- `execFile`：创建一个子进程执行可执行文件，如果是 js 文件则文件开头必须有 `#!/user/bin/env node` \r\n- `fork`：创建一个子进程执行 js 文件\r\n\r\n```javascript\r\n// exec\r\nconst child = exec('node -v',  (err, stdout, stderr) => console.log(stdout));\r\n\r\n// spawn\r\nconst child = spawn('node', ['-v']);\r\nchild.on('spawn', () => child.stdout.pipe(process.stdout));\r\n\r\n// execFile\r\nconst child = execFile('./worker.js');\r\n\r\n// fork\r\nconst child = fork('./worker.js');\r\n```\r\n\r\n## 通信\r\n\r\n实现进程间通信的方式有很多，比如：管道、socket、信号量、共享内存、消息队列、Domain Socket等。\r\n\r\nNode 实现 IPC 采用的管道（抽象层面的称呼），具体的细节由 libuv 实现：在 windows 下采用命名管道实现，而*nix系统则采用 Unix Domain Socket 实现。\r\n\r\n对于上层的暴露的接口十分简单，通信方式只有 `send` 方法和 `message` 事件。\r\n\r\n```javascript\r\nconst worker = fork(join(__dirname, './worker.js'));\r\n// 子进程创建成功触发此事件\r\nworker.on('spawn', () =>  worker.send('hello'));\r\n\r\n// worker.js\r\n\r\nconsole.log('子进程启动成功, processID:', process.pid);\r\n\r\nprocess.on('message', msg =>  console.log('子进程收到消息:', msg));\r\n```\r\n\r\n具体的过程：\r\n\r\n1. 父进程在实际创建子进程之前，会先创建IPC通道并监听它，然后再真正的创建子进程。\r\n2. 通过环境变量 `NODE_CHANNEL_FD` 告知子进程 IPC 通道的文件描述符\r\n3. 子进程在启动过程中，根据文件描述符去连接该 IPC 通道\r\n\r\n```mermaid\r\nflowchart LR\r\nprocess(父进程) --创建--> child_process(子进程)\r\nprocess(父进程) --监听/接收--> IPC(IPC通道)\r\nchild_process(子进程) --连接--> IPC(IPC通道)\r\n```\r\n\r\n异步创建的子进程会返回一个 `ChildProcess` 的实例，表示创建的子进程，通过该实例可以向 IPC 通道传递信息。\r\n\r\n**事件：**\r\n\r\n- `spawn`：子进程创建成功触发\r\n- `message`：收到子进程的消息触发\r\n- `exit`：子进程退出触发\r\n\r\n**方法：**\r\n\r\n- `send`：向子进程发送消息，会触发子进程的 `message` 事件\r\n- `kill`：kill 该子进程，接着触发 `exit` 事件\r\n\r\n## 句柄传递\r\n\r\n`send` 方法除了可以发送一般的数据，还可以传递句柄（文件描述符）目前只支持传递 TCP 和 UDP 套接字。\r\n\r\n利用 `send` 发送套接字即可实现多个子进程监听同一个端口：\r\n\r\n```javascript\r\n// master.js\r\nconst server = createServer(socket => socket.end('父进程处理请求'));\r\n\r\nconst workers = new Map();\r\n\r\nfor (let i = 0; i < cpus().length; i++) {\r\n    const worker = fork('./worker.js');\r\n    workers.set(worker.pid, worker);\r\n}\r\n\r\nserver.listen(8080, () => workers.forEach(w => w.send('server', server)));\r\n\r\n// worker.js\r\nprocess.on('message', (msg, server) => {\r\n    if (msg === 'server') {\r\n        server.on('connection', socket => socket.end(`子进程 ${process.pid} 处理请求`));\r\n    }\r\n});\r\n```\r\n\r\n当多个进程监听同一个端口，一个连接只能被一个进程所处理，目前仅在 Unix 平台上支持。\r\n\r\n**句柄的发送和还原**\r\n\r\n发送到 IPC 管道中的文件描述符（句柄），实际上就是一个整数值。\r\n\r\n而发送的消息先会被封装成一个对象，接着会被 `JSON.stringify` 序列化：\r\n\r\n```json\r\n{\r\n    cmd: \"NODE_HANDLE\",\r\n    type: \"net.Server\",\r\n    msg: message\r\n}\r\n```\r\n\r\n当子进程接收到父进程发来的消息，会先通过 `JSON.parse` 解析消息，然后触发 `message` 事件将消息传递上去。\r\n\r\n```mermaid\r\ngraph LR\r\nprocess(父进程) --发送--> 序列化 --写入-->IPC((IPC)) -- 读取--> 解析数据 --消息--> child_process(子进程)\r\n```\r\n\r\n在这个过程中，如果消息对象的 `message.cmd` 以 `NODE_` 为前缀则会响应一个内部事件 `internalMessage`。\r\n\r\n如果 `message.cmd` 的值为 `NODE_HANDLE`，则会依据 `message.type` 的值和文件描述符一起还原出一个对象。\r\n\r\n具体的就是如果 `message.type` 值为 `net.Socket` 则会创建一个 TCP 服务器对象，并让该对象监听文件描述符。\r\n\r\n我们在 `message` 事件处理程序中得到的 `handle` 就是这个新创建的 `net.Server` 对象。\r\n\r\n```javascript\r\n// 伪代码\r\nconst server = new net.Server();\r\nserver.listen(fd);\r\n```\r\n\r\n而多个应用监听相同的端口时，文件描述符同一时间只能被一个进程所使用，所以当来请求时只有一个进程能够幸运的抢到连接。\r\n\r\n# 集群\r\n\r\n`cluster` 模块可以创建共享服务器端口的子进程，使用 `child_process` 构建集群比较麻烦需要解决许多问题。\r\n\r\n```javascript\r\nconst cluster = require('cluster');\r\nconst http = require('http');\r\nconst count = require('os').cpus().length;\r\n\r\nif (cluster.isMaster) {\r\n    // 衍生工作进程。\r\n    for (let i = 0; i < count; i++) {\r\n        cluster.fork();\r\n    }\r\n} else {\r\n    console.log(`工作进程 ${process.pid} 已启动`);\r\n    // 工作进程可以共享任何 TCP 连接。\r\n    // 在本例子中，共享的是 HTTP 服务器。\r\n    http.createServer((_, res) => res.end(`工作进程 ${process.pid} 处理请求`)).listen(8000);\r\n}\r\n```\r\n\r\n## 工作原理\r\n\r\n`cluster` 模块就是 `child_process` 和 `net` 的组合应用。\r\n\r\n当 `culster` 启动时会在内部启动 TCP 服务器，父进程会将 TCP 的 socket 发送给子进程。\r\n\r\n通过 `culster.fork` 出来的子进程存在环境变量 `NODE_UNIQUE_ID`，只要子进程中使用了 `listen` 就会通过文件描述符重用端口。\r\n\r\n[cluster 实现原理](https://cnodejs.org/topic/56e84480833b7c8a0492e20c)\r\n\r\n## 功能\r\n\r\n事件：\r\n\r\n- `message`：当集群主进程从任何工作进程接收到消息时触发\r\n- `online`：当衍生一个新的工作进程后，工作进程应当响应一个上线消息\r\n\r\n- `exit`：当任何一个工作进程关闭的时候，cluster 模块都将会触发 `'exit'` 事件\r\n\r\n方法：\r\n\r\n- `setupMaster`：用于修改默认的 'fork' 行为，只能主进程调用\r\n- `fork`：衍生出一个新的工作进程，只能主进程调用\r\n\r\n可以通过 `setupMaster` 方法将主进程和子进程在代码上分开。\r\n\r\n```javascript\r\nconst { setupMaster, fork } = require('cluster');\r\nconst cpus = require('os').cpus().length;\r\nsetupMaster({\r\n    exec: 'worker.js'\r\n});\r\nfor (let i = 0; i < cpus; i++) {\r\n    fork();\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","meta":{"size":7989,"birthTime":1663496641396.0278,"updateTime":1663496641396.124}}},"__N_SSG":true}
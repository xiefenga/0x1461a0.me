{"pageProps":{"metaTitle":"迭代器","article":{"title":"迭代器","content":"# 迭代器\n\n如果一个对象具有 `next` 方法，并且该方法返回一个特定格式的对象，则认为该对象是一个**迭代器**，格式如下：\n\n```typescript\ninterface IteratorResult {\n  done: boolean\n  value: any\n}\n```\n\n## 部署接口\n\nES6 规定，默认的 Iterator 接口部署在数据结构的 `Symbol.iterator` 属性上，该方法是一个迭代器创建函数\n\n**迭代器创建函数：** 用于创建一个迭代器对象的函数\n\n原生部署了 Iterator 接口的数据结构：\n\n- Array、Map、Set、String、TypedArray、arguments\n- NodeList\n\n调用了 Iterator 接口的地方：\n\n- 展开运算符（除了对象的展开）本质上是调用的是 Iterator 接口\n\n- 数组和 `set` 的解构本质上调用的也是 Iterator 接口\n\n- 部署了 `Symbol.iterator` 接口，即可被 `for...of` 循环所遍历\n- `yield* ` 后面跟的是一个可遍历的结构，它会调用该结构的 Iterator 接口\n- `Array.from`、`Map`、`Set`、`Promise.all` 等方法\n\n## 其他方法\n\n迭代器对象除了具有 `next` 方法，还可以具有 `return` 方法和 `throw` 方法，`next` 方法是必须部署的，`return` 方法和 `throw` 方法是否部署是可选的\n\n如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 `return` 方法，该方法必须返回一个对象，这是 Generator 语法决定的\n\n如果 `for...of` 循环提前退出，就会调用 `return` 方法。\n\n# 生成器\n\n调用生成器函数会返回一个生成器，生成器也是一个迭代器。该迭代器代表该生成器函数的内部指针，控制函数的执行。\n\n该迭代器的原型链上部署了 `Symbol.iterator` 接口，调则返回自己。\n\n```javascript\nfunction* gen() {}\nconst g = gen();\nconsole.log(g[Symbol.iterator]() === g);\t// true\n```\n\n每次调用 `next` 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 `yield` 表达式（或 `return` 语句）\n\n`yield` 表达式本身没有返回值，或者说总是返回 `undefined`，而 `next` 方法可以带一个参数，该参数就会被当作上一个 `yield` 表达式的返回值。\n\n```javascript\nfunction* numbers() {\n  const one = yield 1\n  console.log(one)\n  const two = yield 2\n  console.log(two)\n}\nconst g = numbers()\ng.next()\ng.next()\t// undefine\ng.next(2)\t// 2\n```\n\n## throw\n\nGenerator 函数返回的生成器，都有一个 `throw` 方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。\n\n- `throw` 方法抛出的错误要被内部捕获，前提是必须至少执行过一次 `next` 方法\n- `throw` 方法被**捕获**以后，会附带执行下一条 `yield` 表达式\n\n```javascript\nfunction* gen(){\n  try {\n    yield 'a'\n  } catch (__) { }\n  yield 'b'\n  yield 'c'\n}\nconst g = gen()\ng.next() // a\ng.throw() // b\n```\n\n## return\n\nGenerator 函数返回的遍历器对象，还有一个 `return` 方法，可以返回给定的值，并且终结遍历 Generator 函数。\n\n迭代器调用 `return` 方法后，返回值的 `value` 属性就是 `return` 方法的参数\n\n```javascript\nfunction* numbers() {\n  yield 1\n  yield 2\n}\n\nconst g = numbers()\ng.return(7)\t// {value: 7, done: true}\n```\n\n如果 Generator 函数内部有 `try...finally` 代码块，且正在执行 `try` 代码块，那么 `return` 方法会导致立刻进入 `finally` 代码块，执行完以后，整个函数才会结束。\n\n```javascript\nfunction* numbers () {\n    yield 1;\n    try {\n        yield 2;\n        yield 3;\n    } finally {\n        yield 4;\n        yield 5;\n    }\n    yield 6;\n}\nconst g = numbers();\ng.next() // { value: 1, done: false }\ng.next() // { value: 2, done: false }\ng.return(7) // { value: 4, done: false }\ng.next() // { value: 5, done: false }\ng.next() // { value: 7, done: true }\n```\n\n## yield*\n\n任何数据结构只要有 Iterator 接口，就可以被 `yield*` 遍历。\n\n`yield*` 一般用来在一个 Generator 函数里面执行另一个 Generator 函数。\n\n如果被代理的 Generator 函数有 `return` 语句，那么就可以向代理它的 Generator 函数返回数据。\n\n```javascript\nfunction* foo() {\n    yield 2;\n    yield 3;\n    return \"foo\";\n}\n\nfunction* bar() {\n    yield 1;\n    var v = yield* foo();\n    console.log(\"v: \" + v);\n    yield 4;\n}\n\nconst it = bar();\nit.next();\t// {value: 1, done: false}\nit.next();\t// {value: 2, done: false}\nit.next();\t// {value: 3, done: false}\nit.next();\t// \"v: foo\"\t// {value: 4, done: false}\nit.next();\t// {value: undefined, done: true}\n```\n\n## 执行上下文\n\nJavaScript 代码运行时，会产生一个全局的上下文环境，包含了当前所有的变量和对象。执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前的上下文，由此形成一个上下文环境的堆栈。\n\n最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。\n\nGenerator 函数不是这样，它执行产生的上下文环境，一旦遇到 `yield` 命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行 `next` 命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。\n\n# 异步应用\n\nGenerator 函数可以将异步的代码以同步的方式书写。\n\n但是由于 Generator 函数无法自动执行，需要借助外部来执行。\n\n## Thunk函数\n\nThunk 函数是自动执行 Generator 函数的一种方法。\n\nThunk 函数的作用是将多参数函数替换成一个只接受回调函数作为参数的单参数函数。\n\n```javascript\nfunction Thunk(fn) {\n  return function (...args) {\n    return function (callback) {\n      return fn.call(this, ...args, callback);\n    }\n  };\n};\n```\n\n实现自动执行的执行器：\n\n```javascript\nfunction run(fn) {\n  const gen = fn();\n\n  function next(err, data) {\n    const result = gen.next(data);\n    if (result.done) {\n      return;\n    }\n    result.value(next);\t// result.value 是一个函数\n  }\n\n  next();\n}\n```\n\n## co模块\n\n> co 模块是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator 函数的自动执行。\n\nco 模块可以让你不用编写 Generator 函数的执行器\n\n```javascript\nvar co = require('co');\nco(gen);\n```\n\nGenerator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。\n\nThunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。\n\nco 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的`yield` 命令后面，只能是 Thunk 函数或 Promise 对象。\n\n如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co，实现并发的异步操作。\n\n## 简易实现\n\n可以很简单的实现一个能够自动执行 Generator 函数的执行器。Thunk 函数太绕了，可以只考虑使用 Promise，很容易就能实现。\n\n```javascript\nfunction run(gen) {\n  const i = gen();\n  next(i.next());\n\n  function next(res) {\n    if (res.done) {\n      return;\n    } else if (typeof res.value.then === \"function\") {\n      res.value.then(data => next(i.next(data)))\n    } else {\n      next(i.next(res.value));\n    }\n  }\n}\n```\n\n# async函数\n\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\n\nasync 简单来说是 Generator 函数的语法糖，区别在于 async函数可以自执行，不需要执行器。而且语义更好、兼容性更好。\n\n**async函数的实现原理**\n\nasync 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里：\n\n```javascript\nasync function fn(args) { }\n\n// 等同于\nfunction fn(args) {\n  return spawn(function* () { });\n}\n```\n\n`spawn` 函数就是自动执行器：\n\n```javascript\nfunction spawn(gen) {\n  return new Promise((resolve, reject) => {\n    const i = gen();\n    step(() => i.next())\n    function step(next) {\n      let res;\n      try {\n        res = next();\n      } catch (e) {\n        return reject(e);\n      }\n      const { value, done } = res;\n      if (done) {\n        return resolve(value);\n      }\n      Promise.resolve(value).then(\n        v => step(() => i.next(v)),\n        e => step(() => i.throw(e))\n      )\n    }\n  })\n}\n```\n\n# 异步迭代器\n\n异步遍历器的最大的语法特点，就是调用迭代器的 `next` 方法，返回的是一个 Promise 对象。\n\n一个对象的同步遍历器的接口，部署在 `Symbol.iterator` 属性上面。同样地，异步遍历器接口，部署在 `Symbol.asyncIterator`。\n\n```javascript\nconst obj = {\n  async *[Symbol.asyncIterator]() {\n    const arr = ['a', 'b'];\n    for (const item of arr) {\n      yield Promise.resolve(item)\n    }\n  }\n}\n\nasync function f() {\n  const asyncIterator = obj[Symbol.asyncIterator]();\n  console.log(await asyncIterator.next());\t// { value: 'a', done: false }\n  console.log(await asyncIterator.next());\t// { value: 'b', done: false }\n  console.log(await asyncIterator.next());\t// { value: undefined, done: true }\n}\n\nf();\n```\n\n## for await...of\n\n`for...of ` 循环用于遍历同步的 Iterator 接口，`for await...of` 循环，则是用于遍历异步的 Iterator 接口。\n\n```javascript\nasync function f() {\n  const asyncIterator = obj[Symbol.asyncIterator]();\n  for await (const value of asyncIterator) {\n    console.log(value); // a b\n  }\n}\n```\n\n如果 `next` 方法返回的 Promise 对象被 `reject`，`for await...of` 就会报错，要用 `try...catch` 捕捉。\n\n`for await...of` 循环也可以用于同步迭代器。\n\n## 异步Generator函数\n\n就像 Generator 函数返回一个同步迭代器对象一样，异步 Generator 函数的作用，是返回一个异步迭代器对象。\n\n```javascript\nasync *asyncGenerator() {\n  const arr = ['a', 'b'];\n  for (const item of arr) {\n    yield Promise.resolve(item)\n  }\n}\n```\n\n## yield*\n\n在**异步生成器函数**中 `yield*` 也可以跟一个异步遍历器\n\n```javascript\nasync function* gen1() {\n  yield 'a';\n  yield 'b';\n  return 2;\n}\n\nasync function* gen2() {\n  const result = yield* gen1();\n  console.log(result); // 2\n}\n```","meta":{"size":10536,"birthTime":1663496641394.314,"updateTime":1663496641394.5632}}},"__N_SSG":true}
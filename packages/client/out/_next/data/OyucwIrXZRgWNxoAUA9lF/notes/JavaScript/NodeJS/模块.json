{"pageProps":{"metaTitle":"模块","article":{"title":"模块","content":"# CommonJS \r\n\r\nCommonJS 试图定义一套普通应用程序使用的 API，从而填补 JavaScript 标准库过于简单的不足。\r\n\r\nNode.js 基于 CommonJS 的 Modules/1.0 规范实现了模块，但并未完全遵循。\r\n\r\n> https://neveryu.github.io/2017/03/07/commonjs/\r\n\r\n## 模块封装\r\n\r\n为了实现 CJS 模块化，Node.js 会将每个模块的代码放在一个函数环境执行（通过 `vm` 模块）：\r\n\r\n```javascript\r\n(function(exports, require, module, __filename, __dirname) {\r\n  // 模块代码实际存在于此处\r\n});\r\n```\r\n\r\n通过这样做，Node.js 实现了以下几点：\r\n\r\n- 将顶层变量（用 `var`、`const` 或 `let` 定义）保持在模块而不是全局对象的范围内\r\n- 有助于提供一些实际特定于模块的全局变量：\r\n  - `module` 和 `exports` 对象用来从模块中导出值\r\n  - `__filename` 和 `__dirname` 提供了模块的绝对路径信息\r\n\r\n## module\r\n\r\n每个模块中都存在一个自由变量 `module`，代表着当前模块对象的引用。\r\n\r\n每个 `module` 对象都是 `module` 模块导出的对象 `Module` 的实例。\r\n\r\n```javascript\r\nconst Module = require('module');\r\n\r\nconsole.log(module instanceof Module);  // true\r\n```\r\n\r\n每个模块都具有一些属性，存储着关于当前模块的信息\r\n\r\n- `module.id`：模块的标识符，通过 `require` 时为模块的完全解析文件名，直接运行时为 `.`\r\n- `module.filename`：模块的绝对路径文件名\r\n- `module.path`：模块的绝对路径名\r\n- `module.paths`：模块的搜索路径\r\n- `module.children`：这个模块通过 `require` 导入的模块的 `module` 对象，不包括内置模块\r\n- `module.exports`：用于实现模块导出\r\n\r\n每个模块实例都有一个 `require` 方法\r\n\r\n```javascript\r\nModule.prototype.require = function(path) {\r\n  return Module._load(path, this)\r\n}\r\n```\r\n\r\n`module.require` 和 `require` 一样可以直接导入模块，但不是同一个对象\r\n\r\n## require\r\n\r\n通过 `require` 一个模块的路径或者 `id` 即可运行该模块的代码，并返回模块导出的数据。\r\n\r\n不同于 `module`，每个模块访问到的 `require` 函数都是同一个。\r\n\r\n- `require.cache`：导入过的模块会缓存在此对象中，从此对象中删除键值，下一次 `require` 将重新加载模块\r\n- `require.main`：表示 Node.js 进程启动时加载的入口脚本\r\n- `require.resolve`：解析一个模块名，功能和 `path.resolve` 相同，但找不到模块会抛出 `MODULE_NOT_FOUND` 错误\r\n\r\n**细节：**\r\n\r\n1. 无法使用 `require()` 扩展名为 `.mjs` 的文件\r\n2. 内置模块可以使用 `node:` 前缀标识，这样会绕过缓存\r\n3. 导入文件模块时会依次尝试 `.js`、`.json`、`.node` 文件后缀\r\n4. 目录模块会尝试根据 package.json 的 main 字段查找模块入口，否则使用 `index.js` 作为模块入口\r\n5. 当使用核心模块的标识导入非核心模块会从当前模块**父目录**开始**层层**向上添加 `node_modules` 查找直到文件系统根目录\r\n\r\nNode执行一个脚本时，会先查看环境变量`NODE_PATH`，在其他位置找不到指定模块时，Node会去这些路径查找。\r\n\r\n`NODE_PATH` 是历史遗留下来的一个路径解决方案，通常不应该使用，而应该使用`node_modules`目录机制。\r\n\r\n[require() 源码解读](https://www.ruanyifeng.com/blog/2015/05/require.html) \r\n\r\nhttps://github.com/nodejs/node-v0.x-archive/blob/master/lib/module.js\r\n\r\nrequire 和 module.require 的区别\r\n\r\n`require` 函数是在 `Module.prototype._compile` 函数中定义的一个闭包\r\n\r\n其函数体就只有一行，调用 `module.require` \r\n\r\n# ESM\r\n\r\nNode.js 中启用 ES Module 的方式：\r\n\r\n1. package.json 的 `type` 字段\r\n2. `.mjs` 强制使用 ESM\r\n\r\n## 使用细节\r\n\r\n在 node 中使用 ESM 的细节：\r\n\r\n1. 后缀名不可以省略\r\n2. 不存在 CJS 模块中的特有变量：`module`、`__filename`、`__dirname`\r\n3. 不同于 CJS 模块的同步执行，ESM 的执行具有异步性\r\n4. 通过 `import.meta.url` 可以获取当前模块的路径，但是是 `file` 协议的字符串\r\n5. `import` 也可以导入一个 CJS 模块（只能整体导入），但是 `require` 无法导入 ESM 模块\r\n6. CJS 模块要想导入一个 ESM，需要使用 `import()`\r\n\r\n## 实现__dirname\r\n\r\n通过 `import.meta.url` 获取到的当前模块的路径，不像 `__filename` 那样好使用，也没有 `__dirname`，解决办法：\r\n\r\n```javascript\r\nimport { join } from 'path'\r\nimport { fileURLToPath } from 'url'\r\n\r\nconst __filename = fileURLToPath(import.meta.url);\r\n\r\nconst __dirname = join(__filename, '../');\r\n```\r\n\r\n# 区别\r\n\r\n1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用\r\n2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口\r\n3. CommonJS 模块的 `require` 是同步加载模块，ES6 模块的 `import` 命令是异步加载，有一个独立的模块依赖的解析阶段\r\n\r\n## 动态引用\r\n\r\nJS 引擎对脚本静态分析的时候，遇到模块加载命令 `import` 只会生成一个只读引用，等到脚本真正执行用到导入的值时才会根据引用到被加载的那个模块里面去取值，类似于“符号连接”。\r\n\r\n所以 ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\r\n\r\n```javascript\r\n// lib.js\r\nexport let counter = 3;\r\nexport function incCounter() {\r\n  counter++;\r\n}\r\n\r\n// main.js\r\nimport { counter, incCounter } from './lib';\r\nconsole.log(counter); // 3\r\nincCounter();\r\nconsole.log(counter); // 4\r\n```\r\n\r\nES6 模块输出的变量和模块绑定，是只读的没有办法重新赋值。\r\n\r\n```javascript\r\n// lib.js\r\nexport let obj = {};\r\n\r\n// main.js\r\nimport { obj } from './lib';\r\n\r\nobj.prop = 123; // OK\r\nobj = {}; // TypeError\r\n```\r\n\r\n## 循环加载\r\n\r\nCommonJS 模块遇到循环加载时，返回的是当前**已经执行**的部分的值，而不是代码全部执行后的值，两者可能会有差异。\r\n\r\n```javascript\r\n// a.js\r\nexports.done = false;\r\nvar b = require('./b.js');\r\nconsole.log('在 a.js 之中，b.done = %j', b.done);\r\nexports.done = true;\r\nconsole.log('a.js 执行完毕');\r\n\r\n// b.js\r\nexports.done = false;\r\nvar a = require('./a.js');\r\nconsole.log('在 b.js 之中，a.done = %j', a.done);\r\nexports.done = true;\r\nconsole.log('b.js 执行完毕');\r\n\r\n// main.js\r\nvar a = require('./a.js');\r\nvar b = require('./b.js');\r\nconsole.log('在 main.js 之中, a.done=%j, b.done=%j', a.done, b.done);\r\n```\r\n\r\n运行结果：\r\n\r\n```shell\r\n在 b.js 之中，a.done = false\r\nb.js 执行完毕\r\n在 a.js 之中，b.done = true\r\na.js 执行完毕\r\n在 main.js 之中, a.done=true, b.done=true\r\n```\r\n\r\nES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用`import`从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。\r\n\r\n# 包模块\r\n\r\n`package.json` 文件有两个字段可以指定模块的入口文件：`main` 和 `exports`。\r\n\r\n`exports` 字段的优先级高于 `main` 字段且具有多种用法，`exports` 字段只有支持 ES6 的 Node.js 才认识，所以可以用来兼容旧版本的 Node.js。\r\n\r\n`module` 字段的作用：\r\n\r\n在 Node.js 中引入对 ES 模块的支持之前，包作者的常见模式同时提供 CommonJS 和 ES 模块入口\r\n\r\n通过 `package.json` 的 `main` 指定 CommonJS 入口，使用 `module` 字段指定 ES 模块入口\r\n\r\n这使得 Node.js 能够正常的通过 CommonJS 入口运行，而构建工具可以通过 ES 模块入口进行打包\r\n\r\n因为 Node.js 忽略（并且仍然忽略）顶级 `module` 字段\r\n\r\n## 子目录别名\r\n\r\n```json\r\n{\r\n  \"exports\": {\r\n    \"./submodule\": \"./src/submodule.js\"\r\n  }\r\n}\r\n```\r\n\r\n上面的代码指定 `src/submodule.js` 别名为 `submodule`，通过 `xxx/submodule` 即可导入该文件\r\n\r\n```javascript\r\nimport sub from 'xxx/submodule'\r\n```\r\n\r\n## main的别名\r\n\r\n`exports` 字段的别名如果是 `.`，就代表模块的主入口，并且可以直接简写成 `exports` 字段的值\r\n\r\n```json\r\n{\r\n  \"exports\": {\r\n    \".\": \"./main.js\"\r\n  }\r\n}\r\n```\r\n\r\n对于只有模块的主入口的别名，可以简写：\r\n\r\n```json\r\n{\r\n  \"exports\": \"./main.js\"\r\n}\r\n```\r\n\r\n## 条件加载\r\n\r\n利用 `.` 这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口：\r\n\r\n```json\r\n{\r\n  \"exports\": {\r\n    \".\": {\r\n      \"require\": \"./main.cjs\",\r\n      \"default\": \"./main.js\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n对于只有主模块的别名时可以简写为：\r\n\r\n```json\r\n{\r\n  \"exports\": {\r\n    \"require\": \"./main.cjs\",\r\n    \"default\": \"./main.js\"\r\n  }\r\n}\r\n```\r\n\r\nhttps://nodejs.org/dist/latest-v16.x/docs/api/packages.html#conditional-exports\r\n","meta":{"size":8810,"birthTime":1663496641395.1494,"updateTime":1663496641395.5183}}},"__N_SSG":true}
{"pageProps":{"metaTitle":"AJAX","article":{"title":"AJAX","content":"# XHR\r\n\r\n把 Ajax 推到历史舞台上的关键技术是 XMLHttpRequest(XHR)对象。这个对象最早由微软发明， 然后被其他浏览器所借鉴\r\n\r\n所有现代浏览器都通过 XMLHttpRequest 构造函数原生支持 XHR 对象\r\n\r\n```javascript\r\nconst xhr = new XMLHttpRequest()\r\n```\r\n\r\n## 方法\r\n\r\n1. `xhr.open(method, url, async)`：为发送请求做好准备\r\n2. `xhr.setRequestHeader(key, value)`：为保证请求头部被发送，必须在 `open` 之后、`send` 之前调用\r\n3. `overrideMimeType(mimetype)`：用于重写 XHR **响应**的 MIME 类型，在 `open` 之后、`send` 之前调用\r\n4. `xhr.send(data)`：没有消息体，必须传递 `null`，调用之后就会发送请求\r\n5. `xhr.abort()`：在收到响应之前取消异步请求\r\n6. `xhr.getResponseHeader(key)`：获取响应头部\r\n7. `xhr.getAllResponseHeaders()`：取得所有响应头部，该方法会返回包含所有响应头部的字符串\r\n\r\n```http\r\nDate: Sun, 14 Nov 2004 18:04:03 GMT\r\nServer: Apache/1.3.29 (Unix)\r\nVary: Accept\r\nX-Powered-By: PHP/4.3.8\r\nConnection: close\r\nContent-Type: text/html charset=iso-8859-1\r\n```\r\n\r\n## 属性\r\n\r\n1. `timeout`：设置了 `timeout` 且超时之后，XHR 对象就会触发 `timeout` 事件，调用 `ontimeout` 事件处理程序\r\n2. `withCredentials`：设置跨源请求提供凭据（cookie、HTTP 认证和客户端 SSL 证书）\r\n3. `responseText`：作为响应主体被返回的文本\r\n4. `status`：相应的 HTTP 状态\r\n5. `statusText`：响应的 HTTP 状态描述\r\n\r\n## readyState\r\n\r\nXHR 对象有一个 readyState 属性，表示当前处在请求/响应过程的哪个阶段：\r\n\r\n- `0`：未初始化，尚未调用 `open()`\r\n- `1`：已打开，调用了 `open()`，还没有调用 `send()`\r\n- `2`：已发送，调用了 `send()`，还没有收到响应\r\n\r\n- `3`：接收中，已经收到部分响应数据\r\n\r\n- `4`：完成，已经接收到全部响应数据，可以使用\r\n\r\n为保证跨浏览器兼容，`readystatechange` 事件处理程序应该在调用 `open()` 之前注册\r\n\r\n## 使用\r\n\r\n```javascript\r\nconst xhr = new XMLHttpRequest()\r\n\r\nxhr.addEventListener('readystatechange', () => {\r\n  if (xhr.readyState === 4) {\r\n    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\r\n      console.log(xhr.responseText)\r\n    } else {\r\n      console.log(\"Request was unsuccessful: \" + xhr.status)\r\n    }\r\n  }\r\n})\r\n\r\nxhr.open('get', 'https://www.xiefeng.tech', true)\r\n\r\nxhr.timeout = 1000 // 设置 1 秒超时\r\n\r\nxhr.ontimeout = () => console.log(\"Request did not return in a second.\")\r\n\r\nxhr.overrideMimeType(\"text/xml\")\r\n\r\nxhr.send(null)\r\n```\r\n\r\n# FormData\r\n\r\nFormData 类型便于创建 `multipart/form-data` 格式的数据，FormData 实例可以直接传给 XHR 对象的 `send()` 方法\r\n\r\n```javascript\r\nconst fd = new FormData()\r\n```\r\n\r\n可以通过直接给 FormData 构造函数传入一个表单元素\r\n\r\n```javascript\r\nconst fd = new FormData(document.forms[0])\r\n```\r\n\r\n## 方法\r\n\r\n**append**\r\n\r\n```javascript\r\nformData.append(name, value)\r\nformData.append(name, value[, filename])  // value 为 Blob (包括子类型，如 File)\r\n```\r\n\r\n**set**\r\n\r\n```javascript\r\nformData.set(name, value)\r\nformData.set(name, value[, filename]) // value 为 Blob (包括子类型，如 File)\r\n```\r\n\r\n**区别：** append 新添加的对应的 key 存在也不会覆盖原值，而是新增一个值，如果 key 不存在则新增一项属性值。\r\n\r\n## 使用\r\n\r\n```javascript\r\nconst xhr = new XMLHttpRequest()\r\nxhr.onreadystatechange = function() {\r\n  if (xhr.readyState == 4) {\r\n    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\r\n      alert(xhr.responseText)\r\n    } else {\r\n      alert(\"Request was unsuccessful: \" + xhr.status)\r\n    }\r\n  }\r\n}\r\nxhr.open(\"post\", \"postexample.php\", true)\r\nconst form = document.getElementById(\"user-info\")\r\nxhr.send(new FormData(form)) \r\n```\r\n\r\n# 进度事件\r\n\r\nProgress Events 是 W3C 的工作草案，定义了客户端-服务器端通信，这些事件最初只针对 XHR，现在也推广到了其他类似的 API。\r\n\r\n## 事件\r\n\r\n- `loadstart`：在接收到响应的第一个字节时触发\r\n- `progress`：在接收响应期间反复触发\r\n- `error`：在请求出错时触发\r\n- `abort`：在调用 `abort()` 终止连接时触发\r\n- `load`：在成功接收完响应时触发\r\n- `loadend`：在通信完成时，且在 `error`、`abort` 或 `load` 之后触发\r\n\r\n每次请求会首先触发 loadstart 事件，之后是一个或多个 progress 事件，接着是 error、abort 或 load 中的一个，最后是 loadend 事件\r\n\r\n**load**\r\n\r\n`load` 事件在响应接收完成后立即触发，这样就不用检查 `readyState` 属性\r\n\r\n`onload` 事件处理程序的 `event.target` 为 XHR 实例，但不是所有浏览器都实现了这个事件的 `event` 对象\r\n\r\n**progress**\r\n\r\n`onprogress` 事件处理程序的 `event.target` 是 XHR 对象，且包含 3 个额外属性：`lengthComputable`、`position` 和 `totalSize`\r\n\r\n- `lengthComputable` 是 一个布尔值，表示进度信息是否可用\r\n- `position` 是接收到的字节数\r\n- `totalSize` 是响应的 `ContentLength` 头部定义的总字节数\r\n\r\n为了保证正确执行，需要在调用 `open()` 之前添加 `onprogress` 事件处理程序\r\n\r\n## 使用\r\n\r\n```javascript\r\nconst xhr = new XMLHttpRequest()\r\nxhr.onload = () => {\r\n  if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\r\n    console.log(xhr.responseText)\r\n  } else {\r\n    console.log(\"Request was unsuccessful: \" + xhr.status)\r\n  }\r\n}\r\nxhr.onprogress = event => {\r\n  const divStatus = document.getElementById(\"status\")\r\n  if (event.lengthComputable) {\r\n    divStatus.innerHTML = \"Received \" + event.position + \" of \" + event.totalSize + \" bytes\"\r\n  }\r\n}\r\nxhr.open(\"get\", \"https://xiefeng.tech\", true)\r\nxhr.send(null)\r\n```\r\n\r\n# Fetch\r\n\r\n只要服务器返回了响应，Promise 就会 resolved，如果服务器没有响应而导致浏览器超时，这样才会导致 Promise rejected\r\n\r\n这个行为是合理的：系统级网络协议已经成功完成消息的一次往返传输，至于真正的“成功”请求，则需要在处理响应时再定义。\r\n\r\n违反 CORS、无网络连接、HTTPS 错配及其他浏览器/网络策略问题都会导致 Promise 被拒绝\r\n\r\n## 中断请求\r\n\r\nFetch API 支持通过 AbortController/AbortSignal 对中断请求\r\n\r\n`AbortController` 接口表示一个控制器对象，可以根据需要中止一个或多个 Web请求：\r\n\r\n- `signal`：返回 `AbortSignal` 对象实例，可以用来 with/abort 一个Web(网络)请求\r\n- `abort()`：中止一个尚未完成的 Web 请求\r\n\r\n`AbortSignal ` 接口表示一个信号对象，通过 `AbortController` 对象与DOM请求进行通信并在需要时将其中止\r\n\r\n- `aborted`：与之通信的请求是否被终止（true）或未终止（false）\r\n- `onabort`：当信号正在与之通信的DOM请求被中止时调用\r\n\r\n当初始化 fetch 时，将信号和控制器与获取请求相关联，可以允许我们通过调用 `abort()` 中止请求\r\n\r\n当调用 `abort()` 时，`fetch` 会 reject 一个名为 `AbortError` 的 `DOMException`\r\n\r\n```javascript\r\nconst abortController = new AbortController()\r\n\r\ndocument.querySelector('#fetch').onclick = async () => {\r\n  const url = 'http://api.xiefeng.tech/api/daily/quote'\r\n  try {\r\n    // 将信号和控制器与获取请求相关联\r\n    const resp = await fetch(url, { signal: abortController.signal })\r\n    const data = await resp.json()\r\n    console.log(data)\r\n  } catch (error) {\r\n    console.log('request has been abort', error)\r\n  }\r\n}\r\n\r\ndocument.querySelector('#abort').onclick = () => {\r\n  abortController.abort()\r\n}\r\n```\r\n\r\n## Header\r\n\r\nHeaders 对象是所有请求和响应头部的容器，通过 `Request.prototype.headers` 和 `Response.prototype.headers` 可以访问请求和响应包含着头部的 Headers 对象。\r\n\r\n请求和响应的 Headers 对象的属性都是可以修改的，使用 `new Headers()` 也可以创建一个新的实例\r\n\r\nHeaders 类似于 Map，但是在初始化 Headers 对象时，可以使用键/值对形式的对象\r\n\r\n```javascript\r\nconst header = new Headers({'a': 'b'})\r\nheader.get('a')\t// 'b'\r\n```\r\n\r\n一个 HTTP 头部字段可以有多个值，Headers 对象通过 `append()` 方法支持添加多个值\r\n\r\n```javascript\r\nconst header = new Headers({'a': 'b'})\r\nheader.get('a')\t// 'b'\r\nheader.append('a', 'c')\r\nheader.get('a')\t// 'b, c'\r\n```\r\n\r\n## Request\r\n\r\n通过 `Request` 构造函数可以创建一个 `Request` 实例，参数和 `fetch` 相同\r\n\r\n```javascript\r\nnew Requset('', {})\r\n```\r\n\r\n### 克隆Request\r\n\r\nFetch API 提供了两种方式创建 Request 对象的副本：使用 Request 构造函数、使用 `clone()` 方法\r\n\r\n将 Request 实例作为 input 参数传给 Request 构造函数，会得到该请求的一个副本：\r\n\r\n```javascript\r\nconst r1 = new Request('https://foo.com')\r\nconst r2 = new Request(r1)\r\n```\r\n\r\n这种克隆方式会使得第一个请求的请求体会被标记为“已使用”，并且可以传递第二个参数覆盖原始的值\r\n\r\n```javascript\r\nr1.bodyUsed\t// true\r\nr2.bodyUsed\t// false\r\n```\r\n\r\n使用 `clone()` 方法会创建一模一样的副本，也不会将任何请求的请求体标记为“已使用”：\r\n\r\n```javascript\r\nconst r1 = new Request('https://foo.com', { method: 'POST', body: 'foobar' })\r\nconst r2 = r1.clone()\r\n\r\nconsole.log(r1.bodyUsed) // false\r\nconsole.log(r2.bodyUsed) // false\r\n```\r\n\r\n如果请求对象的请求体已被读取（`bodyUsed = true`），进行克隆会导致抛出 TypeError\r\n\r\n### 传入fetch\r\n\r\nfetch 的参数和 Request 的参数是一摸一样的，在调用 `fetch` 时，可以传入已经创建好的 Request 实例\r\n\r\n```javascript\r\nconst request = new Request('https://foo.com')\r\n// 向 foo.com 发送 POST 请求\r\nfetch(request, { method: 'POST' })\r\n```\r\n\r\n`fetch` 会在内部克隆传入的 Request 对象，通过 fetch 使用 Request 会将请求体标记为已使用\r\n\r\n`fetch` 也不能拿请求体已 经用过的 Request 对象来发送请求\r\n\r\n```javascript\r\nconst request = new Request('https://foo.com', { body: 'foobar' })\r\nfetch(request)\r\nfetch(request)\t// TypeError: Cannot construct a Request with a Request object that has already been used.\r\n```\r\n\r\n## Response\r\n\r\nResponse 对象是获取资源响应的接口，这个接口暴露了响应的相关信息，也暴露了使用响应体的不同方式\r\n\r\n可以使用构造函数创建 Response 实例\r\n\r\n```javascript\r\nconst response = new Response('body content')\r\n```\r\n\r\n大多数情况下，产生 Response 对象的主要方式是调用 fetch\r\n\r\n使用 `clone` 方法会克隆 Response 实例，不会将任何请求的请求体标记为已使用，如果响应体已经被读取则会报错\r\n\r\n通过创建带有原始响应体的 Response 实例，可以执行伪克隆操作，不会导致第一个 Response 实例标记为已读，但会共享 body\r\n\r\n```javascript\r\nlet r1 = new Response('foobar')\r\nlet r2 = new Response(r1.body)\r\nconsole.log(r1.bodyUsed)    // false\r\nconsole.log(r2.bodyUsed)    // false\r\nr2.text().then(console.log) // foobar\r\nr1.text().then(console.log) // TypeError: Failed to execute 'text' on 'Response': body stream is locked\r\n```\r\n\r\n## Body\r\n\r\nRequest 和 Response 都使用了 Fetch API 的 Body 混入，以实现两者承担有效载荷的能力，通过 body 即可访问\r\n\r\nBody 混入提供了 5 个方法，用于将 ReadableStream 转存到缓冲区的内存里，以及通过 Promise 来产生结果\r\n\r\n1. `body.text`\r\n2. `body.json`\r\n3. `body.formData`\r\n4. `body.arrayBuffer`\r\n5. `body.blob`\r\n\r\nBody 混入是构建在 ReadableStream 之上的，所以主体流只能使用一次，再次调用就会抛出错误\r\n\r\n在读取流时会给流加锁，无论流是否读完第二次调用都会报错，bodyUsed 表示流是否已**摄受**（读取器是否已经在流上加了锁）\r\n\r\n```javascript\r\nrequest.blob(); // 第一次调用给流加锁\r\nrequest.blob(); // 第二次调用再次加锁会失败\r\n```\r\n\r\nReadableStream 暴露了 `getReader()` 方法，可以用于在数据到达时异步获取数据块，数据流的格式是 Uint8Array\r\n\r\n```javascript\r\nconst reader = response.body.getReader()\r\nwhile (true) {\r\n  const { value, done } = await reader.read()\r\n  if (done) {\r\n    break\r\n  }\r\n  console.log(value)\r\n}\r\n```\r\n\r\n# WebSocket\r\n\r\n要创建一个新的 WebSocket，就要实例化一个 WebSocket 对象并传入提供连接的 URL\r\n\r\n创建 WebSocket 实例之后浏览器会马上尝试连接，同源策略不会限制 WebSocket：\r\n\r\n```js\r\nconst socket = new WebSocket(\"ws://xxxxxxx\")\r\n```\r\n\r\n## 状态\r\n\r\n与 XHR 类似，WebSocket 也有一个 readyState 属性表示当前状态：\r\n\r\n- `WebSocket.OPENING`：正在连接\r\n- `WebSocket.OPEN`：已经建立连接\r\n- `WebSocket.CLOSING`：正在关闭连接\r\n- `WebSocket.CLOSE`：已经关闭连接\r\n\r\nWebSocket 对象没有 readystatechange 事件，而是有与上述不同状态对应的其他事件\r\n\r\n任何时候都可以调用 `close()` 方法关闭 Web Socket 连接\r\n\r\n```javascript\r\nsocket.close()\r\n```\r\n\r\n## 发送 / 接收数据\r\n\r\n打开 Web Socket 之后，使用 `send()` 方法传入字符串、ArrayBuffer 或 Blob 即可向服务器发送数据：\r\n\r\n```js\r\nconst stringData = \"Hello world!\"\r\nconst arrayBufferData = Uint8Array.from(['f', 'o', 'o'])\r\nconst blobData = new Blob(['f', 'o', 'o'])\r\nsocket.send(stringData)\r\nsocket.send(arrayBufferData.buffer)\r\nsocket.send(blobData)\r\n```\r\n\r\n服务器向客户端发送消息时，WebSocket 对象上会触发 message 事件，可以通过 event.data 属性访问到有效载荷：\r\n\r\n```javascript\r\nsocket.onmessage = (event)=> {\r\n  const data = event.data\r\n  // ......\r\n}\r\n```\r\n\r\n`event.data` 也可能是 ArrayBuffer 或 Blob，这由 `socket.binaryType` 属性决定，该属性值为 `\"blob\"` 或 `\"arraybuffer\"`\r\n\r\n## 事件\r\n\r\nWebSocket 对象在连接生命周期中可能触发的事件：\r\n\r\n- open：在连接成功建立时触发\r\n- error：在发生错误时触发，连接无法存续\r\n- message：接收到服务器消息时触发\r\n- close：在连接关闭时触发\r\n\r\nWebSocket 对象仅支持 DOM Level 0 风格的事件处理程序来监听这些事件","meta":{"size":14256,"birthTime":1663496641396.8425,"updateTime":1663496641397.074}}},"__N_SSG":true}
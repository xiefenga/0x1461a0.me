{"pageProps":{"metaTitle":"Web Worker","article":{"title":"Web Worker","content":"# 工作者线程\n\nWeb Worker 赋予了浏览器中的 JavaScript 多线程并发执行任务的能力。\n\n传统的多线程模型（例如：POSIX 线程或者 Java 线程）不适合 JavaScript，因为像 DOM 这样的 API 会出现问题。\n\n而这也正是工作者线程的价值所在：允许把主线程的工作转嫁给独立的实体，而不会改变现有的单线程模型。\n\nWeb 工作者线程规范中定义了三种主要的工作者线程：\n\n- **专用工作者线程**：通常简称为Web Worker，脚本可以单独创建一个 JavaScript 线程执行委托的任务\n\n- **共享工作者线程**：与专用工作者线程非常相似，主要区别是共享工作者线程可以被多个不同的上下文使用\n\n- **服务工作者线**：与专用工作者线程和共享工作者线程截然不同，它的主要用途是拦截、重定向和修改页面发出的请求\n\n# 专用工作者线程\n\n专用工作者线程可以称为后台脚本，JavaScript 线程的各个方面，包括生命周期管理、代码路径和输入/输出，都由初始化线程时提供的脚本来控制。\n\n## 创建\n\n通过 `Worker` 构造函数创建专用 Worker 线程，构造函数返回一个 Worker 实例，通过该实例可以和 Worker 通信。\n\n有两种创建 Worker 的方式，一种是通过同源的 URL，一种是通过行内生成Object URL 的方式。\n\n```javascript\nconst worker = new Worker('./worker.js', { type: \"module\" });\n\nconsole.log(worker); // Worker { }\n\n\n// 通过行内的方式创建 Worker\nconst workerScript = `\n\tself.onmessage = ({data}) => console.log(data);\n`;\nconst workerScriptBlob = new Blob([workerScript]);\n\nconst workerScriptBlobUrl = URL.createObjectURL(workerScriptBlob);\nconst worker = new Worker(workerScriptBlobUrl);\n```\n\n第二个参数可以传递配置：\n\n- `name`：可以在工作者线程中通过 `self.name` 读取到的字符串标识符\n- `type`：脚本的运行方式\n\t- `classic`：脚本作为常规脚本来执行\n\t- `module`：脚本作为模块执行\n- `credentials`：在 `type` 为 `\"module\"` 时，指定如何获取与传输凭证数据相关的工作者线程模块脚本\n\t- 这些选项与 `fetch` 的凭证选项相同\n\t- `omit`、`same-orign`、`include`\n\n## 实例\n\n构造函数返回的 Worker 对象是与刚创建的专用工作者线程通信的连接点。它可用于在工作者线程和父上下文间传输信息，以及捕获专用工作者线程发出的事件。\n\n### 事件\n\n- `onerror`：该事件会在工作者线程中抛出错误时发生\n- `onmessage`：该事件会在工作者线程向父上下文发送消息时发生\n- `onmessageerror`：该事件会在工作者线程收到无法反序列化的消息时发生\n\n由于 Worker 继承自 EventTarget，事件也可以通过 `worker.addEventListener` 来注册。\n\n如果工作者线程脚本抛出了错误，该工作者线程沙盒可以阻止它打断父线程的执行。即在父线程中无法捕获，只能通过事件。\n\n```javascript\n// worker.js\nthrow Error('foo');\n\n// main.js\ntry {\n    const worker = new Worker('./worker.js');\n    console.log('no error');\n} catch(e) {\n    console.log('caught error');\n}\n// no error\n\nconst worker = new Worker('./worker.js');\nworker.onerror = console.log; \n// ErrorEvent {message: \"Uncaught Error: foo\"}\n```\n\n### 方法\n\n- `postMessage`：用于通过异步消息事件向工作者线程发送信息\n- `terminate`：用于立即终止工作者线程。没有为工作者线程提供清理的机会，脚本会突然停止\n\n## 全局对象\n\n专用工作者线程的全局作用域是 `DedicatedWorkerGlobalScope` 的实例。因为这继承自 `WorkerGlobalScope`，所以包含它的所有属性和方法。工作者线程可以通过 `self` 关键字访问该全局作用域。\n\n`DedicatedWorkerGlobalScope` 增加的属性和方法：\n\n- `name`：Worker 构造函数的一个可选的字符串标识符\n- `postMessage`：与 `worker.postMessage` 对应的方法，用于从工作者线程内部向父上下文发送消息 \n- `close`：与 `worker.terminate` 对应的方法，用于立即终止工作者线程\n- `importScripts`：可以加载任意源的脚本，只能在 `classic` 脚本中使用，可以接收任意数量的脚本\n\n## 通信\n\n与工作者线程的通信都是通过异步消息完成的。\n\n### postMessage\n\n可以使用 `postMessage` 在主线程和工作者线程之间传递消息，传递的数据保存在事件对象 `e` 的 `data` 属性中。\n\n```javascript\n// worker.js\nfunction factorial(n) {\n    let result = 1;\n    while (n) { result *= n--; }\n    return result;\n}\n\nself.onmessage = (e) => self.postMessage(`${e.data}! = ${factorial(e.data)}`);\n\n// main.js\nconst worker = new Worker('./worker.js');\n\nworker.onmessage = e => console.log(e.data);\n\nworker.postMessage(5);\n```\n\n### MessageChannel\n\n`MessageChannel` 接口允许我们创建一个新的消息通道，并通过它的两个端口（`MessagePort` 实例）发送数据。\n\n`MessagePort` 实例具有 `onmessage` 等事件和 `postMessage` 方法。\n\n```javascript\nconst channel = new MessageChannel();\n\nconsole.log(channel);\n```\n\n![](http://oss.xiefeng.tech/img/20210328140040.png)\n\n首先父线程需要将端口传递给子线程，然后再开始使用端口通信。\n\n`MessagePort` 是可转移对象，可以使用 `postMessage` 的第二个参数进行传递端口，`MessagePort` 会自动保存在 `e.ports` 数组中。\n\n```javascript\n// worker.js\nlet messagePort = null;\n// 通过在全局的事件接收端口\nself.onmessage = e => {\n    messagePort = e.ports[0];\n    self.onmessage = null;\n    // 通过 channel 进行数据的发送、接收\n    messagePort.onmessage = e => messagePort.postMessage(`data: ${e.data}`);\n}; \n\n// main.js\nconst channel = new MessageChannel();\nconst worker = new Worker('./worker.js');\n\nworker.postMessage(null, [channel.port1]);  // 把端口发送到工作者线程\n// 通过 channel 发送、接收数据\nchannel.port2.onmessage = ({data}) => console.log(data);\nchannel.port2.postMessage(5);\n```\n\n使用 MessageChannel 实例与父进程通信感觉没有必要。MessageChannel 真正有用的地方是让两个子线程之间直接通信。\n\n父线程创建一个 channel，并将端口传递给子线程，让子线程之间通过端口进行通信。\n\n```javascript\n// main.js\nconst channel = new MessageChannel();\n\nconst workerA = new Worker('./worker.js');\n\nconst workerB = new Worker('./worker.js');\n\nworkerA.postMessage('workerA', [channel.port1]);\n\nworkerB.postMessage('workerB', [channel.port2]);\n\n// worker.js\nlet messagePort = null;\n\nfunction sendData(target, data) {\n    target.postMessage(data);\n}\n\nself.onmessage = ({data, ports}) => {\n    if (ports.length) {\n        messagePort = ports[0];\n        messagePort.onmessage = ({data}) => sendData(self, data);\n    } else {\n        sendData(messagePort, data);\n    }\n}; \n```\n\n### BroadcastChannel\n\n`BroadcastChannel` 接口代理了一个命名频道，它允许同源的不同浏览器窗口、Tab页、frame或者 iframe 下的不同文档之间相互通信。\n\n通过触发一个 `message` 事件，消息可以广播到所有监听了该频道的 `BroadcastChannel` 对象。\n\n这种通道类型的设置比较简单， 不需要像 `MessageChannel` 那样转移乱糟糟的端口。\n\n```javascript\n// main.js\nconst channel = new BroadcastChannel('worker_channel');\n\nconst worker = new Worker('./worker.js');\n\nchannel.onmessage = ({data}) => {\n    console.log(`heard ${data} on page`);\n}\n\nsetTimeout(() => channel.postMessage('foo'), 1000);\n\n// worker.js\nconst channel = new BroadcastChannel('worker_channel');\n\nchannel.onmessage = ({data}) => {\n    console.log(`heard ${data} in worker`);\n    channel.postMessage('bar');\n} \n```\n\n`BroadcastChannel` 这种信道没有端口所有权的概念，所以如果没有实体监听这个信道，广播的消息就不会有人处理。\n\n在这种情况下，如果没有 `setTimeout`，则由于初始化工作者线程的延迟，就会导致消息已经发送了，但工作者线程上的消息处理程序还没有就位。\n\n## 数据传输\n\n工作者线程是独立的上下文，因此在上下文之间传输数据就会产生消耗。\n\n在支持传统多线程模型的语言中，可以使用锁、互斥量，以及 volatile 变量。\n\nJavaScript 中有三种在上下文间转移信息的方式：\n\n- 结构化克隆算法\n- 可转移对象\n- 共享数组缓冲区\n\n### 结构化克隆算法\n\n结构化克隆算法可用于在两个独立上下文间共享数据。该算法由浏览器在后台实现，不能直接调用。\n\n在通过 `postMessage` 传递对象时，浏览器会遍历该对象，并在目标上下文中生成它的一个副本。\n\n###  可转移对象\n\n使用可转移对象可以把所有权从一个上下文转移到另一个上下文。在不太可能在上下文间复制大量数据的情况下，这个功能特别有用。\n\n只有几种对象是可转移对象：\n\n- `ArrayBuffer`\n- `MessagePort` \n- `ImageBitmap` \n- `OffscreenCanvas`\n\n`postMessage` 方法的第二个可选参数是数组，它指定应该将哪些对象转移到目标上下文。\n\n### SharedArrayBuffer\n\n在把 `SharedArrayBuffer` 传给 `postMessage` 时，浏览器只会传递原始缓冲区的引用。\n\n两个不同的上下文会分别维护对同一个内存块的引用。每个上下文都可以随意修改这个缓冲区， 防止出现错误可以使用 `Atomics` API。\n\n# 共享工作者线程\n\n共享工作者线程或共享线程与专用工作者线程类似，但可以被多个可信任的执行上下文访问。\n\n例如：同源的两个标签页可以访问同一个共享工作者线程。\n\n共享工作者线程通过 `SharedWorker` 构造函数创建，和 `Worker` 参数相同。\n\nWorker 构造函数始终会创建新线程，而 SharedWorker 则只会在相同的标识不存在的情况下才创建新线程。\n\n标识取决于脚本 URL、名称和文档源。\n\n如果的确存在与标识匹配的共享工作者线程，则只会与已有共享者线程建立新的连接。\n\n```javascript\nnew SharedWorker('./sharedWorker.js');\nnew SharedWorker('./sharedWorker.js');\nnew SharedWorker('./sharedWorker.js');\n```\n\n## 连接\n\nSharedWorker 只有 `error` 事件和一个 `port` 属性，是一个 `MessagePort` 实例，专门用于通信。\n\n在共享线程内部，全局作用域是 `SharedWorkerGlobalScope` 的实例，它没有 `postMessage` 等属性和事件，只有一个 `connect` 事件。\n\n每次调用 SharedWorker 构造函数，无论是否创建了工作者线程，都会在共享线程内部触发 `connect` 事件。\n\n发生 `connect` 事件时，SharedWorker 构造函数会隐式创建 MessageChannel 实例，并把 `MessagePort` 实例的所有权唯一地转移给该 SharedWorker 的实例。这个 `MessagePort` 实例会保存在 `connect` 事件对象的 `ports` 数组中。\n\n所以 SharedWorker 想要通信需要通过该事件通过端口来通信。\n\n```javascript\n// main.js\nconst worker = new SharedWorker('./worker.js')\n\nworker.port.onmessage = e => console.log(e)\n\nworker.port.postMessage('aa');\n\n// worker.js\nself.onconnect = ({ ports }) => {\n    ports[0].onmessage = e => {\n        ports[0].postMessage(e.data)\n    }\n};\n```\n\n> 根据浏览器实现，在 SharedWorker 中把日志打印到控制台不一定能在浏览器默 认的控制台中看到。\n\n在Chrome 中，SharedWorker 上下文中的打印统统看不到，只有 Firefox 能够隐晦的看到。\n\n\n\n\n\n","meta":{"size":11509,"birthTime":1663496641399.3843,"updateTime":1663496641399.5793}}},"__N_SSG":true}
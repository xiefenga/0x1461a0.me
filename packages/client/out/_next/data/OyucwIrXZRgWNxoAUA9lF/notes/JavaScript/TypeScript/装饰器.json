{"pageProps":{"metaTitle":"装饰器","article":{"title":"装饰器","content":"## 装饰器种类\n\n装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上\n\n装饰器本身就是一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入\n\n装饰器工厂是一个返回一个装饰器的函数，它用于定制一个修饰器\n\n### 类装饰器\n\n类装饰器是一个对类进行装饰的函数，该函数接收一个参数：要装饰类本身\n\n类装饰器可以返回一个新的类，将会替换掉装饰的类\n\n基本上，类装饰器的行为就是下面这样：\n\n```javascript\n@decorator\nclass A {}\n\n// 等同于\n\nclass A {}\nA = decorator(A) || A\n```\n\n### 属性装饰器\n\n属性装饰器接受两个参数：\n\n1. 如果是静态属性，则为类本身；如果是实例属性，则为类的原型\n\n2. 属性名\n\n```typescript\nfunction propertyDes(target: object, prop: string) {\n  console.log(target, prop)\n}\n\nclass Test {\n  @propertyDes\n  static des: string = 'default'\n\n  @propertyDes\n  des: string = 'default'\n}\n\n// {} des\n// [class Test] { des: 'default' } des\n```\n\n### 方法装饰器\n\n方法装饰器会被应用到方法的**属性描述符**上，可以用来监视，修改或者替换方法定义\n\n方法装饰器接收三个参数：\n\n1. 如果是静态方法，则为类本身；如果是实例方法，则为类的原型\n\n2. 方法名\n\n3. 方法的属性描述符\n\n如果方法装饰器返回一个值，则该值会被用来替换掉方法原本的属性描述符\n\n```typescript\nfunction log(proto: any, key: string, descriptor: PropertyDescriptor) {\n  const method = descriptor.value\n  descriptor.value = function (...args: any[]) {\n    console.log('log:', key, 'execute')\n    return method.apply(this, args)\n  }\n}\n\nclass Test {\n  @log\n  print(val: string) {\n    console.log(val)\n  }\n}\n\nnew Test().print('helle world')\n\n// log: print execute\n// helle world\n```\n\n### 参数装饰器\n\n参数装饰器可以应用于类构造函数或方法声明，参数装饰器只能用来监视一个方法的参数是否被传入（需要使用元数据）\n\n参数装饰器接收三个参数：\n\n1. 如果方法是静态的，则为类本身；如果方法是实例方法，则为类的原型\n\n2. 该参数所属的方法名\n\n3. 参数在函数参数列表中的索引\n\n```typescript\nfunction paramDes(target: object, name: string, index: number) {\n  console.log(target, name, index)\n}\n\nclass Test {\n  print(@paramDes val: string) {\n    console.log(val)\n  }\n}\n\nnew Test().print('helle world')\n// {} print 0\n```\n\n## 执行时机\n\n类装饰器函数会在类定义后直接运行，当然规范中装饰器的运行时机是在编译阶段\n\n```typescript\nfunction classDes(target: new () => object) {\n  console.log(target.name)\n}\n\n@classDes\nclass A { }\nconsole.log('finish')\n// A\n// finish\n```\n\n类中不同声明上的装饰器将按以下规定的顺序应用：\n\n1. **实例成员**的参数装饰器，然后依次是方法装饰器，访问符装饰器，属性装饰器\n2. **静态成员**的参数装饰器，然后依次是方法装饰器，访问符装饰器，属性装饰器\n3. 参数装饰器应用到构造函数\n4. 类装饰器应用到类\n\n## 装饰器组合\n\n多个装饰器可以同时应用到一个声明上，这些装饰器的运行顺序：\n\n1. 由上至下依次对**装饰器表达式**求值，如果本身就是装饰器的话则不需要这一步\n2. 由下至上依次应用装饰器\n\n```typescript\nfunction classDes(des: string) {\n  console.log('evaluated', des)\n  return (target: new () => object) => {\n    console.log('executed', des, target)\n    return class Test {\n      static des = des\n    }\n  }\n}\n\n@classDes('1')\n@classDes('2')\n@classDes('3')\nclass Test {\n  static des: string = 'default'\n}\n\nconsole.log(Test)\n\n// evaluated 1\n// evaluated 2\n// evaluated 3\n// executed 3 [class Test] { des: 'default' }\n// executed 2 [class Test] { des: '3' }\n// executed 1 [class Test] { des: '2' }\n// [class Test] { des: '1' }\n```\n\n多个装饰器的行为等价于：\n\n```javascript\nconst classDes1 = classDes('1')\nconst classDes2 = classDes('2')\nconst classDes3 = classDes('3')\n\nTest = classDes3(Test) ?? Test\nTest = classDes2(Test) ?? Test\nTest = classDes1(Test) ?? Test\n```\n\n## 元数据\n\n元数据：用来描述数据的数据\n\nReflect Metadata 是 ES7 新增的一个提案，通过装饰器来给类添加一些元数据，然后通过反射将这些信息提取出来\n\n也就是 Reflect Metadata 可以对类、属性或方法等进行**元数据**的读写\n\n","meta":{"size":4507,"birthTime":1663496641396.498,"updateTime":1663496641396.6084}}},"__N_SSG":true}
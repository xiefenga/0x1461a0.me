{"pageProps":{"metaTitle":"函数","article":{"title":"函数","content":"# 函数内部\n\n- `arguments`\n\t- `arguments` 有一个名叫 `callee` 的属性，该属性指向拥有这个 `arguments` 对象的函数\n\t- 当函数在严格模式下运行时，访问 `arguments.callee` 会导致错误。\n- `caller`\n\t- 这个属性中保存着**调用当前函数的函数**的引用\n\t- 如果是在全局作用域中调用当前函数，它的值为 `null`\n- `new.target`\n  - ES6 新增用于检测函数是否通过 new 关键字调用\n  - 正常调用函数 `new.target` 为 `undefined`\n  - 使用 new 关键字调用函数，`new.target` 指向该构造函数\n\n# 立即执行函数\n\n一个函数变成表达式，该函数的名字就会变成函数内部的一个局部变量，并指代函数对象本身，并且函数表达式不会成为 `window` 的属性\n\n一般的写法：\n\n- `(function() {...}())`\n- `(function() {...})()`\n\n实际上，只要是函数表达式，就可以被执行符号 `()` 执行，`()` 也能将函数变为表达式所以才有了上面的写法\n\n```javascript\n+ function() {\n  console.log(\"+\");\n}();\n\nvar test = function() {\n  console.log(\"test\");\n}();\n\n! function() {\n  console.log(\"!\");\n}();\n```\n\n# 参数默认值\n\n只要没有给有默认值的参数传递参数或传 `undefined` ，函数即会使用默认值\n\n``` js\nfunction(a = 1, b) {\n  ......\n}\n```\n\n## arguments\n\n非严格模式下，形参和 `arguments` 是相关联的，在严格模式下， `arguments` 和形参是脱离的，使用了参数默认值就是使用了严格模式\n\n``` js\nfunction test(a, b) {\n  \"use strict\";\n  console.log(a, arguments[0]);\n  a = 10;\n  console.log(a, arguments[0]);\n}\n\ntest(1, 10); // 1 1   10 1\n```\n\n## 暂时型死区\n\n形参和 `let` 声明一样，具有作用域，并且根据参数的声明顺序，存在暂时性死区\n\n``` js\nfunction test(a = b, b) {\n  .....\n}\ntest(1, 2); // 没问题\ntest(undefined, 2); //ReferenceError: Cannot access 'b' before initialization\n```\n\n# 剩余参数\n\nES6的剩余参数专门用于收集末尾的所有参数，将其放置到一个形参数组中\n\n``` js\nfunction(a, b, ...args) {\n  ...\n}\n```\n\n# 箭头函数\n\n1. 箭头函数中不存在 `this`、`arguments`、`new.target`，如果使用了这些，则用的是该函数外层对应的值\n2. 箭头函数没有原型（即没有 `prototype` 属性）\n3. 箭头函数不能作用构造函数使用\n4. call、apply、bind 等方法无法改变箭头函数中 this 的指向\n5. 箭头函数不能用作Generator函数，不能使用yeild关键字","meta":{"size":2497,"birthTime":1663496641393.3093,"updateTime":1663496641393.572}}},"__N_SSG":true}
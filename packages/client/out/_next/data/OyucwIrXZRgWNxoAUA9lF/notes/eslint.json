{"pageProps":{"metaTitle":"eslint","article":{"title":"eslint","content":"## 规则配置\n\n```json\n{\n  \"rules\": {\n    \"semi\": [\"error\", \"always\"],\n    \"quotes\": [\"error\", \"double\"]\n  }\n}\n```\n\n配置项为一个数组，第一个为规则的错误级别：`error`、`warn`、`off`，第二个为规则的配置项\n\n## 解析器\n\nESLint 中解析器的作用是将代码转化成 AST，借助 AST 来对代码进行分析\n\n配置项 `parser` 用于指定 ESLint 使用的解析器，ESLint 默认解析器为 Espree\n\n例如：`@typescript-eslint/parser` 用于解析 typescript，从而检查和规范Typescript代码\n\nESTree 是业界统一遵从的标准，它定义了JavaScript中所有涉及到的语法的表达形式，对语法元素描述进行统一标准的定义，并且ES在不断的升级过程中 ESTree 也会伴随着进行升级。\n\nAST 选择器\n\n用来匹配 AST 中节点的字符串（类似于 CSS 选择器），对于描述代码中的特定语法模式非常有用\n\n## 扩展\n\n手动配置完整的配置文件工作量很大，使用 `extends` 可以使用一些预先设置好的配置\n\n预设包一般以 `eslint-config-xxx` 格式命名，配置时可以省略 `eslint-config-` 前缀\n\n`extends` 多个模块，有冲突的配置项，后面的包将覆盖前面的。\n\n该配置文件中的配置项的优先级恒定高于 `extends` 中的\n\nextends 就是一个 mixin 的过程，优先级为：当前文件 > 后 extends > 先 extends\n\n## 插件\n\nESLint 插件用于新增 lint 规则\n\n> 由于eslint本身主要是对js代码进行语法检查以及少量代码格式化的操作，对于一些eslint没有定义的规则或其他格式文件的内容就无法识别进行lint校验。此时，若需要对这些文件内容进行lint规则，就需要使用eslint提供的plugins插件配置对lint规则进行新增。\n\n### 插件配置\n\n插件一般以 `eslint-plugin-xxx` 方式来命名，也支持 `@xx/eslint-plugin-xx` 带 scope 的命名\n\n配置的时候可以省略 `eslint-plugin-` 前缀仅配置插件名，但是 scope 不可以省略\n\n```json\n{\n  plugins: [\n    'vue', // eslint-plugin-vue\n    '@typescript-eslint', // @typescript-eslint/eslint-plugin\n    '@0x1461ao/react', // @0x1461ao/eslint-plugin-react\n  ]\n}\n```\n\n如果插件新增的规则很多，`rules` 中就需要配置很多\n\n如果插件提供了预设配置借助 `extends` 可以启用插件的预设。\n\n通过配置`extends: ['plugin:<包名>/<配置名称>']` 可以实现插件和预设一同导入 \n\n### 插件格式\n\n一个规则就是一个导出一个对象的模块，该对象有两个属性：\n\n- `meta` 代表了这条规则的元数据\n- `create` 表达了这条规则具体会怎么分析代码\n  - 是一个函数，返回一个属性为 AST 选择器的对象\n  - 返回值对象的每个属性值都是一个函数，是对 AST 节点监听的回调\n  - 在回调中我们可以获取对应选中的内容，我们可以针对选中的内容作一定的判断\n    - 如果不满足，可用 `context.report` 抛出问题\n    - `ESLint` 会利用我们的配置对抛出的内容做不同的展示\n  - ESLint 会收集这些选择器，在 AST 遍历过程中会执行所有监听该节点的回调\n\n```javascript\n// lib/rules/no-console-time.js\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: \"no console.time\",\n      category: \"Fill me in\",\n      recommended: false,\n    },\n    fixable: null,  // or \"code\" or \"whitespace\"\n    schema: [],\n    // 报错信息描述\n    messages: {\n      avoidMethod: \"console method '{{name}}' is forbidden.\",\n    },\n  },\n\n  create(context) {\n\n    return {\n      'CallExpression MemberExpression': node => {\n        const { object, property } = node\n        if (object.name === 'console' && property.name === 'time' ) {\n          context.report({\n            node,\n            messageId: 'avoidMethod',\n            data: { name: 'time' },\n          })\n        }\n      }\n    }\n  },\n}\n```\n\n## Processor\n\nprocessor 在 parser 解析源文件之前，以及在 rules 校验完后处理一些事情\n\nprocessor 需要提供两个钩子函数：`preprocess` 和 `postprocess` \n\n- `preprocess` 是在 parser 解析源文件之前调用的方法\n- `postprocess` 是在 rules 校验完毕之后调用的方法\n\n## 运行原理\n\n1. ESLint 使用解析器将代码解析成 AST\n2. 深度遍历 AST，监听匹配过程\n3.  触发监听选择器的 `rule` 回调\n\n## 配置文件\n\n每个目录下都可以存在配置文件，ESLint 会一直向上查找配置文件，直到`/`、 `~/` 或者 `root: true` \n\n与被 lint 文件位于同一目录中的配置文件优先级高\n\n如果在同一个目录下有 `.eslintrc` 和 `package.json` 中 `eslintConfig` 字段\n\n `.eslintrc` 会优先， `package.json` 文件中的配置不会被使用\n\n配置类型上： 注释 > 命令行参数 > 配置文件\n\n- 文件层级上：（相对目标文件）近 > 远\n\n- 同一目录内：（只会采用一个配置文件）js > cjs > yaml > yml > json > package.json\n\n- 同一配置内：`overrides` > `rule` > `extends`\n\n- 同一选项内：后者 > 前者\n\n## overrides\n\n`overrides` 配置项通过 Glob 模式匹配特定文件集合，额外应用不同的配置。\n\n每一项支持大部分的 ESLint 配置，以及用于匹配文件的 `files` 数组和 `excludedFiles` 数组\n\n```json\n{\n  \"overrides\": [\n    {\n      \"files\": [\"src/*.js\"],\n      \"excludedFiles\": \"a.js\",\n      \"rules\": {\n        \"no-alert\": \"warn\"\n      }\n    }\n  ]\n}\n```\n\n## ignorePatterns\n\n`ignorePatterns` 配置项包含一组 glob 模式，其作用类似`.gitignore` \n\n```json\n{\n  \"ignorePatterns\": [\"**/dist/**\", \"**/output/**\"]\n}\n```\n\n## 注释\n\nESLint 支持使用注释禁用规则、进行配置、注入全局变量以及环境配置\n\n`//` 和 `/* */` 都可以，可以在注释的同时说明原因，原因放在配置内容之后，用**两个或两个以上 `-`** 隔开\n\n### 禁用规则\n\n通过 `eslint-disable(-next)-line rule` 可以单行禁用规则\n\n```javascript\nalert('foo'); // eslint-disable-line\nalert('foo'); /* eslint-disable-line */\nalert('foo'); // eslint-disable-line plugin/rule-name\n\n/* eslint-disable-next-line */\nalert('foo');\n// eslint-disable-next-line -- I don't want eslint \nalert('foo');\n// eslint-disable-next-line no-alert, quotes, semi\nalert('foo');\n```\n\n通过 `eslint-disable` 和 `eslint-enable` 实现某一块关闭规则校验\n\n```javascript\n/* eslint-disable */\nconsole.log(\"bar\")\nalert('foo');\n/* eslint-enable */\n\n/* eslint-disable no-alert, no-console */\nalert('foo');\nconsole.log('bar');\n/* eslint-enable no-alert, no-console */\n```\n\n在文件第一行使用  `eslint-disable`  实现整个文件关闭校验\n\n```javascript\n/* eslint-disable */\nalert('foo');\n//...\n\n/* eslint-disable no-alert */\nalert('foo');\n//...\n```\n\n### 规则配置\n\n```javascript\n/* eslint quotes: [\"error\", \"double\"], curly: 2 */\nconst foo=\"'bar'\"\n```\n\n### 全局变量\n\n通过 `global` 注入全局变量，默认只读，通过 `: writable` 表明可写\n\n```javascript\n// var1 只读，var2 读写\n/* global var1, var2: writable */\n```\n\n\n\n[ESLint使用教程](https://juejin.cn/post/7012798266089668645)\n\n[深入浅出之ESLint](https://juejin.cn/post/7028754877312401444)\n","meta":{"size":7161,"birthTime":1663496641419.8381,"updateTime":1663496641420.0784}}},"__N_SSG":true}
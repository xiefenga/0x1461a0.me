{"pageProps":{"metaTitle":"智能指针","article":{"title":"智能指针","content":"## 智能指针\n\nrust 中最常见的指针就是**引用**，并且在 Rust 中被赋予了更深层次的含义：借用其它变量的值。\n\n引用通过 `&` 表示，也非常简单，除了指向某个值外并没有其它的功能，也不会造成性能上的额外损耗，是使用最多的指针类型。\n\n智能指针更加复杂，实际上是一类数据结构（一般基于结构体实现），他们的表现类似指针，但是拥有额外的元数据和功能。\n\n- 智能指针和引用的区别在于：\n  - 引用仅仅是借用了数据\n  - 智能指针往往可以拥有它们指向的数据，然后再为其它人提供服务\n- 智能指针与自定义的结构体的区别在于它实现了 `Deref` 和 `Drop` 特征：\n  - `Deref` 可以让智能指针像引用那样工作，这样你就可以写出同时支持智能指针和引用的代码\n  - `Drop` 允许你指定智能指针超出作用域后自动执行的代码，例如做一些数据清除等收尾工作\n\n## Deref\n\n实现 `Deref` trait 允许我们重载**解引用运算符** `*`，实现了该 trait 的智能指针可以被当作常规引用来对待\n\n```rust\npub trait Deref {\n    type Target: ?Sized;\n\n    fn deref(&self) -> &Self::Target;\n}\n```\n\n`deref` 方法向编译器提供了获取任何实现了 `Deref` trait 的类型的值，调用这个类型的 `deref` 方法来获取一个它知道如何解引用的 `&` 引用的能力。\n\n### 解引用操作\n\n```rust\nfn main() {\n  let x = 5;\n  let y = &x;\n  assert_eq!(5, *y);\n}\n```\n\n当执行 `*` 解引用操作时，Rust 将 `*` 运算符替换为先调用 `deref` 方法再进行普通解引用的操作：\n\n```rust\nassert_eq!(5, *(y.deref()));\n```\n\n该特性可以让我们写出行为一致的代码，无论是面对的是常规引用还是实现了 `Deref` 的类型，我们不用考虑手动调用 `deref` 方法\n\n`*` 不会无限递归替换，从 `*y` 到 `*(y.deref())` 只会发生一次，不会继续进行替换产生形如 `*((y.deref()).deref())` 的怪物\n\n### Deref 强制转换\n\nRust 在函数和方法的传参上提供了一种 **`Deref ` 转换**的便利：引用类型的实参会触发自动解引用\n\n1. 当一个实现了 `Deref` 的值通过**引用**的方式传递给函数或方法时，会根据参数来决定是否进行自动 `Deref` \n2. 并且支持连续的隐式 `Deref` 转换，直到找到适合的形式为止\n\n```rust\nfn main() {\n  let s = String::from(\"hello world\");\n  display(&s)\n}\n\nfn display(s: &str) {\n  println!(\"{}\",s);\n}\n```\n\n`String` 实现了 `Deref` 特征，能被转换成一个 `&str`，使用 `&s` 的方式传递给函数自动通过 `Deref` 转换成了 `&str` \n\n在赋值中也可以自动应用 `Deref`，需要**手动标注解引用后的类型 ** \n\n```rust\nlet x = Box::new(String::from(\"hello\"));\n\nlet x: &str = &x;\n\nprintln!(\"{}\", x); // hello\n```\n\n### 引用归一\n\nRust 编译器实际上只能对 `&v` 形式的引用进行解引用操作，对于多重 `&`（例如 `&&&&v` 类型）会归一成 `&v` \n\n```rust\nimpl<T: ?Sized> Deref for &T {\n  type Target = T;\n\n  fn deref(&self) -> &T {\n    *self\n  }\n}\n```\n\n`& &&&T` 会被自动解引用为 `&&&T`，然后 `& &&T` 会被自动解引用为 `&&T`，最终解引用变成 `&T` \n\n### 三种 Deref\n\n除了不可变的 `Deref` 转换，Rust 还支持将一个可变的引用转换成另一个可变的引用以及将一个可变引用转换成不可变的引用\n\n- 当 `T: Deref<Target=U>`，可以将 `&T` 转换成 `&U` \n- 当 `T: DerefMut<Target=U>`，可以将 `&mut T` 转换成 `&mut U` \n- 当 `T: Deref<Target=U>`，可以将 `&mut T` 转换成 `&U` \n\n```rust\npub trait DerefMut: Deref {    \n  fn deref_mut(&mut self) -> &mut Self::Target;\n}\n```\n\nDerefMut “继承”了 Deref，只是它额外提供了一个 deref_mut 方法，用来获取可变的解引用。\n\n## RC\n\nRc 即引用计数（reference counting），适用于有向无环图（DAG）这种需要**共享数据所有权**的情况\n\n`Rc<T>` 会将对应的数据结构创建在**堆**上，并记录该数据被引用的次数，当引用次数归零时，代表该数据不再被使用，就会清理释放对应的内存\n\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(String::from(\"hello, world\"));\nlet b = Rc::clone(&a); // a.clone();\n\nassert_eq!(2, Rc::strong_count(&a));\nassert_eq!(Rc::strong_count(&a), Rc::strong_count(&b));\n```\n\n### 特点\n\n- 通过 `clone` 增加引用计数，只会共享数据所有权，不会复制内部的数据\n- 当一个 `Rc` 结构离开作用域被 `drop` 时，只会减少其引用计数，引用计数为零时才会真正清除堆内存\n- `Rc` 只能用于同一线程内部，要用于线程之间的对象共享需要使用 `Arc` \n- `Rc<T>` 是一个智能指针，实现了 `Deref` 特征\n\n`Rc<T>` 指向的是底层数据的**不可变的引用**（因为 `Rc` 可以共享所有权），因此无法拿到内部数据结构的可变引用来修改数据\n\n在所有权模型下，堆内存的生命周期和创建它的栈内存的生命周期保持一致，Rc 内部引用的堆内存不受栈内存生命周期的控制，通过 `Box::leak` 机制实现\n\n### 所有权\n\nRc 所有权的检查：\n\n- 静态检查（靠编译器保证代码符合所有权规则）：通过 `Rc::clone` 实现\n- 动态检查：通过 `Box::leak` 让堆内存拥有不受限的生命周期，在运行过程中通过对引用计数的检查，保证这样的堆内存最终会得到释放\n\n### Arc\n\n`Rc` 为了性能使用的不是线程安全的引用计数器，不可以处理多个线程访问同一块内存的问题\n\n`Arc` 是 `Atomic Rc` 的缩写，内部的引用计数使用 Atomic Usize，实现了线程安全的引用计数器\n\nAtomic Usize 是 usize 的原子类型，可以保证多线程下的安全\n\n`Arc` 拥有和 `Rc` 完全一样的 API，并且是线程安全，但是会伴随着性能损耗\n\n## RefCell\n\n`RefCell` 绕过了 Rust 编译器的静态检查，允许在**运行时**对某个只读数据进行**可变借用** \n\n### 内部可变性\n\n外部可变性（exterior mutability）：通过 `mut` 关键字进行声明，即 `mut` 或者 `&mut`\n\n内部可变性（interior mutability）：对并未声明成 `mut` 的值或者引用可以进行修改\n\n在编译器的眼里值是只读的，但是在运行时，这个值可以得到**可变借用**，从而修改内部的数据\n\n```rust\nuse std::cell::RefCell;\n\nlet data = RefCell::new(1);\n{\n  // 获得 RefCell 内部数据的可变借用\n  let mut v = data.borrow_mut();\n  *v += 1;\n}\nprintln!(\"data: {:?}\", data.borrow());\n```\n\n### 借用检测\n\n外部可变性会在编译时检测是否符合借用规则，不符合会产生编译错误\n\n使用 `RefCell` 获取内部数据结构的借用时，依旧需要保证所有权的借用规则，只不过它在**运行时检测** \n\n运行时检测到不符合借用规则时，会导致程序产生 `panic` \n\n```rust\nlet data = RefCell::new(1);\n{\n  // 获得 RefCell 内部数据的可变借用\n  let mut v = data.borrow_mut();\n  *v += 1;\n} // 不能同时有可变借用和不可变借用，或者使用 drop(v);\nprintln!(\"data: {:?}\", data.borrow());\n```\n\n由于运行时检测会导致无法做到像外部可变性一样实现 NLL (non-lexical lifetime) \n\n即使一个可变借用不再使用但没有进行释放，依旧无法通过借用规则检测，导致程序 `panic`\n\n### 线程安全\n\n`RefCell` 也不是线程安全的，如果需要在多线程中使用内部可变性，Rust 提供了 `Mutex` 和 `RwLock` \n\n`Mutex` 是互斥量，获得互斥量的线程对数据独占访问\n\n`RwLock` 是读写锁，获得写锁的线程对数据独占访问，但当没有写锁的时候，允许有多个读锁\n\n在多线程环境下，需要把 `RefCell<T>` 替换为 `Mutex<T>` 或者 `RwLock<T>` \n\n### Cell\n\n`Cell` 和 `RefCell` 在功能上没有区别，区别在于 `Cell<T>` 用于 `T` 实现 `Copy` 的情况\n\n```rust\nuse std::cell::Cell;\nlet c = Cell::new(\"asdf\");\nlet one = c.get();\nc.set(\"qwer\");\nlet two = c.get();\nprintln!(\"{},{}\", one, two);\n```\n\n![](https://static001.geekbang.org/resource/image/fc/86/fc524d667fabeec0a8a22d0e10531086.jpg?wh=3387x1982)\n\n","meta":{"size":8167,"birthTime":1663496641424.053,"updateTime":1663496641424.2864}}},"__N_SSG":true}
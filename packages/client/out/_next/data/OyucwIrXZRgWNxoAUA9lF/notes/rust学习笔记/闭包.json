{"pageProps":{"metaTitle":"闭包","article":{"title":"闭包","content":"## 概述\n\n闭包是将代码和其环境一起存储的一种数据结构，闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分。\n\nrust 中的闭包的语法：\n\n```rust\nlet cb = |x: i32, y: i32| -> i32 { x + y }\n```\n\n其中的类型注解可以省略，编译器会进行类型推导，推导完类型会被锁定进闭包中，无法多次推导为不同类型的闭包\n\n```rust\nlet example_closure = |x| x;\nlet s = example_closure(String::from(\"hello\"));\n\n// 已经推导为 |String| -> String，会报错\nlet n = example_closure(5);\n```\n\n## 变量捕获\n\n闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分\n\n和变量的使用方式一样，变量捕获的方式有三种：\n\n- 不可变借用\n- 可变借用\n- 获取所有权（闭包会根据其语义进行 Move 或 Copy）\n\n闭包会根据内部对变量的使用情况，采取不同的方式捕获环境中的自由变量\n\n```rust\n// 不可变借用\nlet c = || println!(\"hello: {}\", name);\n\n// Move\nlet c = || {\n  let name = name;\n  println!(\"hello: {}\", name)\n};\n```\n\n## move\n\n在闭包的参数列表前使用 `move` 关键字会强制闭包获取其使用变量的所有权\n\n`move` 通常用于使闭包的生命周期大于所捕获的变量的原生命周期，一般用于将闭包返回或移至其他线程\n\n```rust\nfn main() {\n    let x = vec![1, 2, 3];\n\n    let equal_to_x = move |z| z == x;\n\n    println!(\"can't use x here: {:?}\", x);\n\n    let y = vec![1, 2, 3];\n\n    assert!(equal_to_x(y));\n}\n```\n\n如果闭包捕获的变量为引用，使用 `move` 之后闭包会根据所引用的对象的语义获取所有权（Copy 或 Move）\n\n## 本质\n\n> A closure expression produces a closure value with a unique, anonymous type that cannot be written out. A closure type is approximately equivalent to a struct which contains the captured variables.\n\nRust 中的闭包是一种匿名类型，类似于一个结构体，其中存储了该结构体所捕获的变量。\n\n并且一旦声明，就会产生一个新的类型。\n\n闭包的大小跟参数、局部变量都无关，只跟捕获的变量有关。\n\n参数和局部变量是在调用时才在栈上产生的内存分配，和闭包类型本身是无关的，所以跟闭包的大小也无关。\n\n所以闭包是一个 DST\n\n```rust\n// 有参、无捕获\nlet c1 = |i: i32| println!(\"hello: {}\", i);\n\nlet name1 = String::from(\"tyr\");\n// 捕获一个引用，closure 长度为 8\nlet c2 = || println!(\"hello: {}\", name1);\n\nlet name2 = name.clone();\n// 捕获了一个 String，closure 长度 24\nlet c3 = move || {\n  let x = 1;\n  let name3 = String::from(\"lindsey\");\n  println!(\"hello: {}, {:?}, {:?}\", x, name2, name3);\n};\n\nprintln!(\n  \"c1: {}, c2: {}, c3: {}, main: {}\",\n  size_of_val(&c1),\n  size_of_val(&c2),\n  size_of_val(&c3),\n  size_of_val(&main),\n);\n// c1: 0, c2: 8, c3: 24, main: 0\n```\n\n通过 gdb 的输出，可以发现闭包产生的匿名数据类型，格式和 struct 是一样的。\n\n而且闭包是存储在栈上，并且除了捕获的数据外，闭包本身不包含任何额外函数指针指向闭包的代码。\n\nRust 为每个闭包生成一个新的类型，使得调用闭包时可以直接和代码对应，省去了使用函数指针再转一道手的额外消耗。\n\n## 闭包类型\n\nRust 中闭包有三种类型约束：\n\n```rust\npub trait FnOnce<Args> {\n    type Output;\n    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n}\n\npub trait FnMut<Args>: FnOnce<Args> {\n    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n}\n\npub trait Fn<Args>: FnMut<Args> {\n    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n}\n```\n\n闭包实现了哪一个 `trait`，只与该闭包**如何使用**捕获环境中的变量有关：\n\n1. 闭包**移出**了所捕获变量的**所有权**，则只会实现 `FnOnce`\n2. 闭包通过**可变借用**使用捕获的变量，则会实现 `FnMut`\n3. 闭包通过**不可变借用**使用捕获的变量/没有捕获变量，则会实现 `Fn`\n\n闭包实现了哪一个 `trait` 只与闭包如何使用所捕获的变量有关，与如何捕获变量无关。\n\n关键字 `move` 影响的是闭包如何捕获变量，因此对闭包实现 `FnOnce`、`FnMut` 和 `Fn` 没有任何影响。\n\n只有移出所有权不太好理解：\n\n```rust\nlet s = String::from(\"fadsfda\");\nlet c = || {\n  let s = s;\n  println!(\"{}\", s);\n};\nc();\nc();\n```\n\n由于 `let s = s` 移出了所有权，所以该闭包只实现了 `FnOnce` \n\n```shell\n |\n |         let s = s;\n |                 ^\nnote: this value implements `FnOnce`, which causes it to be moved when called\n```\n\n只要是将所捕获的变量转移了所有权的使用方法，都会使闭包（仅实现 `FnOnce`）只能调用一次\n\n如果一个闭包被当做 `FnOnce ` 调用，那么它就无法再次被调用\n\n原因就是 `FnOnce` 的调用使用 `call_once` 方法，该方法的第一个参数为 `self` 获取了所有权 \n\n## Copy trait\n\n闭包可以看做一个匿名结构体，其本身是否会实现 Copy trait 取决于捕获的变量\n\n- 捕获的变量为不可变引用&T或具有Copy语义时，闭包会实现 Copy trait\n- 捕获的变量为可变引用&mut T或具有Move语义时，则闭包不会实现 Copy trait\n\n闭包是否实现Copy trait，只与如何捕获变量以及捕获的变量是否实现 Copy trait 有关···\n\n```rust\nlet s = \"sss\";\n\nlet c = move || {\n  println!(\"{}\", s);\n};\n\ncall_copy(c);\n\nfn call_copy<F: Fn() + Copy>(c: F) {\n    c();\n}\n```\n\n- `move` 不会影响闭包对 `Fn`，`FnMut`，`FnOnce` 的实现\n- `move` 会捕获变量所有权，会影响闭包自动实现 Copy trait\n\n## 函数\n\n`fn` 是函数指针类型，也实现了闭包的所有 trait，所以只要接口一致 `fn` 也可以传递\n\n声明参数的时候，可以统一使用泛型`Fnxx`，无论传闭包还是传函数指针都是可以调用\n\n```rust\nfn call_once<F: FnOnce(String)>(arg: String, c: F) {\n  c(arg);\n}\n\nfn not_closure(arg: String) {\n  println!(\"{}\", arg);\n}\n\ncall_once(\"hello\".into(), not_closure);\n\ncall_once(\"hello\".into(), |arg| println!(\"{}\", arg));\n```\n\n","meta":{"size":6196,"birthTime":1663496641426.066,"updateTime":1663496641426.338}}},"__N_SSG":true}
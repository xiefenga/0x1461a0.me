{"pageProps":{"metaTitle":"Vue3的变化","article":{"title":"Vue3的变化","content":"## h函数\r\n\r\nh 函数不会传入 render 函数，被全局导出\r\n\r\n## 异步组件\r\n\r\n```javascript\r\ndefineAsyncComponent({\r\n\tloader: Promise\r\n    loadingComponent: Component\r\n    errorComponent: Component\r\n});\r\n```\r\n\r\n返回一个组件，直接使用就行。\r\n\r\n## Teleport\r\n\r\n将组件结构和真实DOM结构分开\r\n\r\n```vue\r\n<Teleport to=\"css选择器\">\r\n    <Component />\r\n</Teleport>\r\n```\r\n\r\n## Reactivity API\r\n\r\n### API\r\n\r\n|    API     |           传入            |       返回       |                             备注                             |\r\n| :--------: | :-----------------------: | :--------------: | :----------------------------------------------------------: |\r\n| `reactive` |      `plain-object`       |     `Proxy`      |       深度代理对象中的所有成员，如果已经是代理直接返回       |\r\n| `readonly` | `plain-object` or `proxy` |     `Proxy`      |              只能读取代理对象中的成员，不可修改              |\r\n|   `ref`    |           `any`           | `{ value: ... }` | 对 `value` 的访问是响应式的；如果传递的值是一个对象，则会通过 `reactive` 函数进行代理；如果已经是代理，`value` 则是代理，如果是 `ref` 则直接返回 |\r\n| `computed` |        `function`         | `{ value: ... }` |                   返回的格式和 `ref` 相同                    |\r\n\r\n- 如果想要让一个对象变为响应式数据，可以使用 `reactive` 或 `ref`\r\n- 如果想要让一个对象的所有属性只读，使用 `readonly`\r\n- 如果想要让一个非对象数据变为响应式数据，使用 `ref`\r\n- 如果想要根据已知的响应式数据得到一个新的响应式数据，使用 `computed`\r\n\r\n### 监听\r\n\r\n**watchEffect**\r\n\r\n```javascript\r\nconst stop = watchEffect(() => {\r\n    // 该函数会立即执行，然后追中函数中用到的响应式数据，响应式数据变化后会再次执行\r\n})\r\n\r\n// 通过调用stop函数，会停止监听\r\nstop(); // 停止监听\r\n```\r\n\r\n**watch**\r\n\r\n```javascript\r\n// 监听单个数据的变化\r\nconst state = reactive({ count: 0 })\r\nwatch(() => state.count, (newValue, oldValue) => {\r\n    // ...\r\n}, options)\r\n\r\n// ref 可以直接传递 ref 而不传递函数\r\nconst countRef = ref(0);\r\nwatch(countRef, (newValue, oldValue) => {\r\n    // ...\r\n}, options)\r\n\r\n// 监听多个数据的变化\r\nwatch([() => state.count, countRef], ([new1, new2], [old1, old2]) => {\r\n    // ...\r\n});\r\n```\r\n\r\n无论是 `watchEffect` 还是 `watch`，当依赖项变化时，回调函数的运行都是异步的（微队列）\r\n\r\n除非遇到下面的场景，否则均建议选择 `watchEffect`\r\n\r\n- 不希望回调函数一开始就执行\r\n- 数据改变时，需要参考旧值\r\n- 需要监控一些回调函数中不会用到的数据\r\n\r\n### 判断\r\n\r\n| API          | 含义                                                         |\r\n| ------------ | ------------------------------------------------------------ |\r\n| `isProxy`    | 判断某个数据是否是由`reactive`或`readonly`                   |\r\n| `isReactive` | 判断某个数据是否是通过`reactive`创建的，详细:https://v3.vuejs.org/api/basic-reactivity.html#isreactive |\r\n| `isReadonly` | 判断某个数据是否是通过`readonly`创建的                       |\r\n| `isRef`      | 判断某个数据是否是一个`ref`对象                              |\r\n\r\n### 转换\r\n\r\n**unref**\r\n\r\n等同于：`isRef(val) ? val.value : val`\r\n\r\n**toRef**\r\n\r\n得到一个响应式对象某个属性的 `ref` 格式\r\n\r\n```javascript\r\nconst state = reactive({\r\n    foo: 1,\r\n    bar: 2\r\n})\r\n\r\nconst fooRef = toRef(state, 'foo'); // fooRef: {value: ...}\r\n\r\nfooRef.value++\r\nconsole.log(state.foo) // 2\r\n\r\nstate.foo++\r\nconsole.log(fooRef.value) // 3\r\n```\r\n\r\n**toRefs**\r\n\r\n把一个响应式对象的所有属性转换为ref格式，然后包装到一个`plain-object`中返回\r\n\r\n```javascript\r\nconst state = reactive({\r\n    foo: 1,\r\n    bar: 2\r\n})\r\n\r\nconst stateAsRefs = toRefs(state)\r\n/*\r\nstateAsRefs: not a proxy\r\n{\r\n  foo: { value: ... },\r\n  bar: { value: ... }\r\n}\r\n*/\r\n```\r\n\r\n## setup提案\r\n\r\n在 `setup` 脚本中定义的顶级绑定都会被编译为 `setup` 函数的返回值，顶级绑定：\r\n\r\n- `import` \r\n- 顶级变量\r\n\r\n### 组件属性\r\n\r\n```javascript\r\nimport { defineProps } from 'vue'\r\n\r\nconst props = defineProps({\r\n    username: {\r\n        type: String,\r\n        required: true\r\n    }\r\n})\r\n```\r\n\r\n### emit事件\r\n\r\n```javascript\r\nimport { defineEmit } from 'vue'\r\nconst emit = defineEmit(['click']);\r\nconst onClick = () => emit('click');\r\n```\r\n\r\n## Ref语法糖\r\n\r\n只能适用于SFC中（`.vue` 文件中）\r\n\r\n```vue\r\n<script setup>\r\n    Ref: a = 'a';\t// const a = Ref('a')\r\n    Ref: b = 'b';\r\n    Ref: c = computed(() => a + b);\r\n</script>\r\n```\r\n\r\n## Suspense\r\n\r\nfallback插槽：显示的是组件没有加载出来之前显示的内容\r\n\r\ndefault插槽：组件 `setup` 返回的是 `Promise`\r\n\r\n用于处理子组件一开始就需要请求数据的情况，请求数据的请求中需要显示 loading\r\n\r\n## 生命周期\r\n\r\nrenderTracked\r\n\r\nrenderTriggered\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","meta":{"size":5152,"birthTime":1663496641418.7424,"updateTime":1663496641418.9478}}},"__N_SSG":true}
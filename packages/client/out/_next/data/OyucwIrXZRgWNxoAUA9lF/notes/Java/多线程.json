{"pageProps":{"metaTitle":"多线程","article":{"title":"多线程","content":"# 开启线程\r\n\r\n每一个 Java 程序启动后，会默认开启一个主线程，也就是 main 方法所在的线程。\r\n\r\n每一个 线程都是 java.lang.Thread 对象，可以通过 Thread. currentThread 方法获取当前的线程对象。\r\n\r\n1. 传入 Runnable 接口实例\r\n\r\n\t```java\r\n\tThread thread = new Thread(() -> System.out.println(Thread.currentThread()));\r\n\tthread.start();\r\n\t```\r\n\r\n2. 继承 Thread，重写 run 方法\r\n\r\n\t```java\r\n\tpublic class MyThread extends Thread {\r\n\t    @Override\r\n\t    public void run() {\r\n\t        System.out.println(Thread.currentThread());\r\n\t    }\r\n\t}\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t    Thread thread = new MyThread();\r\n\t    thread.start();\r\n\t}\r\n\t```\r\n\r\n调用 `thread.start` 方法会启动线程，`start` 方法会自动调用 `thread` 的 `run` 方法。Thread 实现了 Runnable 接口。\r\n\r\n# 内存布局\r\n\r\n- PC 寄存器（Program Counter Register）：每一个线程都有自己的 PC 寄存器\r\n- Java 虚拟机栈（Java Virtual Machine Stack）：每一个线程都有自己的 Java 虚拟机栈\r\n- 堆（Heap）：多个线程共享堆\r\n- 方法区（Method Area）：多个线程共享方法区\r\n- 本地方法栈（Native Method Stack）：每一个线程都有自己的本地方法栈\r\n\r\n# 线程状态\r\n\r\n可以通过实例方法 `getState` 获得线程的状态。\r\n\r\n线程一共有 6 种状态：\r\n\r\n- `NEW`：尚未启动，新建状态\r\n- `RUNNABLE`：正在 jvm 中运行，或者正在等待操作系统的资源（比如处理器）\r\n- `BLOCKED`：正在等待监视器锁（内部锁），阻塞状态\r\n- `WAITING`：正在等待另一个线程，等待状态\r\n- ","meta":{"size":1656,"birthTime":1663496641380.8762,"updateTime":1663496641381.069}}},"__N_SSG":true}
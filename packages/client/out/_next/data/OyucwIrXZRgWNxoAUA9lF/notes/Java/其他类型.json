{"pageProps":{"metaTitle":"其他类型","article":{"title":"其他类型","content":"# 包装类\r\n\r\n对比引用类型，基本类型存在一些缺陷：\r\n\r\n- 无法表示不存在的值（`null` 值）\r\n- 不能利用面向对象的方式去操作基本类型（比如直接用基本类型调用方法）\r\n- 当方法参数是引用类型时，基本类型无法传递\r\n\r\n数字类型的包装类（`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`）最终都继承自 `java.lang.Number`\r\n\r\n自动装箱：Java 编译器会自动将基本类型转换为包装类（调用静态方法 `valueOf`）\r\n\r\n自动拆箱：Java 编译器会自动将包装类转换为基本类型（调用实例方法 `xxxValue` 方法，例如 `intValue`）\r\n\r\n- 包装类的判等，不要使用 `==`、`!=` 运算符，应该使用 `equals` 方法\r\n- `IntegerCache` 这个内部类中缓存了 [-128, 127] 范围的 `Integer` 对象\r\n- 使用 `Integer.valueOf` 方法会优先去 `IntegerCache` 缓存中获取 `Integer` 对象\r\n- **基本类型数组** 与 **包装类数组** 之间是不能自动装箱、拆箱的\r\n\r\n# 字符串\r\n\r\nJava 中用 `java.lang.String` 类代表字符串\r\n\r\n- 底层使用 `char[]` 存储字符数据，从 Java 9 开始，底层使用 `byte[]` 存储字符数据\r\n- 所有字符串字面量（比如 `\"ABC\"`）都是 `String` 类的实例\r\n- `String` 对象一旦创建完毕，它的字符内容是不可以修改的\r\n\r\n## 字符串常量池\r\n\r\nJava 中有个字符串常量池（String Constant Pool，简称 SCP）\r\n\r\n- 当遇到**字符串字面量**时，会去查看 SCP\r\n\t- 如果 SCP 中存在与字面量内容一样的字符串对象 A 时，就返回 A\r\n\t- 否则，创建一个新的字符串对象 D，并加入到 SCP 中，返回 D\r\n- 字符串常量池从 Java 7 开始属于堆空间的一部分（以前放在方法区）\r\n\r\n## intern\r\n\r\n- 如果 SCP 中存在与 A **内容一样**的字符串对象 C 时，就返回 C\r\n\r\n- 否则，将 A 加入到 SCP 中，返回 A\r\n\r\n```java\r\nString s1 = String.format(\"%d%d%d\", 1, 2, 3);\r\nString s2 = String.format(\"%d%d%d\", 1, 2, 3);\r\nString s3 = s1.intern();\r\nString s4 = s2.intern();\r\nString s5 = \"123\";\r\nSystem.out.println(s1 == s2); // false\r\nSystem.out.println(s1 == s3); // true\r\nSystem.out.println(s1 == s4); // true\r\nSystem.out.println(s1 == s5); // true\r\n```\r\n\r\n## StringBuilder\r\n\r\n在进行大量字符串的改动操作时（比如拼接、替换）：\r\n\r\n- 使用 String 会非常消耗内存、降低程序性能\r\n- 使用 `StringBuilder` 可以节省内存、提高程序性能\r\n\r\nStringBuilder 的常用方法有：`append`、`insert`、`delete`、`replace`、`reverse`等\r\n\r\n# 枚举\r\n\r\n如果一个变量的取值只可能是固定的几个值，可以考虑使用枚举类型\r\n\r\n- 枚举由一组预定义的常量构成，每个常量都是一个该类型的变量\r\n- 枚举的本质是类，所有枚举类型最终都隐式继承自 `java.lang.Enum`\r\n- 枚举定义完常量后，可以再定义成员变量、方法等内容，常量之间通过 `,` 分隔，最后一个常量需要使用 `;`\r\n- 枚举的构造方法权限必须是 无修饰符 或者 `private`\r\n- Java 会主动调用构造方法初始化每一个常量，你不能主动调用构造方法\r\n\r\n```java\r\npublic enum Season {\r\n    SPRING(\"spring\"),\r\n    SUMMER(\"summer\"),\r\n    FALL(\"fall\"),\r\n    WINTER(\"winter\");\r\n\r\n    private String name;\r\n\r\n    private  Season(String name) {\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nSeason s = Season.SUMMER;\r\n```\r\n\r\n枚举就相当于：\r\n\r\n```java\r\npublic class Season {\r\n    public static final Season SPRING = new Season(\"spring\");\r\n    public static final Season SUMMER = new Season(\"summer\");\r\n    public static final Season FALL = new Season(\"fall\");\r\n    public static final Season WINTER = new Season(\"winter\");\r\n    private String name;\r\n\r\n    private  Season(String name) {\r\n        this.name = name;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n","meta":{"size":3856,"birthTime":1663496641380.5962,"updateTime":1663496641380.8022}}},"__N_SSG":true}
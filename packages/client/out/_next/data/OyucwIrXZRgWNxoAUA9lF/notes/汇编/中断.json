{"pageProps":{"metaTitle":"中断","article":{"title":"中断","content":"# 中断\r\n\r\n任何一个通用的 CPU，都有一种能力：可以在执行完当前正在执行的指令之后，检测到 CPU 外部或内部发送过来的一种特殊信息，并立即做出处理。\r\n\r\n这种特殊的信息就叫中断信息，中断就是 CPU 不接着往下执行而是去处理这个特殊的中断信息。\r\n\r\n# 内中断\r\n\r\n对于 8086 来说，当 CPU 内部发生以下情况，会产生中断信息：\r\n\r\n1. 除法错误\r\n2. 单步执行\r\n3. 执行 into 指令\r\n4. 执行 int 指令\r\n\r\n中断信息的来源：8086 用称为**中断类型码**的数据标识中断信息的来源。\r\n\r\n8086 的中断类型码使用一个字节标识，所以 8086 具有 256 种中断信息的来源。\r\n\r\n具体就是：\r\n\r\n1. 除法错误：0\r\n2. 单步执行：1\r\n3. 执行 into 指令：4\r\n4. 执行 int 指令：`int n` n 即为类型码\r\n\r\n# 中断向量表\r\n\r\nCPU 在收到中断信息之后，需要对中断信息进行处理。也就是转去执行处理该中断的程序，用来处理中断信息的程序称为**中断处理程序**。\r\n\r\n中断处理程序也称**中断例程**。\r\n\r\n中断向量：中断处理程序的入口地址\r\n\r\n中断向量表：中断处理程序入口地址的列表，相当于是中断类型码和中断向量的映射，一个表项存放一个中断向量。\r\n\r\nCPU 只要知道了中断类型码，就可以将中断类型码作为中断向量表的表项号，定位相应的表项得到中断处理程序的入口地址。\r\n\r\n中断向量表在内存中存放，8086 CPU规定，中断向量表指定放在内存地址为 0000:0000 - 0000:03FF 的 1024 个内存单元中，每个表项占据**两个字**，高地址存放段地址，低地址存放偏移地址。\r\n\r\n8086 CPU 中 N 号中断源对应的中断向量的**段地址**和**偏移地址**分别为：`N * 4`、`N * 4 + 2`\r\n\r\n# 中断过程\r\n\r\n中断过程就是利用中断类型码从中断向量表中找到对应中断处理程序的地址，使用该地址设置 CS 和 IP 寄存器，让 CPU 执行该中断处理程序。\r\n\r\n但是 CPU 需要保护现场，需要将此时的 CS 和 IP 入栈，不然中断处理程序完成之后不知道从哪恢复执行。\r\n\r\n中断过程是由一个硬件自动执行的过程。\r\n\r\n中断过程细节：\r\n\r\n1. 从中断信息中获取中断类型码 N\r\n2. 标志寄存器的值入栈（因为中断过程中会用到标志寄存器，先将其值保存）\r\n3. 设置标志寄存器 TF 和 IF 值为 0\r\n4. CS 入栈\r\n5. IP 入栈\r\n6. 从内存 `N*4 : N*4+2` 处获取中断向量，并设置 CS 和 IP\r\n\r\n# 中断处理程序\r\n\r\n中断处理程序的编写和子程序非常相似：\r\n\r\n1. 保存用到的寄存器\r\n2. 处理中断\r\n3. 恢复用到的寄存器\r\n4. 使用 `iret` 指令返回\r\n\r\n`iret` 指令相当于：\r\n\r\n```assembly\r\npop IP\r\npop CS\r\npopf\r\n```\r\n\r\n`iret` 和硬件自动完成的中断过程配合即可实现中断的处理。\r\n\r\n# 单步中断\r\n\r\nCPU 在执行完一条指令之后，如果检测到标志寄存器的 **TF** 位为 1，则产生**单步中断**。\r\n\r\n产生单步中断，CPU 会转而去执行单步中断处理程序，但是在执行中断程序时，TF = 1，则又得触发中断，所以在中断过程中，CPU 会将 TF 设置为 0 避免这种死循环的发生。\r\n\r\nCPU 提供的单步中断功能，给单步跟踪程序的执行过程提供了实现机制。\r\n\r\n# BIOS\r\n\r\nBIOS 是在系统板的 ROM 中存放的一套程序，主要包含的内容：\r\n\r\n1. 硬件系统的检测和初始化的程序\r\n2. 外部中断和内部中断的中断处理程序\r\n3. 用于对硬件设备进行 I/O 操作的中断例程\r\n4. 其他和硬件系统相关的中断处理程序\r\n\r\nBIOS 中断程序的安装过程：\r\n\r\n1. CPU 一加电，初始化 CS = 0FFFFH，IP = 0，FFFF:0 处的指令为跳转指令，跳转到 BIOS 中的硬件系统检测和初始化程序\r\n2. 初始化程序将 BIOS 支持的中断向量登记到中断向量表中，由于这些中断处理程序存在 ROM 中，无需调入内存，直接登记地址即可\r\n3. 硬件系统检测和初始化完成之后，调用 `int 19h` 进行操作系统的引导，从此计算机由操作系统控制\r\n4. 操作系统启动后，除了其他的工作，还将它提供的中断处理程序调入内存，并在中断向量表中登记\r\n\r\n# 一些中断\r\n\r\n一般一个供我们调用的中断程序往往包含多个子程序，内部通过传递进来的参数来决定执行哪一个子程序。\r\n\r\nBIOS 和 DOS 提供的中断例程都使用 ah 寄存器来传递内部子程序的编号。\r\n\r\n## int 10h\r\n\r\nint 10h 是 BIOS 提供的中断程序。\r\n\r\n在内存地址空间中，B8000H - BFFFFH 共 32KB 的空间，为 80 * 25 彩色字符模式的显示缓冲区。\r\n\r\n显示缓冲区分为 8 页，每页 4KB大小，显示器可以显示任意一页的内容，一般显示第 0 页的内容。通常情况下 B8000H - B8F9FH 中的 4KB 内容将出现在屏幕上。\r\n\r\n2 号子程序用于设置光标：\r\n\r\n```assembly\r\nmov ah, 2\r\nmov bh, 0 ;页码\r\nmov dh, 5  ;行号\r\nmov dl, 12 ;列号\r\nint 10h\r\n```\r\n\r\n9 号子程序在光标位置显示字符：\r\n\r\n```assembly\r\nmov ah, 2\r\nmov al, 'a' ; 字符\r\nmov bl, 11001010B\t; 颜色属性\r\nmov bh, 0\t; 页码\r\nmov cx, 3\t; 字符重复个数\r\nint 10h\r\n```\r\n\r\n## int 21h\r\n\r\nint 21h 是 DOS 提供的中断例程。\r\n\r\n4ch 号子程序，为程序返回功能：\r\n\r\n```assembly\r\nmov ah, 4ch\r\nmov al, 0\t;返回值\r\nint 21h\r\n```\r\n\r\n9号子程序，在光标位置显示字符串：\r\n\r\n```assembly\r\nds:dx 指向字符串,字符串以 '$' 结尾\r\nmov ah, 9\r\nint 21h\r\n```\r\n\r\n# 外中断\r\n\r\n## 端口\r\n\r\n各种存储器都和 CPU 的地址线、数据线、控制线相连，CPU 在控制它们的时候都把它们当作内存来对待。\r\n\r\n和 CPU 通过总线相连的芯片除了各种存储器，还有：\r\n\r\n1. 各种接口卡，例如网卡、显卡，它们控制接口卡的工作\r\n2. 主板上的接口芯片，CPU 通过它们对部分外设进行访问\r\n3. 其他芯片，用来存储系统信息或其他作用，例如存储时间的芯片\r\n\r\n这些芯片中都有一组可以通过 CPU 读写的寄存器，CPU 将这些**寄存器**当作**端口**，并对它们进行统一编址，和内存一样在地址空间中拥有一个地址。\r\n\r\n- 外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中，由 CPU 来读取；\r\n\r\n- CPU 向外设的输出也不是直接送入外设，而是送入端口中，再由芯片送到外设中。\r\n\r\nCPU 通过端口来和外部设备进行联系，端口的读写通过 `in` 和 `out` 指令。\r\n\r\n## 外中断信息\r\n\r\n外设的输入被存放在端口中，但外设的输入随时可能到达，CPU 如何及时的知道并处理？\r\n\r\n当外设的输入到达，相关的芯片会向 CPU 发出相应的中断信息。\r\n\r\n外中断的中断类型码通过数据总线传入 CPU，而内中断的类型码在 CPU 内部产生。\r\n\r\n外中断一般分为两类：\r\n\r\n1. 可屏蔽中断，CPU 可以不响应，是否响应看标志寄存器的 IF 位，IF = 0，不响应\r\n2. 不可屏蔽中断，8086 不可屏蔽的中断类型码固定为 2，一般外设的中断都是可屏蔽中断\r\n\r\n中断过程中会将 IF 置 0 的目的就是在进入中断处理程序后，禁止其他的可屏蔽中断。\r\n\r\n将 IF 置 0 可实现关中断，原语的实现应该就是这样。\r\n\r\n8086 提供的指令：\r\n\r\n```assembly\r\nsti ; IF = 1\r\ncli ; IF = 0\r\n```\r\n\r\n","meta":{"size":7479,"birthTime":1663496641433.1167,"updateTime":1663496641433.3984}}},"__N_SSG":true}
{"pageProps":{"metaTitle":"并查集","article":{"title":"并查集","content":"# 并查集\n\n并查集用于处理一些**不相交集合**的合并及查询问题，核心操作就是：\n\n- **查询（find）**：查询两个元素是否在同一个集合中\n- **合并（union）**：把两个不相交的集合合并为一个集合\n\n并查集的重要思想在于，**用集合中的一个元素代表集合**，一个有趣的比喻是把集合看成**帮派**，**帮主**则是代表\n\n一开始每个集合只有自己一个元素，当合并时一个集合则会由多个元素代表元素则为其中一个元素\n\n实现思路：\n\n1. Quick Find：\n\t- 查找的时间复杂度：O(1)\n\t- 合并的时间复杂度：O(n)\n2. Quick Union\n\t- 查找的时间复杂度：O(lgn)\n\t- 合并的时间复杂度：O(lgn)\n\t- Quick Union 的查找和合并操作都可以优化至 O(α(n))，α(n) < 5\n\n## Quick Find\n\nQuick Find 实现让每个元素都指向自己所在集合的代表元素：\n\n![](https://oss.xiefeng.tech/img/20210818214448.png)\n\n```typescript\npublic find(v: number): number {\n    this.checkIndex(v)\n    return this.parents[v]\n}\n\npublic union(v1: number, v2: number): void {\n    const p1 = this.find(v1)\n    const p2 = this.find(v2)\n    if (p1 !== p2) {\n        this.parents = this.parents.map(p => p === p1 ? p2 : p)\n    }\n}\n```\n\n## Quick Union\n\nQuick Union 实现在合并时让一个集合的代表指向另一个集合的代表\n\n![](https://oss.xiefeng.tech/img/20210818214342.png)\n\n```typescript\npublic find(v: number): number {\n    this.checkIndex(v)\n    while (v !== this.parents[v]) {\n        v = this.parents[v]\n    }\n    return v\n}\n\npublic union(v1: number, v2: number): void {\n    const p1 = this.find(v1)\n    const p2 = this.find(v2)\n    if (p1 !== p2) {\n        this.parents[p1] = p2\n    }\n}\n```\n\n# 优化\n\n在 union 的过程中，会出现树不平衡的情况，最差会变成链表\n\n有两种常见的优化f方式：\n\n- 基于 size 优化：union 时元素少的合并到元素多的集合上\n- 基于 rank 优化：union 时树矮的集合合并到高的集合上\n\n```typescript\npublic override union(v1: number, v2: number): void {\n    const p1 = this.find(v1)\n    const p2 = this.find(v2)\n    if (p1 !== p2) {\n        const rank1 = this.rank[v1]\n        const rank2 = this.rank[v2]\n        if (rank1 < rank2) {\n            this.parents[p1] = p2\n        } else if (rank1 > rank2) {\n            this.parents[p2] = p1\n        } else {\n            this.parents[p1] = p2\n            this.rank[p2] = rank2 + 1\n        }\n    }\n}\n```\n\n基于 size 的优化也会存在树不平衡的问题：\n\n![](https://oss.xiefeng.tech/img/20210818220048.png)\n\n基于 rank 的优化树会相对平衡一点，但是随着 union 的次数增多，树依旧会越来越高\n\nfind 操作就会变慢，因为底层节点需要一层一层往上找\n\n## 路径压缩\n\n路径压缩就是在执行 find 操作时，顺便让路径上所有的节点都指向根节点，从而减低树的高度：\n\n![](https://oss.xiefeng.tech/img/20210818220418.png)\n\n```typescript\npublic override find(v: number): number {\n    this.checkIndex(v)\n    if (this.parents[v] !== v) {\n        this.parents[v] = this.find(this.parents[v])\n    }\n    return this.parents[v]\n}\n```\n\n## 路径分裂\n\n路径分裂就是将路径上的每一个节点都指向其祖先节点：\n\n```typescript\npublic override find(v: number): number {\n    this.checkIndex(v)\n    const parents = this.parents\n    while (v !== parents[v]) {\n        const p = parents[v];\n        parents[v] = parents[parents[v]];\n        v = p;\n    }\n    return v;\n}\n```\n\n## 路径减半\n\n路径减半就是使路径上每隔一个节点就指向其祖父节点：\n\n```typescript\npublic override find(v: number): number {\n    this.checkIndex(v)\n    const parents = this.parents\n    while (v !== parents[v]) {\n        parents[v] = parents[parents[v]];\n        v = parents[v];\n    }\n    return v;\n}\n```\n\n使用路径压缩、分裂或减半 + 基于 rank 或者 size 的优化，可以确保每个操作的均摊时间复杂度为  O(α(n))\n\n","meta":{"size":4002,"birthTime":1663496641431.0193,"updateTime":1663496641431.193}}},"__N_SSG":true}
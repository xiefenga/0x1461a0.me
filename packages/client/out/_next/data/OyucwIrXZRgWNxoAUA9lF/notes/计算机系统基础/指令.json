{"pageProps":{"metaTitle":"指令","article":{"title":"指令","content":"## CPU工作原理\n\n冯诺依曼式计算机采用**存储程序**的工作方式，数据和指令事先存放在存储器中，形式上没有差别\n\n每条指令和每个数据都有各自的地址，其中指令按序存放，PC 中存放着程序下一条需要执行指令的地址，指令由 OP、ADDR 字段组成\n\nCPU 能自动地取出一条一条指令执行无需人为干预，指令和数据被从存储器取到 CPU，存放在寄存器中，其中指令在 IR 中，数据在通用寄存器中\n\nCPU 执行指令的一般步骤：\n\n1. 从 PC 指向的地址中取出指令\n2. 修改 PC 的值，指向下一条指令\n3. 对指令进行译码\n4. 执行该条指令\n\n## 指令集体系结构\n\n指令集体系结构（ISA）是一种规约，它规定了如何使用硬件\n\n- 所有**可执行指令的集合**\n- 指令格式、操作种类以及每种操作对应的操作数的相应规定\n- 指令可以接受的操作数的类型\n- 操作数所能存放的寄存器组的结构，包括每个寄存器的名称、编号、 长度和用途\n- 操作数所能存放的存储空间的大小和编址方式\n- 操作数在存储空间存放时按照大端还是小端方式存放\n- 指令获取操作数的方式，即寻址方式\n- 指令执行过程的控制方式，包括程序计数器、条件码定义等\n\nISA 在计算机系统中是必不可少的一个**抽象层**，缺少 ISA 软件无法使用计算机硬件，一台计算机也不能称为“通用计算机“\n\nISA 和计算机组成（微体系结构）的关系：ISA 是计算机组成的抽象，同一种 ISA 可以有不同的计算机组成\n\n相当于 ISA 规定了接口，计算机组成是具体的实现方式，实现方式是不唯一的，例如：乘法指令可用 ALU 或乘法器实现\n\n## C 语言转换过程\n\n用 GCC 编译器套件进行转换的过程：\n\n1. 预处理：在高级语言源程序中插入所有用 `#include` 命令指定的文件和用 `#define` 声明指定的宏\n\n2. 编译：将预处理后的源程序文件编译生成相应的汇编语言程序\n\n3. 汇编：由汇编程序将汇编语言源程序文件转换为**可重定位的机器语言目标代码文件**\n\n4. 链接：由**链接器**将多个可重定位的机器语言目标文件以及库例程（如 `printf` 库函数）链接起来，生成最终的**可执行目标文件**\n\n\n![](https://oss.xiefeng.tech/images/20211026231522.png)\n\n## x86 架构\n\nx86 是 Intel 开发的一类处理器体系结构的泛称，包括 Intel 8086、80286、i386 和 i486 等，因此其架构被称为 “x86”\n\nIntel 把 32 位 x86 架构的名称 x86-32 改称为 IA-32，IA 是 Intel Architecture 的缩写\n\n兼容 IA-32 指令集的 64 位版本：\n\n- 命名为 “x86-64” ，有时也简称为 x64\n\n- AMD 首先提出，并称其为 AMD64\n- Intel 称其为 Intl64\n\nIA-32 架构由16位架构发展而来，虽然字长为32 位或更大 ，但一个字固定为 16 位，长度后缀为 w，32 位为双字，长度后缀为 l\n\n## 过程调用\n\n过程调用在使用机器级指令的一般执行步骤（P为调用者，Q为被调用者）\n\n1. P 保存被调用函数所需的参数，并且 Q 能够访问到这些参数\n2. P 保存调用完成后的返回地址，然后控制转移到 Q\n3. Q 保存 P的现场（将自己需要用到的寄存器入栈）\n4. 执行 Q 的过程体（函数体），为自己的局部变量分配空间\n5. Q 恢复 P 的现场，释放过程占用的内存空间\n6. Q 取出返回地址，并将控制转移到 P\n\n核心是需要**保护现场**和**恢复现场**，本质的原因是所有过程**共享一套通用寄存器**\n\n参数的传递可以通过寄存器，也可以通过栈，主要还是看寄存器和参数的数量\n\n### 栈和栈帧\n\nCPU 往往会提供栈操作的指令，主要是通过栈顶指针寄存器指示当前栈顶的位置，通过修改栈顶指针寄存器的值来实现入栈和出栈的操作\n\n一个过程的调用会在栈中压入一个栈帧，栈帧本质上就是栈中的一块内存空间，其中存储了该过程调用中所有的局部变量和可能需要传递的参数，以及对父过程现场的保护（寄存器）\n\n在可执行文件中存在一部分的空间分配给栈（往往栈顶在低地址部分，栈底在高地址部分），用于实现一个一个的过程调用\n\n![](https://oss.xiefeng.tech/images/20211028220624.png)\n\n所谓的栈还是存在于逻辑上，在内存的层面上不存在栈这种结构，只是通过栈的方式去操作内存去达到这种数据结构的特点\n\n栈帧在不同的角度是不同的，通过 `push` 指令去入栈，那么栈帧意味着就是一个存储单元（字节）或者一个字等大小\n\n而在过程调用的角度，一个栈帧就是一个过程调用所占用的内存大小，在 IA-32 往往通过 EBP 和 ESP 寄存器来表示栈顶的栈帧\n\n在 x86-64 由于地址是 64 bit 的，所以使用 rbp 和 rsp 寄存器来表示当前过程调用的栈帧\n\n### 机器级表示\n\n```c\nint add(int x, int y) {\n  return  x + y;\n}\n\nint caller() {\n  int t1 = 125, t2 = 80;\n  int sum = add(t1, t2);\n  return sum;\n}\n```\n\n可以将源码编译之后再反汇编，查看相关的过程调用指令\n\n```shell\ngcc -o process_call process_call.c && objdump -d process_call > process_call.s\n```\n\n在 x86_64-redhat-linux 环境下进行编译，使用 objdump 可以得到该程序 `caller` 函数所对应的汇编指令\n\n![](https://oss.xiefeng.tech/images/20211104191221.png)\n\n## 数据对齐\n\n在读写数据时主存按一个**传送单位**（字长）进行传输，这意味着如果传送单位为 64 位，则第 0~7 字节同时读写，第 8~15 字节同时读写\n\n而内存按字节编址，所以如果要读取 `0x7 ~ 0x8` 这两个内存单元，则需要进行两次访存\n\n指令系统支持对字节、半字、字及双字的运算，所以为了提高效率，编译器会让各种不同长度的数据存放时**按边界对齐**\n\n以 32 位系统为例，不同系统采用的内存对齐策略有些许差别\n\n- Windows 采用策略\n\n  - char 型无需对齐\n  - int 型地址是 4 的倍数、short 型地址是2 的倍数\n  - float 型的是4 的倍数、double 和 long long 型的是8的倍数\n- Linux采用更宽松策略\n  - short 型是2的倍数\n  - 其他类型如 int、 float、double 和指针等都是 4 的倍数\n\n对于结构来说，**结构变量首地址**按 4 字节边界对齐，结构数组变量的最末可能需要插空，以使每个数组元素都按 4 字节边界对齐\n\n对于成员相同的两个结构，两者所占用的空间并不相同：\n\n```c\nstruct c1 {\n  int i;\n  char c;\n  int j;\n};\n\nstruct c2 {\n  int i;\n  int j;\n  char c;\n};\n```\n\n![](https://oss.xiefeng.tech/images/20211104193712.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","meta":{"size":6798,"birthTime":1663496641439.1555,"updateTime":1663496641439.3655}}},"__N_SSG":true}
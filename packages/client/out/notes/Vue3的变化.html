<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>Vue3的变化 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#h函数" data-target-id="h2-h函数-0">h函数</a></li><li><a href="#异步组件" data-target-id="h2-异步组件-1">异步组件</a></li><li><a href="#Teleport" data-target-id="h2-Teleport-2">Teleport</a></li><li><a href="#Reactivity API" data-target-id="h2-Reactivity API-3">Reactivity API</a><ul><li><a href="#API" data-target-id="h3-API-0">API</a></li><li><a href="#监听" data-target-id="h3-监听-1">监听</a></li><li><a href="#判断" data-target-id="h3-判断-2">判断</a></li><li><a href="#转换" data-target-id="h3-转换-3">转换</a></li></ul></li><li><a href="#setup提案" data-target-id="h2-setup提案-4">setup提案</a><ul><li><a href="#组件属性" data-target-id="h3-组件属性-4">组件属性</a></li><li><a href="#emit事件" data-target-id="h3-emit事件-5">emit事件</a></li></ul></li><li><a href="#Ref语法糖" data-target-id="h2-Ref语法糖-5">Ref语法糖</a></li><li><a href="#Suspense" data-target-id="h2-Suspense-6">Suspense</a></li><li><a href="#生命周期" data-target-id="h2-生命周期-7">生命周期</a></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">Vue3的变化</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h2>h函数</h2>
<p>h 函数不会传入 render 函数，被全局导出</p>
<h2>异步组件</h2>
<pre><code class="language-javascript">defineAsyncComponent({
	loader: Promise
    loadingComponent: Component
    errorComponent: Component
});
</code></pre>
<p>返回一个组件，直接使用就行。</p>
<h2>Teleport</h2>
<p>将组件结构和真实DOM结构分开</p>
<pre><code class="language-vue">&lt;Teleport to=&quot;css选择器&quot;&gt;
    &lt;Component /&gt;
&lt;/Teleport&gt;
</code></pre>
<h2>Reactivity API</h2>
<h3>API</h3>
<table><thead><tr><th style="text-align:center">API</th><th style="text-align:center">传入</th><th style="text-align:center">返回</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><code>reactive</code></td><td style="text-align:center"><code>plain-object</code></td><td style="text-align:center"><code>Proxy</code></td><td style="text-align:center">深度代理对象中的所有成员，如果已经是代理直接返回</td></tr><tr><td style="text-align:center"><code>readonly</code></td><td style="text-align:center"><code>plain-object</code> or <code>proxy</code></td><td style="text-align:center"><code>Proxy</code></td><td style="text-align:center">只能读取代理对象中的成员，不可修改</td></tr><tr><td style="text-align:center"><code>ref</code></td><td style="text-align:center"><code>any</code></td><td style="text-align:center"><code>{ value: ... }</code></td><td style="text-align:center">对 <code>value</code> 的访问是响应式的；如果传递的值是一个对象，则会通过 <code>reactive</code> 函数进行代理；如果已经是代理，<code>value</code> 则是代理，如果是 <code>ref</code> 则直接返回</td></tr><tr><td style="text-align:center"><code>computed</code></td><td style="text-align:center"><code>function</code></td><td style="text-align:center"><code>{ value: ... }</code></td><td style="text-align:center">返回的格式和 <code>ref</code> 相同</td></tr></tbody></table>
<ul>
<li>如果想要让一个对象变为响应式数据，可以使用 <code>reactive</code> 或 <code>ref</code></li>
<li>如果想要让一个对象的所有属性只读，使用 <code>readonly</code></li>
<li>如果想要让一个非对象数据变为响应式数据，使用 <code>ref</code></li>
<li>如果想要根据已知的响应式数据得到一个新的响应式数据，使用 <code>computed</code></li>
</ul>
<h3>监听</h3>
<p><strong>watchEffect</strong></p>
<pre><code class="language-javascript">const stop = watchEffect(() =&gt; {
    // 该函数会立即执行，然后追中函数中用到的响应式数据，响应式数据变化后会再次执行
})

// 通过调用stop函数，会停止监听
stop(); // 停止监听
</code></pre>
<p><strong>watch</strong></p>
<pre><code class="language-javascript">// 监听单个数据的变化
const state = reactive({ count: 0 })
watch(() =&gt; state.count, (newValue, oldValue) =&gt; {
    // ...
}, options)

// ref 可以直接传递 ref 而不传递函数
const countRef = ref(0);
watch(countRef, (newValue, oldValue) =&gt; {
    // ...
}, options)

// 监听多个数据的变化
watch([() =&gt; state.count, countRef], ([new1, new2], [old1, old2]) =&gt; {
    // ...
});
</code></pre>
<p>无论是 <code>watchEffect</code> 还是 <code>watch</code>，当依赖项变化时，回调函数的运行都是异步的（微队列）</p>
<p>除非遇到下面的场景，否则均建议选择 <code>watchEffect</code></p>
<ul>
<li>不希望回调函数一开始就执行</li>
<li>数据改变时，需要参考旧值</li>
<li>需要监控一些回调函数中不会用到的数据</li>
</ul>
<h3>判断</h3>
<table><thead><tr><th>API</th><th>含义</th></tr></thead><tbody><tr><td><code>isProxy</code></td><td>判断某个数据是否是由<code>reactive</code>或<code>readonly</code></td></tr><tr><td><code>isReactive</code></td><td>判断某个数据是否是通过<code>reactive</code>创建的，详细:<a href="https://v3.vuejs.org/api/basic-reactivity.html#isreactive">https://v3.vuejs.org/api/basic-reactivity.html#isreactive</a></td></tr><tr><td><code>isReadonly</code></td><td>判断某个数据是否是通过<code>readonly</code>创建的</td></tr><tr><td><code>isRef</code></td><td>判断某个数据是否是一个<code>ref</code>对象</td></tr></tbody></table>
<h3>转换</h3>
<p><strong>unref</strong></p>
<p>等同于：<code>isRef(val) ? val.value : val</code></p>
<p><strong>toRef</strong></p>
<p>得到一个响应式对象某个属性的 <code>ref</code> 格式</p>
<pre><code class="language-javascript">const state = reactive({
    foo: 1,
    bar: 2
})

const fooRef = toRef(state, &#x27;foo&#x27;); // fooRef: {value: ...}

fooRef.value++
console.log(state.foo) // 2

state.foo++
console.log(fooRef.value) // 3
</code></pre>
<p><strong>toRefs</strong></p>
<p>把一个响应式对象的所有属性转换为ref格式，然后包装到一个<code>plain-object</code>中返回</p>
<pre><code class="language-javascript">const state = reactive({
    foo: 1,
    bar: 2
})

const stateAsRefs = toRefs(state)
/*
stateAsRefs: not a proxy
{
  foo: { value: ... },
  bar: { value: ... }
}
*/
</code></pre>
<h2>setup提案</h2>
<p>在 <code>setup</code> 脚本中定义的顶级绑定都会被编译为 <code>setup</code> 函数的返回值，顶级绑定：</p>
<ul>
<li><code>import</code></li>
<li>顶级变量</li>
</ul>
<h3>组件属性</h3>
<pre><code class="language-javascript">import { defineProps } from &#x27;vue&#x27;

const props = defineProps({
    username: {
        type: String,
        required: true
    }
})
</code></pre>
<h3>emit事件</h3>
<pre><code class="language-javascript">import { defineEmit } from &#x27;vue&#x27;
const emit = defineEmit([&#x27;click&#x27;]);
const onClick = () =&gt; emit(&#x27;click&#x27;);
</code></pre>
<h2>Ref语法糖</h2>
<p>只能适用于SFC中（<code>.vue</code> 文件中）</p>
<pre><code class="language-vue">&lt;script setup&gt;
    Ref: a = &#x27;a&#x27;;	// const a = Ref(&#x27;a&#x27;)
    Ref: b = &#x27;b&#x27;;
    Ref: c = computed(() =&gt; a + b);
&lt;/script&gt;
</code></pre>
<h2>Suspense</h2>
<p>fallback插槽：显示的是组件没有加载出来之前显示的内容</p>
<p>default插槽：组件 <code>setup</code> 返回的是 <code>Promise</code></p>
<p>用于处理子组件一开始就需要请求数据的情况，请求数据的请求中需要显示 loading</p>
<h2>生命周期</h2>
<p>renderTracked</p>
<p>renderTriggered</p><div><a href="/notes">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"Vue3的变化","article":{"title":"Vue3的变化","content":"## h函数\r\n\r\nh 函数不会传入 render 函数，被全局导出\r\n\r\n## 异步组件\r\n\r\n```javascript\r\ndefineAsyncComponent({\r\n\tloader: Promise\r\n    loadingComponent: Component\r\n    errorComponent: Component\r\n});\r\n```\r\n\r\n返回一个组件，直接使用就行。\r\n\r\n## Teleport\r\n\r\n将组件结构和真实DOM结构分开\r\n\r\n```vue\r\n\u003cTeleport to=\"css选择器\"\u003e\r\n    \u003cComponent /\u003e\r\n\u003c/Teleport\u003e\r\n```\r\n\r\n## Reactivity API\r\n\r\n### API\r\n\r\n|    API     |           传入            |       返回       |                             备注                             |\r\n| :--------: | :-----------------------: | :--------------: | :----------------------------------------------------------: |\r\n| `reactive` |      `plain-object`       |     `Proxy`      |       深度代理对象中的所有成员，如果已经是代理直接返回       |\r\n| `readonly` | `plain-object` or `proxy` |     `Proxy`      |              只能读取代理对象中的成员，不可修改              |\r\n|   `ref`    |           `any`           | `{ value: ... }` | 对 `value` 的访问是响应式的；如果传递的值是一个对象，则会通过 `reactive` 函数进行代理；如果已经是代理，`value` 则是代理，如果是 `ref` 则直接返回 |\r\n| `computed` |        `function`         | `{ value: ... }` |                   返回的格式和 `ref` 相同                    |\r\n\r\n- 如果想要让一个对象变为响应式数据，可以使用 `reactive` 或 `ref`\r\n- 如果想要让一个对象的所有属性只读，使用 `readonly`\r\n- 如果想要让一个非对象数据变为响应式数据，使用 `ref`\r\n- 如果想要根据已知的响应式数据得到一个新的响应式数据，使用 `computed`\r\n\r\n### 监听\r\n\r\n**watchEffect**\r\n\r\n```javascript\r\nconst stop = watchEffect(() =\u003e {\r\n    // 该函数会立即执行，然后追中函数中用到的响应式数据，响应式数据变化后会再次执行\r\n})\r\n\r\n// 通过调用stop函数，会停止监听\r\nstop(); // 停止监听\r\n```\r\n\r\n**watch**\r\n\r\n```javascript\r\n// 监听单个数据的变化\r\nconst state = reactive({ count: 0 })\r\nwatch(() =\u003e state.count, (newValue, oldValue) =\u003e {\r\n    // ...\r\n}, options)\r\n\r\n// ref 可以直接传递 ref 而不传递函数\r\nconst countRef = ref(0);\r\nwatch(countRef, (newValue, oldValue) =\u003e {\r\n    // ...\r\n}, options)\r\n\r\n// 监听多个数据的变化\r\nwatch([() =\u003e state.count, countRef], ([new1, new2], [old1, old2]) =\u003e {\r\n    // ...\r\n});\r\n```\r\n\r\n无论是 `watchEffect` 还是 `watch`，当依赖项变化时，回调函数的运行都是异步的（微队列）\r\n\r\n除非遇到下面的场景，否则均建议选择 `watchEffect`\r\n\r\n- 不希望回调函数一开始就执行\r\n- 数据改变时，需要参考旧值\r\n- 需要监控一些回调函数中不会用到的数据\r\n\r\n### 判断\r\n\r\n| API          | 含义                                                         |\r\n| ------------ | ------------------------------------------------------------ |\r\n| `isProxy`    | 判断某个数据是否是由`reactive`或`readonly`                   |\r\n| `isReactive` | 判断某个数据是否是通过`reactive`创建的，详细:https://v3.vuejs.org/api/basic-reactivity.html#isreactive |\r\n| `isReadonly` | 判断某个数据是否是通过`readonly`创建的                       |\r\n| `isRef`      | 判断某个数据是否是一个`ref`对象                              |\r\n\r\n### 转换\r\n\r\n**unref**\r\n\r\n等同于：`isRef(val) ? val.value : val`\r\n\r\n**toRef**\r\n\r\n得到一个响应式对象某个属性的 `ref` 格式\r\n\r\n```javascript\r\nconst state = reactive({\r\n    foo: 1,\r\n    bar: 2\r\n})\r\n\r\nconst fooRef = toRef(state, 'foo'); // fooRef: {value: ...}\r\n\r\nfooRef.value++\r\nconsole.log(state.foo) // 2\r\n\r\nstate.foo++\r\nconsole.log(fooRef.value) // 3\r\n```\r\n\r\n**toRefs**\r\n\r\n把一个响应式对象的所有属性转换为ref格式，然后包装到一个`plain-object`中返回\r\n\r\n```javascript\r\nconst state = reactive({\r\n    foo: 1,\r\n    bar: 2\r\n})\r\n\r\nconst stateAsRefs = toRefs(state)\r\n/*\r\nstateAsRefs: not a proxy\r\n{\r\n  foo: { value: ... },\r\n  bar: { value: ... }\r\n}\r\n*/\r\n```\r\n\r\n## setup提案\r\n\r\n在 `setup` 脚本中定义的顶级绑定都会被编译为 `setup` 函数的返回值，顶级绑定：\r\n\r\n- `import` \r\n- 顶级变量\r\n\r\n### 组件属性\r\n\r\n```javascript\r\nimport { defineProps } from 'vue'\r\n\r\nconst props = defineProps({\r\n    username: {\r\n        type: String,\r\n        required: true\r\n    }\r\n})\r\n```\r\n\r\n### emit事件\r\n\r\n```javascript\r\nimport { defineEmit } from 'vue'\r\nconst emit = defineEmit(['click']);\r\nconst onClick = () =\u003e emit('click');\r\n```\r\n\r\n## Ref语法糖\r\n\r\n只能适用于SFC中（`.vue` 文件中）\r\n\r\n```vue\r\n\u003cscript setup\u003e\r\n    Ref: a = 'a';\t// const a = Ref('a')\r\n    Ref: b = 'b';\r\n    Ref: c = computed(() =\u003e a + b);\r\n\u003c/script\u003e\r\n```\r\n\r\n## Suspense\r\n\r\nfallback插槽：显示的是组件没有加载出来之前显示的内容\r\n\r\ndefault插槽：组件 `setup` 返回的是 `Promise`\r\n\r\n用于处理子组件一开始就需要请求数据的情况，请求数据的请求中需要显示 loading\r\n\r\n## 生命周期\r\n\r\nrenderTracked\r\n\r\nrenderTriggered\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","meta":{"size":5152,"birthTime":1663496641418.7424,"updateTime":1663496641418.9478}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["Vue3的变化"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>多路分解 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#运输层的作用" data-target-id="h1-运输层的作用-0">运输层的作用</a><ul><li><a href="#多路分解和复用" data-target-id="h2-多路分解和复用-0">多路分解和复用</a></li><li><a href="#端口" data-target-id="h2-端口-1">端口</a></li></ul></li><li><a href="#UDP的多路分解" data-target-id="h1-UDP的多路分解-1">UDP的多路分解</a></li><li><a href="#UDP 套接字" data-target-id="h1-UDP 套接字-2">UDP 套接字</a></li><li><a href="#TCP的多路分解" data-target-id="h1-TCP的多路分解-3">TCP的多路分解</a></li><li><a href="#TCP 服务器，欢迎套接字" data-target-id="h1-TCP 服务器，欢迎套接字-4">TCP 服务器，欢迎套接字</a></li><li><a href="#来新的连接，创建一个新的 TCP 套接字" data-target-id="h1-来新的连接，创建一个新的 TCP 套接字-5">来新的连接，创建一个新的 TCP 套接字</a></li><li><a href="#让每个连接对应一个线程来处理" data-target-id="h1-让每个连接对应一个线程来处理-6">让每个连接对应一个线程来处理</a></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">多路分解</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h1>运输层的作用</h1>
<p>运输层将网络层在两个<strong>端系统</strong>之间的交付扩展到了运行在两个端系统上的<strong>应用进程</strong>之间的交付。</p>
<p>或者说运输层的协议为运行在不同主机上的<strong>应用进程</strong>提供了<strong>逻辑通信</strong>的能力。</p>
<p>运输层提供的最低限度的服务有两种：</p>
<ul>
<li>进程到进程的数据交付</li>
<li>差错检查</li>
</ul>
<p>因特网中的运输层协议有两种：UDP（用户数据报协议） 和 TCP（传输控制协议）</p>
<p>RFC 文档将 TCP 的分组称为报文段（segment），将 UDP 的分组称为数据报，将网络层的分为也称为数据报（datagram）。</p>
<p>这是比较严谨的，本质上 UDP 在网络层协议 IP 的基础上没有提供什么能力，就是将数据交给 UDP，UDP 立马交给 IP 协议进行发送。</p>
<p>应用进程和运输层之间不会直接打交道，而是通过套接字来进行数据的传输，所以当运输层收到另一个端系统的某个应用进程发来的数据时，会将该数据交给上层对应的套接字，而非应用进程。</p>
<h2>多路分解和复用</h2>
<p>一台主机上会运行很多的应用进程，每个应用进程又可能会有一个或多个套接字，所以套接字需要有唯一的<strong>标识符</strong>来让运输层可以准确的交付。</p>
<p><strong>多路分解：</strong> 运输层将报文段中的数据交付到正确的套接字的工作</p>
<p><strong>多路复用：</strong> 运输层从上层不同的套接字收集数据并生成报文段，接着将报文段传递到网络层</p>
<p>实现多路分解和复用的要求：</p>
<ol>
<li>套接字有唯一的标识符</li>
<li>每个报文字段有特殊字段（目的端口号、源端口号）来指示该报文字段所要交付的套接字</li>
</ol>
<h2>端口</h2>
<p>端口号是一个 16 bit 的数，大小在 0 ~ 65535 之间。</p>
<p>0 ~ 1023 号端口被称为<strong>周知端口号</strong>，也就是说它们是给特定应用层协议所使用，例如：HTTP 对应的是 80，FTP 对应的是 21</p>
<p>当我们在开发网络应用程序时必须要为其分配一个端口号（严格来说是分配给该程序所使用的套接字），这是运输层为了实现多路分解和复用所必须的。</p>
<p>简单来说运输层会根据套接字所对应的端口号，以及其他的一些信息来判断该将数据交给哪一个套接字。</p>
<h1>UDP的多路分解</h1>
<p>一个 UDP 套接字是由一个二元组进行标识，该二元组是：（目的 IP 地址, 目的端口号）</p>
<p>因为传输层是分析接收到的数据报来进行套接字的定位，所以所谓地目的就是本机。</p>
<p>严格来说，在一台主机上所有的的 UDP 套接字具有相同的 IP 地址，传输层只需要根据目的端口号就可以准确定位套接字。</p>
<p>由于 UDP 套接字仅由目的 IP 和目的端口进行标识，所以只要是发送到该主机的相同端口号的 UDP 报文，都会被交付到相同的进程（套接字）。</p>
<p>通过简单地写一个 UDP 的例子可以明显的看出来，创建的 UDP 套接字是被复用的，或者严格来说相同端口的请求使用的是同一个 UDP 套接字。</p>
<p><strong>server.py</strong></p>
<pre><code class="language-python">server = socket(AF_INET,  SOCK_DGRAM) # UDP 套接字

server.bind((&#x27;&#x27;, 8080))

print(&#x27;server is listening 8080&#x27;)

while True:
    message, addr = server.recvfrom(2048)
    message = message.decode()
    print(&#x27;from client&#x27;, message)
    print(&#x27;client addr&#x27;, addr)
    server.sendto(message.upper().encode(), addr)
</code></pre>
<p><strong>client.ts</strong></p>
<pre><code class="language-typescript">const client = createSocket(&#x27;udp4&#x27;);

client.on(&#x27;message&#x27;, (msg, info) =&gt; {
  console.log(&#x27;from server&#x27;, msg.toString());
  console.log(&#x27;server info&#x27;, info);
  client.close();
});

client.send(&#x27;hello&#x27;, 8080);
</code></pre>
<p>一个容易忽略的点，当我们在创建 UDP 客户端套接字时，往往都是没有分配端口的，这时运输层（操作系统）会自动地为该套接字分配一个端口号，我们也可以手动的 <code>bind</code> 一个端口。</p>
<pre><code class="language-typescript">client.bind(12345);
</code></pre>
<p><img src="http://oss.xiefeng.tech/img/20210629204016.png" alt=""/></p>
<h1>TCP的多路分解</h1>
<p>TCP 套接字由一个四元组标识：（源 IP, 源端口,  目的 IP, 目的端口）</p>
<p>这意味着只要有一个是不同的就不会定向到同一个套接字，和 UDP 更加不同的是一开始并不会创建一个 TCP 套接字。</p>
<p>因为每一个套接字需要依赖四元组，而一开始是没有办法创建一个 TCP 套接字的，因为缺少客户端的信息（源 IP 和源端口），不像 UDP 只要是请求这个端口的都会走这个套接字。</p>
<ul>
<li>当我们使用 TCP 服务器时会先创建一个 “欢迎套接字”，让它监听端口</li>
<li>当主机接收到该端口的建立连接的报文时，会定位到该进程（该进程在等待连接）</li>
<li>然后该进程就会创建一个新的 TCP 套接字，运输层则使用四元组标识该套接字</li>
<li>套接字可以和一个进程关联，也可以和进程的某个线程相关联</li>
</ul>
<p><strong>server.py</strong></p>
<pre><code class="language-python">server = socket(AF_INET, SOCK_STREAM) # TCP 服务器，欢迎套接字

server.bind((&#x27;&#x27;, 8080))

server.listen()

print(&#x27;server is listening 8080&#x27;)

def handleConnection(connectionSocket):
    current = threading.current_thread()
    handleMsg = &#x27;thread: &#x27; + current.name + &#x27; &#x27; + str(current.native_id)
    connectionSocket.send(handleMsg.encode())
    connectionSocket.close()

while True:
    connectionSocket, addr = server.accept() # 来新的连接，创建一个新的 TCP 套接字
    # 让每个连接对应一个线程来处理
    threading.Thread(target=handleConnection, args=(connectionSocket,)).start()
</code></pre><div><a href="/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"多路分解","article":{"title":"多路分解","content":"# 运输层的作用\r\n\r\n运输层将网络层在两个**端系统**之间的交付扩展到了运行在两个端系统上的**应用进程**之间的交付。\r\n\r\n或者说运输层的协议为运行在不同主机上的**应用进程**提供了**逻辑通信**的能力。\r\n\r\n运输层提供的最低限度的服务有两种：\r\n\r\n- 进程到进程的数据交付\r\n- 差错检查\r\n\r\n因特网中的运输层协议有两种：UDP（用户数据报协议） 和 TCP（传输控制协议）\r\n\r\nRFC 文档将 TCP 的分组称为报文段（segment），将 UDP 的分组称为数据报，将网络层的分为也称为数据报（datagram）。\r\n\r\n这是比较严谨的，本质上 UDP 在网络层协议 IP 的基础上没有提供什么能力，就是将数据交给 UDP，UDP 立马交给 IP 协议进行发送。\r\n\r\n应用进程和运输层之间不会直接打交道，而是通过套接字来进行数据的传输，所以当运输层收到另一个端系统的某个应用进程发来的数据时，会将该数据交给上层对应的套接字，而非应用进程。\r\n\r\n## 多路分解和复用\r\n\r\n一台主机上会运行很多的应用进程，每个应用进程又可能会有一个或多个套接字，所以套接字需要有唯一的**标识符**来让运输层可以准确的交付。\r\n\r\n**多路分解：** 运输层将报文段中的数据交付到正确的套接字的工作\r\n\r\n**多路复用：** 运输层从上层不同的套接字收集数据并生成报文段，接着将报文段传递到网络层\r\n\r\n实现多路分解和复用的要求：\r\n\r\n1. 套接字有唯一的标识符\r\n2. 每个报文字段有特殊字段（目的端口号、源端口号）来指示该报文字段所要交付的套接字\r\n\r\n## 端口\r\n\r\n端口号是一个 16 bit 的数，大小在 0 ~ 65535 之间。\r\n\r\n0 ~ 1023 号端口被称为**周知端口号**，也就是说它们是给特定应用层协议所使用，例如：HTTP 对应的是 80，FTP 对应的是 21\r\n\r\n当我们在开发网络应用程序时必须要为其分配一个端口号（严格来说是分配给该程序所使用的套接字），这是运输层为了实现多路分解和复用所必须的。\r\n\r\n简单来说运输层会根据套接字所对应的端口号，以及其他的一些信息来判断该将数据交给哪一个套接字。\r\n\r\n# UDP的多路分解\r\n\r\n一个 UDP 套接字是由一个二元组进行标识，该二元组是：（目的 IP 地址, 目的端口号）\r\n\r\n因为传输层是分析接收到的数据报来进行套接字的定位，所以所谓地目的就是本机。\r\n\r\n严格来说，在一台主机上所有的的 UDP 套接字具有相同的 IP 地址，传输层只需要根据目的端口号就可以准确定位套接字。\r\n\r\n由于 UDP 套接字仅由目的 IP 和目的端口进行标识，所以只要是发送到该主机的相同端口号的 UDP 报文，都会被交付到相同的进程（套接字）。\r\n\r\n通过简单地写一个 UDP 的例子可以明显的看出来，创建的 UDP 套接字是被复用的，或者严格来说相同端口的请求使用的是同一个 UDP 套接字。\r\n\r\n**server.py**\r\n\r\n```python\r\nserver = socket(AF_INET,  SOCK_DGRAM) # UDP 套接字\r\n\r\nserver.bind(('', 8080))\r\n\r\nprint('server is listening 8080')\r\n\r\nwhile True:\r\n    message, addr = server.recvfrom(2048)\r\n    message = message.decode()\r\n    print('from client', message)\r\n    print('client addr', addr)\r\n    server.sendto(message.upper().encode(), addr)\r\n```\r\n\r\n**client.ts**\r\n\r\n```typescript\r\nconst client = createSocket('udp4');\r\n\r\nclient.on('message', (msg, info) =\u003e {\r\n  console.log('from server', msg.toString());\r\n  console.log('server info', info);\r\n  client.close();\r\n});\r\n\r\nclient.send('hello', 8080);\r\n```\r\n\r\n一个容易忽略的点，当我们在创建 UDP 客户端套接字时，往往都是没有分配端口的，这时运输层（操作系统）会自动地为该套接字分配一个端口号，我们也可以手动的 `bind` 一个端口。\r\n\r\n```typescript\r\nclient.bind(12345);\r\n```\r\n\r\n![](http://oss.xiefeng.tech/img/20210629204016.png)\r\n\r\n# TCP的多路分解\r\n\r\nTCP 套接字由一个四元组标识：（源 IP, 源端口,  目的 IP, 目的端口）\r\n\r\n这意味着只要有一个是不同的就不会定向到同一个套接字，和 UDP 更加不同的是一开始并不会创建一个 TCP 套接字。\r\n\r\n因为每一个套接字需要依赖四元组，而一开始是没有办法创建一个 TCP 套接字的，因为缺少客户端的信息（源 IP 和源端口），不像 UDP 只要是请求这个端口的都会走这个套接字。\r\n\r\n- 当我们使用 TCP 服务器时会先创建一个 “欢迎套接字”，让它监听端口\r\n- 当主机接收到该端口的建立连接的报文时，会定位到该进程（该进程在等待连接）\r\n- 然后该进程就会创建一个新的 TCP 套接字，运输层则使用四元组标识该套接字\r\n- 套接字可以和一个进程关联，也可以和进程的某个线程相关联\r\n\r\n**server.py**\r\n\r\n```python\r\nserver = socket(AF_INET, SOCK_STREAM) # TCP 服务器，欢迎套接字\r\n\r\nserver.bind(('', 8080))\r\n\r\nserver.listen()\r\n\r\nprint('server is listening 8080')\r\n\r\ndef handleConnection(connectionSocket):\r\n    current = threading.current_thread()\r\n    handleMsg = 'thread: ' + current.name + ' ' + str(current.native_id)\r\n    connectionSocket.send(handleMsg.encode())\r\n    connectionSocket.close()\r\n\r\nwhile True:\r\n    connectionSocket, addr = server.accept() # 来新的连接，创建一个新的 TCP 套接字\r\n    # 让每个连接对应一个线程来处理\r\n    threading.Thread(target=handleConnection, args=(connectionSocket,)).start()\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","meta":{"size":5664,"birthTime":1663496641447.0618,"updateTime":1663496641447.1685}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["计算机网络","运输层","多路分解"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
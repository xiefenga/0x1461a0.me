<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>HTTP1 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#请求方法" data-target-id="h1-请求方法-0">请求方法</a></li><li><a href="#WEBDAV" data-target-id="h1-WEBDAV-1">WEBDAV</a></li><li><a href="#状态码" data-target-id="h1-状态码-2">状态码</a><ul><li><a href="#100" data-target-id="h2-100-0">100</a></li><li><a href="#200" data-target-id="h2-200-1">200</a></li><li><a href="#300" data-target-id="h2-300-2">300</a></li><li><a href="#400" data-target-id="h2-400-3">400</a></li><li><a href="#500" data-target-id="h2-500-4">500</a></li></ul></li><li><a href="#URI" data-target-id="h1-URI-3">URI</a><ul><li><a href="#组成" data-target-id="h2-组成-5">组成</a></li><li><a href="#编码" data-target-id="h2-编码-6">编码</a></li></ul></li><li><a href="#[ ]" data-target-id="h1-[ ]-4">[ ]</a></li><li><a href="#长连接" data-target-id="h1-长连接-5">长连接</a></li><li><a href="#内容协商" data-target-id="h1-内容协商-6">内容协商</a></li><li><a href="#包体传输" data-target-id="h1-包体传输-7">包体传输</a><ul><li><a href="#定长传输" data-target-id="h2-定长传输-7">定长传输</a></li><li><a href="#分块传输" data-target-id="h2-分块传输-8">分块传输</a></li></ul></li><li><a href="#表单提交" data-target-id="h1-表单提交-8">表单提交</a></li><li><a href="#Range请求" data-target-id="h1-Range请求-9">Range请求</a><ul><li><a href="#请求范围" data-target-id="h2-请求范围-9">请求范围</a></li><li><a href="#服务器响应" data-target-id="h2-服务器响应-10">服务器响应</a><ul><li><a href="#单一范围" data-target-id="h3-单一范围-0">单一范围</a></li><li><a href="#多重范围" data-target-id="h3-多重范围-1">多重范围</a></li></ul></li><li><a href="#条件Range" data-target-id="h2-条件Range-11">条件Range</a></li></ul></li><li><a href="#Cookie" data-target-id="h1-Cookie-10">Cookie</a></li><li><a href="#条件请求" data-target-id="h1-条件请求-11">条件请求</a></li><li><a href="#请求上下文" data-target-id="h1-请求上下文-12">请求上下文</a></li><li><a href="#缓存控制" data-target-id="h1-缓存控制-13">缓存控制</a></li><li><a href="#消息的转发" data-target-id="h1-消息的转发-14">消息的转发</a></li><li><a href="#重定向" data-target-id="h1-重定向-15">重定向</a></li><li><a href="#Upgrade" data-target-id="h1-Upgrade-16">Upgrade</a></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">HTTP1</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h1>请求方法</h1>
<ul>
<li>
<p><code>GET</code>：主要的获取信息方法，幂等方法</p>
</li>
<li>
<p><code>POST</code>：常用于提交 form 表单，新增资源等</p>
</li>
<li>
<p><code>HEAD</code>：类似于 GET 方法，但是服务器不返回 body，用于确认 URI 的有效性及资源更新的日期时间等，幂等方法</p>
</li>
<li>
<p><code>PUT</code>：传输文件，更新资源</p>
</li>
<li>
<p><code>DELETE</code>：删除文件</p>
</li>
<li>
<p><code>CONNECT</code>：要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP，主要使用 SSL 和 TLS 加密内容</p>
</li>
<li>
<p><code>OPTIONS</code>：查询服务器对访问资源支持的方法</p>
</li>
<li>
<p><code>TRACE</code>：路径追踪，回显服务器收到的请求，用于定位问题</p>
</li>
</ul>
<p>发送请求时在 <code>Max-Forwards</code> 首部填入字段，每经过一个服务器就会该字段值就会 -1，为 0 时停止传输，最后接收到的服务器返回 200</p>
<p>客户端可以通过 TRACE 查询发出去的请求是如何经过一系列代理中转的。</p>
<p>但是该方法容易引发 XST(Cross-Site Tracing) 攻击</p>
<h1>WEBDAV</h1>
<p>WebDAV是一组基于超文本传输协议的技术集合，有利于用户间协同编辑和管理存储在万维网服务器文档。</p>
<p>WebDAV 在标准的HTTP协议上扩展了特有的请求方式。 然后用这些请求，操作web服务器上的磁盘。</p>
<ul>
<li><code>PROPFIND</code>：从 Web 资源中检索以 XML 格式存储的属性，也被重载以允许一个检索远程系统的集合结构（目录层次结构）</li>
<li><code>PROPPATCH</code>：在单个原子性动作中更改和删除资源的多个属性</li>
<li><code>MKCOL</code>：创建集合或目录</li>
<li><code>COPY</code>：将资源从一个URI复制到另一个URI</li>
<li><code>MOVE</code>：将资源从一个URI移动到另一个URI</li>
<li><code>LOCK</code>：锁定一个资源</li>
<li><code>UNLOCK</code>：解除资源的锁定</li>
</ul>
<h1>状态码</h1>
<p>客户端如果遇到了无法识别的状态码，会当作该系列的第一个状态码处理，比如 555 会当作 500 来处理</p>
<h2>100</h2>
<p>请求已接收到，需要进一步处理才能完成，HTTP 1.0 不支持</p>
<ul>
<li>100 Continue<!-- -->
<ul>
<li>上传大文件前使用</li>
<li>由客户端发起请求中携带 <code>Expect: 100-continue</code> 头部触发</li>
</ul>
</li>
<li>101 Switch Protocols<!-- -->
<ul>
<li>协议升级使用</li>
<li>由客户端发起请求中携带 <code>Upgrade</code> 头部触发，如升级 websocket 或者 http/2.0</li>
<li>返回该响应码表示服务器同意升级</li>
</ul>
</li>
<li>102 Processing<!-- -->
<ul>
<li>WebDAV 请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求</li>
<li>该代码表示服务器已经收到并正在处理请求，但无响应可用</li>
<li>这样可以防止客户端超时，并假设请求丢失</li>
</ul>
</li>
</ul>
<h2>200</h2>
<p>成功处理请求</p>
<ul>
<li>
<p>200 OK：请求成功</p>
</li>
<li>
<p>201 Created：有新资源在服务器端被成功创建</p>
</li>
<li>
<p>202 Accepted</p>
<ul>
<li>服务器接收并开始处理请求，但请求未处理完成</li>
<li>这样一个模糊的概念是有意如此设计，可以覆盖更多的场景。例如异步、需要长时间处理的任务</li>
</ul>
</li>
<li>
<p>203 Non-Authoritative Information</p>
<p>当代理服务器修改了 origin server 的原始响应包体时（例如更换了HTML中的元素值），代理服务器可以通过修改<code>200</code> 为 <code>203</code> 的方式告知客户端这一事实，方便客户端为这一行为作出相应的处理。<code>203</code> 响应可以被缓存。但是代理服务器一般不会这样做，直接返回 <code>200</code></p>
</li>
<li>
<p>204 No Content：成功执行了请求且不携带响应包体，并暗示客户端无需更新当前的页面视图。</p>
</li>
<li>
<p>205 Reset Content：成功执行了请求且不携带响应包体，同时指明客户端需要更新当前页面视图。</p>
</li>
<li>
<p>206 Partial Content：使用 range 协议时返回部分响应内容时的响应码</p>
</li>
<li>
<p>207 Multi-Status</p>
<ul>
<li>RFC4918</li>
<li>在 WEBDAV 协议中以 XML 返回多个资源的状态</li>
<li>每个资源也有自己的状态码，比如 200</li>
</ul>
</li>
<li>
<p>208 Already Reported</p>
<ul>
<li>RFC5842</li>
<li>为避免相同集合下资源在207响应码下重复上报，使用 <code>208</code> 可以使用父集合的响应码。</li>
</ul>
</li>
</ul>
<h2>300</h2>
<p>重定向使用 Location 指向的资源或者缓存中的资源。在 RFC2068中规定客户端重定向次数不应超过 5 次，以防止死循环。</p>
<ul>
<li>
<p>300 Multiple Choices</p>
<ul>
<li>资源有多种表述，通过 300 返回给客户端后由其自行选择访问哪一种表述</li>
<li>由于缺乏明确的细节，300 很少使用</li>
</ul>
</li>
<li>
<p>301 Moved Permanently</p>
<ul>
<li>资源永久性的重定向到另一个 URI 中</li>
<li>浏览器强制使用GET</li>
</ul>
</li>
<li>
<p>302 Found</p>
<ul>
<li>资源临时的重定向到另一个 URI 中</li>
<li>浏览器强制使用GET</li>
</ul>
</li>
<li>
<p>303 See Other</p>
<p>重定向到其他URI，客户端并且应该使用GET</p>
</li>
<li>
<p>304 Not Modified</p>
<ul>
<li>当客户端拥有可能过期的缓存时，会携带缓存的标识 <code>etag</code>、时间等信息询问服务器缓存是否仍可复用</li>
<li>304是告诉客户端可以复用缓存</li>
</ul>
</li>
<li>
<p>307 Temporary Redirect</p>
<ul>
<li>类似 302</li>
<li>但明确重定向后请求方法必须与原请求方法相同，不得改变</li>
</ul>
</li>
<li>
<p>308 Permanent Redirect</p>
<ul>
<li>类似301</li>
<li>但明确重定向后请求方法必须与原请求方法相同，不得改变</li>
</ul>
</li>
</ul>
<h2>400</h2>
<p>客户端出现错误</p>
<ul>
<li>
<p>400 Bad Request</p>
<ul>
<li>服务器认为客户端出现了错误，但不能明确判断为以下哪种错误时使用此错误码</li>
<li>例如HTTP请求格式错误。浏览器会像对待200一样对待400</li>
</ul>
</li>
<li>
<p>401 Unauthorized</p>
<ul>
<li>表示发送的请求需要有通过HTTP认证</li>
<li>如果之前已经认证过一次，则表示认证失败</li>
</ul>
</li>
<li>
<p>407 Proxy Authentication Required</p>
<p>对需要经由代理的请求，认证信息未通过代理服务器的验证</p>
</li>
<li>
<p>403 Forbidden</p>
<p>服务器理解请求的含义，但没有权限执行此请求 / 请求被拒绝</p>
</li>
<li>
<p>404 Not Found</p>
<p>服务器没有找到对应的资源</p>
</li>
<li>
<p>410 Gone</p>
<p>服务器没有找到对应的资源，且明确的知道该位置永久性找不到该资源</p>
</li>
<li>
<p>405 Method Not Allowed</p>
<p>服务器不支持请求行中的 method 方法</p>
</li>
<li>
<p>406 Not Acceptable</p>
<p>对客户端指定的资源表述不存在（例如对语言或者编码有要求），服务器返回表述列表供客户端选择。</p>
</li>
<li>
<p>408 Request Timeout</p>
<p>服务器接收请求超时</p>
</li>
<li>
<p>409 Conflict</p>
<p>资源冲突，例如上传文件时目标位置已经存在版本更新的资源</p>
</li>
<li>
<p>411 Length Required</p>
<p>如果请求含有包体且未携带 <code>Content-Length</code> 头部，且不属于chunk 类请求时，返回 411</p>
</li>
<li>
<p>412 Precondition Failed</p>
<p>复用缓存时传递的 <code>If-Unmodified-Since</code> 或 <code>If-None-Match</code> 头部不被满足</p>
</li>
<li>
<p>413 Payload Too Large/Request Entity Too Large</p>
<p>请求的包体超出服务器能处理的最大长度</p>
</li>
<li>
<p>414 URI Too Long</p>
<p>请求的 URI 超出服务器能接受的最大长度</p>
</li>
<li>
<p>415 Unsupported Media Type</p>
<p>上传的文件类型不被服务器支持</p>
</li>
<li>
<p>416 Range Not Satisfiable</p>
<p>无法提供 Range 请求中指定的那段包体</p>
</li>
<li>
<p>417 Expectation Failed</p>
<p>对于 <code>Expect</code> 请求头部期待的情况无法满足时的响应码</p>
</li>
<li>
<p>421 Misdirected Request</p>
<p>服务器认为这个请求不该发给它，因为它没有能力处理。</p>
</li>
<li>
<p>426 Upgrade Required</p>
<p>服务器拒绝基于当前 HTTP 协议提供服务，通过 <code>Upgrade</code> 头部告知客户端必须升级协议才能继续处理。</p>
</li>
<li>
<p>428 Precondition Required</p>
<p>用户请求中缺失了条件类头部，例如 <code>If-Match</code></p>
</li>
<li>
<p>429 Too Many Requests</p>
<p>客户端发送请求的速率过快，一般服务器不会返回该状态码，而是返回 503</p>
</li>
<li>
<p>431 Request Header Fields Too Large</p>
<p>请求的 HEADER 头部大小超过限制</p>
</li>
<li>
<p>451 Unavailable For Legal Reasons</p>
<p>RFC7725 ，由于法律原因资源不可访问</p>
</li>
</ul>
<h2>500</h2>
<p>服务器端出现错误</p>
<ul>
<li>
<p>500 Internal Server Error</p>
<p>服务器内部错误，且不属于以下错误类型</p>
</li>
<li>
<p>501 Not Implemented</p>
<p>服务器不支持实现请求所需要的功能</p>
</li>
<li>
<p>502 Bad Gateway</p>
<p>代理服务器无法获取到合法响应</p>
</li>
<li>
<p>503 Service Unavailable</p>
<p>服务器资源尚未准备好处理当前请求</p>
</li>
<li>
<p>504 Gateway Timeout</p>
<p>代理服务器无法及时的从上游获得响应</p>
</li>
<li>
<p>505 HTTP Version Not Supported</p>
<p>请求使用的 HTTP 协议版本不支持</p>
</li>
<li>
<p>507 Insufficient Storage</p>
<p>服务器没有足够的空间处理请求，为了安全一般不会返回</p>
</li>
<li>
<p>508 Loop Detected</p>
<p>访问资源时检测到循环</p>
</li>
<li>
<p>511 Network Authentication Required</p>
<p>代理服务器发现客户端需要进行身份验证才能获得网络访问权限</p>
</li>
</ul>
<h1>URI</h1>
<ul>
<li>URL：Uniform Resource Locator，统一资源定位符，表示资源的位置</li>
<li>URN：Uniform Resource Name<!-- -->
<ul>
<li>期望为资源提供持久的、位置无关的标识方式</li>
<li>例如磁力链接 <code>magnet:?xt=urn:sha1:YNCKHTQC5</code></li>
</ul>
</li>
<li>URI：Uniform Resource Identifier<!-- -->
<ul>
<li>统一资源标识符，用以区分资源</li>
<li>是 URL 和 URN 的超集，用以取代 URL 和 URN 概念</li>
</ul>
</li>
</ul>
<h2>组成</h2>
<p>组成：schema, user information, host, port, path, query, fragme</p>
<p><img src="http://oss.xiefeng.tech/img/20210801102030.png" alt=""/></p>
<p>合法的 URI：</p>
<ul>
<li><code>ftp://ftp.is.co.za/rfc/rfc1808.txt</code></li>
<li><code>http://www.ietf.org/rfc/rfc2396.txt</code></li>
</ul>
<h2>编码</h2>
<p>URL 编码就是是把 URI 中不安全的字符转化为安全字符的过程，对于 URL 中的合法字符，编码和不编码是等价的</p>
<p>RFC3986 文档规定，URL 中只允许包含英文字母、数字、- _ . ~ 4个特殊字符以及所有保留字符</p>
<p>RFC3986 中指定了以下字符为保留字符：! * &#x27; ( ) ; : @ &amp; = + $ , / ? # [ ]</p>
<p><strong>保留字符</strong></p>
<p>URL 可以划分成若干个组件，协议、主机、路径等，当组件中的<strong>普通数据</strong>包含这些特殊字符时，需要对其进行编码</p>
<ol>
<li>
<p>一些字符（:/?#[]@）是用作分隔不同组件的</p>
<p>例如：<code>:</code> 用于分隔协议和主机，<code>/</code> 用于分隔主机和路径，<code>?</code> 用于分隔路径和查询参数等</p>
</li>
<li>
<p>一些字符（!$&amp;&#x27;()*+,;=）用于在每个组件中起到分隔作用的</p>
<p>例如：<code>=</code> 用于表示查询参数中的键值对，<code>&amp;</code> 用于分隔查询多个键值对</p>
</li>
</ol>
<p><strong>不安全字符</strong></p>
<p>有一些字符，当他们直接放在 URL 中的时候，可能会引起解析程序的歧义，这些字符被视为不安全字符，原因有很多。</p>
<ul>
<li>空格：URL 在传输的过程，或者文本处理程序在处理 URL 时，都有可能引入无关紧要的空格，或者去掉了那些有意义的空格</li>
<li>引号和&lt;&gt;：引号和尖括号通常用于在普通文本中起到分隔 URL 的作用</li>
<li>%：百分号本身用作对不安全字符进行编码时使用的特殊字符，因此本身需要编码</li>
<li>......</li>
</ul>
<p><strong>编码方式</strong></p>
<p>URL 编码采用 <strong>百分号编码</strong></p>
<p>URL 编码默认使用的字符集是 US-ASCII</p>
<p>百分号编码就是将字符采用 ASCII 编码的十六进制表示，再加上一个 <code>%</code></p>
<p>对于非 ASCII 字符，需要使用 ASCII 字符集的超集进行编码得到相应的字节，然后对每个字节执行百分号编码</p>
<p>例如：<code>#</code> 在 ASCII 编码中对应的十六进制表示为 <code>23</code>，则 <code>#</code> 的百分号编码为 <code>%23</code></p>
<h1>长连接</h1>
<p>早期 HTTP/1.0 性能上有一个很大的问题：每发起一个请求，都要新建一次 TCP 连接，而且是<strong>串行</strong>请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。</p>
<p>HTTP/1.1 提出了长连接的通信方式，即只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p>
<p>HTTP/1.1 默认是长连接，当想要断开连接时只需要指定 <code>Connection: close</code></p>
<p>HTTP/1.1 之前的版本默认短连接，如果想在旧版本也使用就需要指定 <code>Connection: Keep-alive</code>，服务器会返回 <code>Connection: keep-alive</code> 和 <code>Keep-alive: xxxx</code> 首部</p>
<p>对于陈旧的代理服务器（不认识 <code>Connection</code> 头部）需要使用 <code>Proxy-Connect</code> 头部来替代，当浏览器检测到<strong>正向代理</strong>时，就会这么做</p>
<p><img src="http://oss.xiefeng.tech/img/20210402092543.jpg" alt=""/></p>
<h1>内容协商</h1>
<ul>
<li>
<p>Proactive 主动式内容协商：客户端先在请求头部中提出需要的表述形式，服务器根据这些请求头部提供特定的表述</p>
</li>
<li>
<p>Reactive 响应式内容协商：服务器返回 300 或者 406，由客户端选择一种表述 URI 使用</p>
</li>
</ul>
<p><strong>常见的协商要素：</strong>（请求）</p>
<ul>
<li>
<p>质量因子 q：内容的质量、可接受类型的优先级，和内容通过 <code>;</code> 分隔，默认为 1</p>
<pre><code class="language-http">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
</code></pre>
</li>
<li>
<p>MIME 类型</p>
<pre><code class="language-http">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
</code></pre>
</li>
<li>
<p>内容编码：主要指压缩算法</p>
<pre><code class="language-http">Accept-Encoding: gzip, deflate, br
</code></pre>
</li>
<li>
<p>表述语言</p>
<pre><code class="language-http">Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7
</code></pre>
</li>
<li>
<p>字符编码：由于 UTF-8 格式广为使用， <code>Accept-Charset</code> 已被废弃</p>
</li>
</ul>
<p><strong>资源表述的元数据头部：</strong>（响应）</p>
<ul>
<li>
<p>媒体类型、编码</p>
<pre><code class="language-http">content-type: text/html; charset=utf-8
</code></pre>
</li>
<li>
<p>内容编码</p>
<pre><code class="language-http">content-encoding: gzip
</code></pre>
</li>
<li>
<p>语言</p>
<pre><code class="language-http">Content-Language: de-DE, en-CA
</code></pre>
</li>
</ul>
<h1>包体传输</h1>
<p>HTTP 有两种包体传输方式：定长传输和分块传输</p>
<h2>定长传输</h2>
<p>发送 HTTP 消息时已能够确定包体的全部长度，使用 <code>Content-Length</code> 明确指明包体长度</p>
<ul>
<li>
<p>使用 10 进制，而不是 16 进制，表示包体中的字节数</p>
</li>
<li>
<p>必须与实际传输的包体长度一致</p>
</li>
<li>
<p>接收端处理简单</p>
</li>
</ul>
<pre><code class="language-http">Content-Length = 1*DIGIT
</code></pre>
<p>当 <code>Content-Length</code> 指定的字节数小于包体中的数据长度，则浏览器会进行截断处理</p>
<pre><code class="language-typescript">import { createServer } from &#x27;http&#x27;

const server = createServer((_, res) =&gt; {
  res.setHeader(&#x27;content-length&#x27;, 10)
  res.write(&#x27;hello world&#x27;)
})

server.listen(12306)
</code></pre>
<p>当 <code>Content-Length</code> 指定的字节数大于包体中的数据长度，页面会加载失败</p>
<h2>分块传输</h2>
<p>发送 HTTP 消息时不能确定包体的全部长度，使用 <code>Transfer-Encoding: chunked</code> 指明使用 Chunk 传输方式</p>
<ul>
<li>含 <code>Transfer-Encoding</code> 头部后 <code>Content-Length</code> 头部应被忽略</li>
<li>分块传输则 body 由一些分开发送的  chunked-body  组成</li>
</ul>
<p><img src="https://oss.xiefeng.tech/images/20210921152832.png" alt=""/></p>
<ul>
<li>每一个 chunk 都是一段数据，由 chunk 大小和数据组成</li>
<li>last-chunk 指的是最后一个 chunk，其中没有数据代表的是 chunk 边界，由多个 0 组成，一般发送一个 0 即可</li>
<li>trailer-part 是 chunk 传递完之后要传递的 HTTP 头部<!-- -->
<ul>
<li>可没有该部分，如果有的话首先需要在 <code>Trailer</code> 头部声明</li>
<li>该部分可能传递的值：分包传递的这个文件的 MD5 值</li>
</ul>
</li>
</ul>
<pre><code class="language-typescript">import { createServer } from &#x27;net&#x27;

const server = createServer((socket) =&gt; {
  socket.on(&#x27;data&#x27;, () =&gt; {
    // 头部
    socket.write(&#x27;HTTP/1.1 200 OK\r\n&#x27;)
    socket.write(&#x27;Transfer-Encoding: chunked\r\n&#x27;)
    socket.write(&#x27;\r\n&#x27;)
    // 第一个 chunk
    socket.write(&#x27;5\r\n&#x27;)
    socket.write(&#x27;hello\r\n&#x27;)
    // 第二个 chunk
    socket.write(&#x27;6\r\n&#x27;)
    socket.write(&#x27; world\r\n&#x27;)
    // last chunk
    socket.write(&#x27;0\r\n&#x27;)
    socket.write(&#x27;\r\n&#x27;)
  })
})
server.listen(12306)
</code></pre>
<p><img src="https://oss.xiefeng.tech/images/20210921152737.png" alt=""/></p>
<p>如果在 chunk 传递完之后需要传递一些头部，则一开始就需要在 <code>Trailer</code> 字段中声明后续 trailer-part 部分要传递的头部字段名</p>
<pre><code class="language-typescript">socket.write(&#x27;HTTP/1.1 200 OK\r\n&#x27;)
socket.write(&#x27;Trailer: Date\r\n&#x27;)
socket.write(&#x27;Transfer-Encoding: chunked\r\n&#x27;)
socket.write(&#x27;\r\n&#x27;)

socket.write(&#x27;5\r\n&#x27;)
socket.write(&#x27;hello\r\n&#x27;)

socket.write(&#x27;0\r\n&#x27;)

socket.write(`Date: ${new Date()}\r\n`)

socket.write(&#x27;\r\n&#x27;)
</code></pre>
<p>但是客户端需要在请求中添加 <code>TE: trailers</code> 表明客户端支持处理 <code>Trailer</code> 头部</p>
<p>有些头部不允许在 <code>Trailer</code> 头部中传输：</p>
<ul>
<li>用于信息分帧的首部 (例如 <code>Transfer-Encoding</code> 和 <code>Content-Length</code>)</li>
<li>用于路由用途的首部 (例如 <code>Host</code>)</li>
<li>请求修饰首部 (例如控制类和条件类的，如 <code>Cache-Control</code>，Max-Forwards，或者 <code>TE</code>)</li>
<li>身份验证首部 (例如 <code>Authorization</code> 或者 <code>Set-Cookie</code>)</li>
<li><code>Content-Encoding</code>、<code>Content-Type</code>、 <code>Content-Range</code>，以及 <code>Trailer</code> 自身</li>
</ul>
<p><a href="https://imququ.com/post/transfer-encoding-header-in-http.html">https://imququ.com/post/transfer-encoding-header-in-http.html</a></p>
<p><code>Content-Disposition</code> 头部：</p>
<ul>
<li>
<p><code>inline</code>：指定包体是以 <code>inline</code> 内联的方式，作为页面的一部分展示</p>
</li>
<li>
<p><code>attachment</code>：指定浏览器将包体以附件的方式下载</p>
<p>例如：<code>Content-Disposition: attachment; filename=“filename.jpg”</code></p>
</li>
<li>
<p>在 multipart/form-data 类型应答中，可以用于子消息体部分</p>
<p>例如：<code>Content-Disposition: form-data; name=&quot;fieldName&quot;; filename=&quot;filename.jpg&quot;</code></p>
</li>
</ul>
<h1>表单提交</h1>
<p>POST 方式下对表单内容在请求包体中的编码方式有两种，并通过 <code>enctype</code> 属性控制</p>
<ol>
<li>
<p><code>application/x-www-form-urlencoded</code></p>
<p>数据被编码成以 ‘&amp;’ 分隔的键值对, 同时以 ‘=’ 分隔键和值，字符以 URL 编码方式编码</p>
</li>
<li>
<p><code>multipart/form-data</code></p>
<p>在这种方式下，每个 input 的内容都是一个资源表述，前一种方式所有的 input 内容是一个资源表述</p>
<p>格式特点：1. boundary 分隔符   2. 每部分表述皆有HTTP头部描述子包体，例如 Content-Type   3. last boundary 结尾</p>
<p><code>Content-type: multipart/form-data</code></p>
</li>
</ol>
<p><img src="http://oss.xiefeng.tech/img/20210403083002.png" alt=""/></p>
<h1>Range请求</h1>
<p>HTTP 允许服务器基于客户端的请求只发送响应包体的一部分，而客户端自动将多个片断的包体组合成完整的体积更大的包体</p>
<ul>
<li>支持断点续传</li>
<li>支持多线程下载</li>
<li>支持视频播放器实时拖动</li>
</ul>
<p>服务器通过 <code>Accept-Range</code> 头部表示是否支持 Range 请求：</p>
<ul>
<li><code>Accept-Ranges: bytes</code> 表示支持</li>
<li><code>Accept-Ranges: none</code> 表示不支持</li>
</ul>
<h2>请求范围</h2>
<p>客户端使用 <code>Range</code> 头部传递请求范围：</p>
<ul>
<li><code>Range: bytes=0-499</code>：前 500 字节</li>
<li><code>Range: bytes=500-600,601-999</code>：多个范围</li>
<li><code>Range: bytes=-500</code>：最后 500 字节</li>
<li><code>Range: bytes = 9500-</code>：从当前到结尾</li>
</ul>
<h2>服务器响应</h2>
<p>响应首部 <code>Content-Range</code> 显示的是一个数据片段在整个文件中的位置</p>
<pre><code class="language-http">Content-Range: &lt;unit&gt; &lt;range-start&gt;-&lt;range-end&gt;/&lt;size&gt;
Content-Range: &lt;unit&gt; &lt;range-start&gt;-&lt;range-end&gt;/*
Content-Range: &lt;unit&gt; */&lt;size&gt;
</code></pre>
<ul>
<li><code>unit</code>：数据区间所采用的单位，通常是 byte</li>
<li><code>range-start</code>：表示在给定单位下区间的起始值</li>
<li><code>range-end</code>：表示在给定单位下，区间的结束值</li>
<li><code>size</code>：整个文件的大小，如果大小未知则用 <code>*</code> 表示</li>
</ul>
<h3>单一范围</h3>
<ol>
<li>服务器支持 range 请求并且请求范围正确，服务器返回 <code>206 Partial Content</code> + <code>Content-Range</code></li>
</ol>
<p><img src="https://oss.xiefeng.tech/images/20210922113300.png" alt=""/></p>
<ol start="2">
<li>请求范围不满足实际资源的大小，服务器返回 <code>416 Range Not Satisfiable</code>  +  <code>Content-Range: bytes */1234</code></li>
</ol>
<p><img src="https://oss.xiefeng.tech/images/20210922113443.png" alt=""/></p>
<ol start="3">
<li>服务器不支持 <code>Range</code> 请求时，服务器以 200 返回完整的响应包体</li>
</ol>
<h3>多重范围</h3>
<p>当客户端请求多个范围时：</p>
<pre><code class="language-shell">curl https://xiefeng.tech -i -H &quot;Range: bytes=0-50, 100-150&quot;
</code></pre>
<ol>
<li>服务器返回 206 Partial Content 状态码</li>
<li>具有头部：<code>Content-Type：multipart/byteranges; boundary=xxxxxxxx</code></li>
<li><code>Content-Type：multipart/byteranges</code> 表示这个响应有多个 byterange，并且它们之间使用 boundary 分隔</li>
<li>每一部分 byterange 都有他自己的 <code>Centen-type</code> 头部和 <code>Content-Range</code></li>
</ol>
<p><img src="https://oss.xiefeng.tech/images/20210922113006.png" alt=""/></p>
<h2>条件Range</h2>
<p>如果客户端已经得到了 Range 响应的一部分，并想在这部分响应未过期的情况下，获取其他部分的响应</p>
<p>则需要将 Range 和 If-Unmodified-Since 或者 If-Match 头部共同使用</p>
<p>可以使用 <code>If-Range = entity-tag / HTTP-date</code>，其值可以为 Etag 或者 Last-Modified</p>
<pre><code class="language-http">GET /index.html HTTP/1.1
If-Range: &quot;123456&quot;
Range: bytes=5001-10000
</code></pre>
<p>它告知服务器若该字段的值（<code>ETage</code> 值 / 时间）和请求资源的 <code>ETage</code> 值 / 时间一致时，则作为范围请求处理，否则返回全体资源</p>
<h1>Cookie</h1>
<p>Cookie 是保存在客户端、由浏览器维护、表示应用状态的 HTTP 头部</p>
<p>服务器通过响应中添加 <code>Set-Cookie</code> 来种 Cookie，客户端通过 <code>Cookie</code> 字段携带本地存储的 Cookie</p>
<p><code>Set-Cookie</code> 头部一次只能传递 1 个 name/value 名值对，但是响应中可以含多个 <code>Set-Cookie</code> 头部</p>
<p><strong>Cookie 字段</strong></p>
<ul>
<li><code>Name=value</code>：Cookie 的名和值</li>
<li><code>expires</code>：设置 cookie 的过期时间，如果没有设置则当前会话结束就过期</li>
<li><code>max-age</code>：cookie 经过多少秒后失效，<code>max-age</code> 优先级高于 <code>expires</code> 且不能为0，http1.1 出现</li>
<li><code>path</code>：可以访问此 cookie 的页面路径，子路径也能访问</li>
<li><code>domain</code>：可以访问此 cookie 的域名<!-- -->
<ul>
<li>顶级域名只能设置 domain 为顶级域名</li>
<li>二级域名能读取设置了 domain 为顶级域名或者自身的 cookie</li>
<li>将设置 domain 为顶级域名， cookie 可以在多个二级域名中共享</li>
</ul>
</li>
<li><code>Secure</code>：只有使用 TLS/SSL 协议（https）时才能使用该 cookie</li>
<li><code>HttpOnly</code>：不能通过 JavaScript 访问到该 cookie</li>
<li><code>SameSite</code>： 允许服务器要求某个 cookie 在跨站请求时不会被发送，用于阻止 CSRF 攻击<!-- -->
<ul>
<li>None：浏览器会在同站请求、跨站请求下继续发送 cookies</li>
<li>Strict：浏览器将只在访问相同站点时发送 cookie</li>
<li>Lax：与 Strict 类似，但用e户从外部站点导航至URL时（例如通过链接）除外</li>
</ul>
</li>
</ul>
<p><strong>第三方Cookie</strong></p>
<p>浏览器允许对于其他域下的资源（如广告图片）响应中的 <code>Set-Cookie</code> 保存，并在后续访问该域时自动使用 Cookie</p>
<h1>条件请求</h1>
<ul>
<li>
<p><code>If-Match</code></p>
<ul>
<li>服务器会比对该字段值和资源的 <code>ETage</code> 值是否一致</li>
<li>一致则会执行请求</li>
<li>不一致则返回 412</li>
</ul>
</li>
<li>
<p><code>If-Modified-Since</code></p>
<ul>
<li>如果在该字段的日期之后资源没有更新，服务器返回 304</li>
<li>否则返回 200 + <code>Last-Modified</code></li>
</ul>
</li>
<li>
<p><code>If-None-Match</code></p>
<ul>
<li>和 <code>If-Match</code> 相反，当和 <code>ETag</code> 值不一致时处理请求</li>
</ul>
</li>
<li>
<p><code>If-Unmodified-Since</code></p>
<ul>
<li>和 <code>If-Unmodified-Since</code> 相反，如果发生了更新返回 412，没更新处理请求</li>
</ul>
</li>
<li>
<p><code>If-Range</code></p>
<ul>
<li>它告知服务器若该字段的值和请求资源的 <code>ETage</code> 值 / 时间一致时，则作为范围请求处理，否则返回全体资源</li>
</ul>
</li>
</ul>
<p>ETag：资源的实体标识，服务器会为每一份资源分配对应的 <code>ETag</code> 值，资源更新时，<code>ETag</code> 也需要更新</p>
<ul>
<li>
<p>强 <code>ETag</code>：不论实体发生多么细微的变化该值都会变化，如：<code>ETag: &quot;usagi-1234&quot;</code></p>
</li>
<li>
<p>弱 <code>ETag</code>：只有资源发生了根本的改变，才会改变该值，会在字段开始添加 <code>W/</code> 如： <code>ETag: W/&quot;usagi-1234&quot;</code></p>
</li>
</ul>
<h1>请求上下文</h1>
<ul>
<li>
<p><code>User-Agent</code> 头部：指明客户端的类型信息，服务器可以据此对资源的表述做抉择</p>
<pre><code class="language-http">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36(KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36
</code></pre>
</li>
<li>
<p><code>Referer</code> 头部：浏览器对来自某一页面的请求自动添加的头部</p>
<ul>
<li><code>Referer</code> 不会被添加的场景<!-- -->
<ul>
<li>来源页面采用的协议为表示本地文件的 &quot;<code>file</code>&quot; 或者 &quot;<code>data</code>&quot; URI</li>
<li>当前请求页面采用的是 <code>http</code> 协议，而来源页面采用的是 <code>https</code> 协议</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>From</code> 头部：主要用于网络爬虫，告诉服务器如何通过邮件联系到爬虫的负责人</p>
</li>
<li>
<p><code>Server</code> 头部：指明服务器上所用软件的信息，用于帮助客户端定位问题或者统计数据</p>
</li>
<li>
<p><code>Allow</code> 头部：告诉客户端，服务器上该 URI 对应的资源允许哪些方法的执行</p>
</li>
</ul>
<h1>缓存控制</h1>
<ul>
<li>
<p><code>Cache-Control</code></p>
<ul>
<li>
<p><strong>请求</strong></p>
<ul>
<li>
<p><code>no-cache</code></p>
<p>告诉服务器，不能直接使用已有缓存作为响应返回，除非带着缓存条件到上游服务端得到 304 验证返回码才可使用现有缓存</p>
</li>
<li>
<p><code>no-store</code></p>
<p>告诉各代理服务器不要对该请求的响应缓存（实际有不少不遵守该规定的代理服务器）</p>
</li>
<li>
<p><code>max-age</code></p>
<p>告诉服务器，客户端不会接受时间超出 <code>max-age</code> 的缓存</p>
</li>
<li>
<p><code>min-fresh</code></p>
<p>要求服务器返回至少还未超过指定时间的缓存资源（在指定时间内没有过期的缓存可以返回）</p>
<p>告诉服务器，<code>Age</code> 至少经过 <code>min-fresh</code> 秒后缓存才可使用</p>
</li>
<li>
<p><code>max-stale</code></p>
<p>接收缓存即使过期，没指定数值怎样都会接收缓存；如果指定数值，即使过期，只要没有超过指定的时间都可以接收</p>
</li>
<li>
<p><code>no-transform</code></p>
<p>告诉代理服务器不要修改消息包体的内容</p>
</li>
<li>
<p><code>only-if-cached</code></p>
<p>告诉服务器仅能返回缓存的响应，若没有缓存则返回 504 错误码</p>
</li>
</ul>
</li>
<li>
<p><strong>响应</strong></p>
<ul>
<li>
<p><code>public</code>、<code>private</code></p>
<p><code>public</code>：表示无论私有缓存或者共享缓存，皆可将该响应缓存</p>
<p><code>private</code>：表示该响应不能被代理服务器作为共享缓存使用。若 <code>private</code> 后指定头部，则在告诉代理服务器不能缓存指定的头部，但可缓存其他部分</p>
</li>
<li>
<p><code>no-cache</code></p>
<p>告诉客户端不能直接使用缓存的响应，使用前必须在源服务器验证得到 304 返回码。如果 <code>no-cache</code> 后指定头部，则若客户端的后续请求及响应中不含有这些头则可直接使用缓存</p>
</li>
<li>
<p><code>no-store</code></p>
<p>告诉所有下游节点不能对响应进行缓存</p>
</li>
<li>
<p><code>max-age</code></p>
<p>告诉客户端缓存时间超出 <code>max-age</code> 秒后则缓存过期</p>
</li>
<li>
<p><code>s-maxage</code></p>
<p>与 <code>max-age</code> 相似，但仅针对共享缓存，且优先级高于 <code>max-age</code> 和 <code>Expires</code>，告诉缓存最多缓存多久</p>
</li>
<li>
<p><code>no-transform</code></p>
<p>告诉代理服务器不能修改消息包体的内容</p>
</li>
<li>
<p><code>must-revalidate</code></p>
<p>告诉<strong>客户端</strong>一旦缓存过期，必须向服务器验证后才可使用</p>
</li>
<li>
<p><code>proxy-revalidate</code></p>
<p>与 <code>must-revalidate</code> 类似，但它仅对<strong>代理服务器</strong>的共享缓存有效</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>Age</code></p>
<p>表示自源服务器发出响应（或者验证过期缓存），到使用缓存的响应发出时经过的秒数</p>
</li>
<li>
<p><code>Pragma</code></p>
<p>是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义</p>
<pre><code class="language-http">Cache-Control: no-cache
Pragma: no-cache
</code></pre>
</li>
<li>
<p><code>Vary</code></p>
<p>服务器告诉缓存服务器/客户端，只有请求持有和 该头部指定的值相同且头部的相同 才可以响应缓存</p>
<pre><code class="language-http">// 浏览器 -&gt; 代理
GET /sample.html
Accept-Language: en-us

// 代理 -&gt; 源服务器
GET /sample.html
Accept-Language: en-us

// 源 -&gt; 代理
Vary: Accept-Language
</code></pre>
</li>
<li>
<p><code>Expires</code></p>
<p>资源失效的日期</p>
</li>
<li>
<p><code>Warning</code></p>
<p>HTTP/1.1 的 warning 首部是从 HTTP/1.0 的响应头部（Retry-After）演变过来的，通常会告知用户一些和缓存相关的问题的警告</p>
<pre><code class="language-http">Warning: [警告码] [警告的主机:端口号] &quot;[警告内容]&quot;([日期时间])
</code></pre>
</li>
</ul>
<h1>消息的转发</h1>
<ul>
<li>
<p><code>Via</code></p>
<p>使用该字段用于追踪客户端和服务器之间的请求和响应报文的传输路径，报文经过代理或网关时，会现在首部字段 <code>Via</code> 中附加该服务器的信息，然后再进行转发。</p>
<p><code>Via</code> 首部是为了追踪传输路径，所以经常和 <code>TRACE</code> 方法一起使用。代理服务器接收到请求并且 <code>Max-Forward: 0</code>，服务器则会加上自身的信息后返回响应</p>
</li>
<li>
<p><code>Max-Forwards</code></p>
<p>限制 Proxy 代理服务器的最大转发次数，仅对 <code>TRACE</code> / <code>OPTIONS</code> 方法有效</p>
</li>
<li>
<p>传递 IP 地址</p>
<ul>
<li><code>X-Forwarded-For</code> 传递代理服务器的地址</li>
<li><code>X-Real-IP</code>  传递真正请求的地址</li>
</ul>
<pre><code class="language-http">X-Forwarded-For: 115.204.33.1, 1.1.1.1
X-Real-IP: 115.204.33.1
</code></pre>
</li>
</ul>
<h1>重定向</h1>
<p><code>Location</code> 可以将响应接收方引导至某个与请求URI位置不同的资源，和 3xx 配合，提供重定向的 URI</p>
<p>流程：当浏览器接收到重定向响应码时，需要读取响应头部 Location 头部的值，获取到新的 URI 再跳转访问该页面</p>
<ol>
<li>永久重定向，表示资源永久性变更到新的 URI<!-- -->
<ul>
<li>301（HTTP/1.0）：重定向请求通常（一些浏览器会把 POST 改为GET）会使用 GET 方法，而不管原请求究竟采用的是什么方法</li>
<li>308（HTTP/1.1）：重定向请求必须使用原请求的方法和包体发起访问</li>
</ul>
</li>
<li>临时重定向，表示资源只是临时的变更 URI<!-- -->
<ul>
<li>302 （HTTP/1.0）：重定向请求通常会使用 GET 方法，而不管原请求究竟采用的是什么方法</li>
<li>303 （HTTP/1.1）：它并不表示资源变迁，而是用新 URI 的响应表述而为原请求服务，重定向请求会使用 GET 方法<!-- -->
<ul>
<li>例如表单提交后向用户返回新内容（亦可防止重复提交）</li>
</ul>
</li>
<li>307 （HTTP/1.1）：重定向请求必须使用原请求的方法和包体发起访问</li>
</ul>
</li>
<li>特殊重定向<!-- -->
<ul>
<li>300：响应式内容协商中，告知客户端有多种资源表述，要求客户端选择一种自认为合适的表述</li>
<li>304：服务器端验证过期缓存有效后，要求客户端使用该缓存</li>
</ul>
</li>
</ol>
<h1>Upgrade</h1>
<p>用于检测 HTTP 协议及其它协议是否可以使用更高的版本进行通信，其参数可以用来指定一个完全不同的通信协议，对于 <code>Upgrade</code> 请求，服务器可返回 101</p>
<pre><code class="language-http">GET /index.html HTTP/1.1
Upgrade: TLS/1.0
Connection: Upgrade
</code></pre>
<pre><code class="language-http">HTTP/1.1 101 Switching Protocols
Upgrade: TLS/1.0, HTTP/1.1
Connection: Upgrade
</code></pre><div><a href="/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"HTTP1","article":{"title":"HTTP1","content":"# 请求方法\r\n\r\n- `GET`：主要的获取信息方法，幂等方法\r\n\r\n- `POST`：常用于提交 form 表单，新增资源等\r\n\r\n- `HEAD`：类似于 GET 方法，但是服务器不返回 body，用于确认 URI 的有效性及资源更新的日期时间等，幂等方法\r\n\r\n- `PUT`：传输文件，更新资源\r\n\r\n- `DELETE`：删除文件\r\n\r\n- `CONNECT`：要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP，主要使用 SSL 和 TLS 加密内容\r\n\r\n- `OPTIONS`：查询服务器对访问资源支持的方法\r\n\r\n- `TRACE`：路径追踪，回显服务器收到的请求，用于定位问题\r\n\r\n发送请求时在 `Max-Forwards` 首部填入字段，每经过一个服务器就会该字段值就会 -1，为 0 时停止传输，最后接收到的服务器返回 200\r\n\r\n客户端可以通过 TRACE 查询发出去的请求是如何经过一系列代理中转的。\r\n\r\n但是该方法容易引发 XST(Cross-Site Tracing) 攻击\r\n\r\n# WEBDAV\r\n\r\nWebDAV是一组基于超文本传输协议的技术集合，有利于用户间协同编辑和管理存储在万维网服务器文档。\r\n\r\nWebDAV 在标准的HTTP协议上扩展了特有的请求方式。 然后用这些请求，操作web服务器上的磁盘。\r\n\r\n- `PROPFIND`：从 Web 资源中检索以 XML 格式存储的属性，也被重载以允许一个检索远程系统的集合结构（目录层次结构）\r\n- `PROPPATCH`：在单个原子性动作中更改和删除资源的多个属性\r\n- `MKCOL`：创建集合或目录\r\n- `COPY`：将资源从一个URI复制到另一个URI\r\n- `MOVE`：将资源从一个URI移动到另一个URI\r\n- `LOCK`：锁定一个资源\r\n- `UNLOCK`：解除资源的锁定\r\n\r\n# 状态码\r\n\r\n客户端如果遇到了无法识别的状态码，会当作该系列的第一个状态码处理，比如 555 会当作 500 来处理\r\n\r\n## 100\r\n\r\n请求已接收到，需要进一步处理才能完成，HTTP 1.0 不支持\r\n\r\n- 100 Continue\r\n  - 上传大文件前使用\r\n  - 由客户端发起请求中携带 `Expect: 100-continue` 头部触发\r\n- 101 Switch Protocols\r\n  - 协议升级使用\r\n  - 由客户端发起请求中携带 `Upgrade` 头部触发，如升级 websocket 或者 http/2.0\r\n  - 返回该响应码表示服务器同意升级\r\n- 102 Processing\r\n\t- WebDAV 请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求\r\n\t- 该代码表示服务器已经收到并正在处理请求，但无响应可用\r\n\t- 这样可以防止客户端超时，并假设请求丢失\r\n\r\n## 200\r\n\r\n成功处理请求\r\n\r\n- 200 OK：请求成功\r\n\r\n- 201 Created：有新资源在服务器端被成功创建\r\n\r\n- 202 Accepted\r\n\r\n  - 服务器接收并开始处理请求，但请求未处理完成\r\n  - 这样一个模糊的概念是有意如此设计，可以覆盖更多的场景。例如异步、需要长时间处理的任务\r\n\r\n- 203 Non-Authoritative Information\r\n\r\n\t当代理服务器修改了 origin server 的原始响应包体时（例如更换了HTML中的元素值），代理服务器可以通过修改`200` 为 `203` 的方式告知客户端这一事实，方便客户端为这一行为作出相应的处理。`203` 响应可以被缓存。但是代理服务器一般不会这样做，直接返回 `200`\r\n\r\n- 204 No Content：成功执行了请求且不携带响应包体，并暗示客户端无需更新当前的页面视图。\r\n\r\n- 205 Reset Content：成功执行了请求且不携带响应包体，同时指明客户端需要更新当前页面视图。\r\n\r\n- 206 Partial Content：使用 range 协议时返回部分响应内容时的响应码\r\n\r\n- 207 Multi-Status\r\n\r\n  - RFC4918\r\n  - 在 WEBDAV 协议中以 XML 返回多个资源的状态\r\n  - 每个资源也有自己的状态码，比如 200\r\n\r\n- 208 Already Reported\r\n\r\n\t- RFC5842 \r\n\t- 为避免相同集合下资源在207响应码下重复上报，使用 `208` 可以使用父集合的响应码。\r\n\r\n## 300\r\n\r\n重定向使用 Location 指向的资源或者缓存中的资源。在 RFC2068中规定客户端重定向次数不应超过 5 次，以防止死循环。\r\n\r\n- 300 Multiple Choices\r\n\r\n  - 资源有多种表述，通过 300 返回给客户端后由其自行选择访问哪一种表述\r\n  - 由于缺乏明确的细节，300 很少使用\r\n\r\n- 301 Moved Permanently\r\n\r\n  - 资源永久性的重定向到另一个 URI 中\r\n  - 浏览器强制使用GET\r\n\r\n- 302 Found\r\n\r\n  - 资源临时的重定向到另一个 URI 中\r\n  - 浏览器强制使用GET\r\n\r\n- 303 See Other\r\n\r\n\t重定向到其他URI，客户端并且应该使用GET\r\n\r\n- 304 Not Modified\r\n\r\n  - 当客户端拥有可能过期的缓存时，会携带缓存的标识 `etag`、时间等信息询问服务器缓存是否仍可复用\r\n  - 304是告诉客户端可以复用缓存\r\n\r\n- 307 Temporary Redirect\r\n\r\n  - 类似 302\r\n  - 但明确重定向后请求方法必须与原请求方法相同，不得改变\r\n\r\n- 308 Permanent Redirect\r\n\r\n\t- 类似301\r\n\t- 但明确重定向后请求方法必须与原请求方法相同，不得改变\r\n\r\n## 400\r\n\r\n客户端出现错误\r\n\r\n- 400 Bad Request\r\n\r\n  - 服务器认为客户端出现了错误，但不能明确判断为以下哪种错误时使用此错误码\r\n  - 例如HTTP请求格式错误。浏览器会像对待200一样对待400\r\n\r\n- 401 Unauthorized\r\n\r\n  - 表示发送的请求需要有通过HTTP认证\r\n  - 如果之前已经认证过一次，则表示认证失败\r\n\r\n- 407 Proxy Authentication Required\r\n\r\n\t对需要经由代理的请求，认证信息未通过代理服务器的验证\r\n\r\n- 403 Forbidden\r\n\r\n\t服务器理解请求的含义，但没有权限执行此请求 / 请求被拒绝\r\n\r\n- 404 Not Found\r\n\r\n\t服务器没有找到对应的资源\r\n\r\n- 410 Gone\r\n\r\n\t服务器没有找到对应的资源，且明确的知道该位置永久性找不到该资源\r\n\r\n- 405 Method Not Allowed\r\n\r\n\t服务器不支持请求行中的 method 方法\r\n\r\n- 406 Not Acceptable\r\n\r\n\t对客户端指定的资源表述不存在（例如对语言或者编码有要求），服务器返回表述列表供客户端选择。\r\n\r\n- 408 Request Timeout\r\n\r\n\t服务器接收请求超时\r\n\r\n- 409 Conflict\r\n\r\n\t资源冲突，例如上传文件时目标位置已经存在版本更新的资源\r\n\r\n- 411 Length Required\r\n\r\n\t如果请求含有包体且未携带 `Content-Length` 头部，且不属于chunk 类请求时，返回 411\r\n\r\n- 412 Precondition Failed\r\n\r\n\t复用缓存时传递的 `If-Unmodified-Since` 或 `If-None-Match` 头部不被满足\r\n\r\n- 413 Payload Too Large/Request Entity Too Large\r\n\r\n\t请求的包体超出服务器能处理的最大长度\r\n\r\n- 414 URI Too Long\r\n\r\n\t请求的 URI 超出服务器能接受的最大长度\r\n\r\n- 415 Unsupported Media Type\r\n\r\n\t上传的文件类型不被服务器支持\r\n\r\n- 416 Range Not Satisfiable\r\n\r\n\t无法提供 Range 请求中指定的那段包体\r\n\r\n- 417 Expectation Failed\r\n\r\n\t对于 `Expect` 请求头部期待的情况无法满足时的响应码\r\n\r\n- 421 Misdirected Request\r\n\r\n\t服务器认为这个请求不该发给它，因为它没有能力处理。\r\n\r\n- 426 Upgrade Required\r\n\r\n\t服务器拒绝基于当前 HTTP 协议提供服务，通过 `Upgrade` 头部告知客户端必须升级协议才能继续处理。\r\n\r\n- 428 Precondition Required\r\n\r\n\t用户请求中缺失了条件类头部，例如 `If-Match`\r\n\r\n- 429 Too Many Requests\r\n\r\n\t客户端发送请求的速率过快，一般服务器不会返回该状态码，而是返回 503\r\n\r\n- 431 Request Header Fields Too Large\r\n\r\n\t请求的 HEADER 头部大小超过限制\r\n\r\n- 451 Unavailable For Legal Reasons\r\n\r\n\tRFC7725 ，由于法律原因资源不可访问\r\n\r\n## 500\r\n\r\n服务器端出现错误\r\n\r\n- 500 Internal Server Error\r\n\r\n\t服务器内部错误，且不属于以下错误类型\r\n\r\n- 501 Not Implemented\r\n\r\n\t服务器不支持实现请求所需要的功能\r\n\r\n- 502 Bad Gateway\r\n\r\n\t代理服务器无法获取到合法响应\r\n\r\n- 503 Service Unavailable\r\n\r\n\t服务器资源尚未准备好处理当前请求\r\n\r\n- 504 Gateway Timeout\r\n\r\n\t代理服务器无法及时的从上游获得响应\r\n\r\n- 505 HTTP Version Not Supported\r\n\r\n\t请求使用的 HTTP 协议版本不支持\r\n\r\n- 507 Insufficient Storage\r\n\r\n\t服务器没有足够的空间处理请求，为了安全一般不会返回\r\n\r\n- 508 Loop Detected\r\n\r\n\t访问资源时检测到循环\r\n\r\n- 511 Network Authentication Required\r\n\r\n\t代理服务器发现客户端需要进行身份验证才能获得网络访问权限\r\n\r\n# URI\r\n\r\n- URL：Uniform Resource Locator，统一资源定位符，表示资源的位置\r\n- URN：Uniform Resource Name\r\n\t- 期望为资源提供持久的、位置无关的标识方式\r\n\t- 例如磁力链接 `magnet:?xt=urn:sha1:YNCKHTQC5`\r\n- URI：Uniform Resource Identifier\r\n\t- 统一资源标识符，用以区分资源\r\n\t- 是 URL 和 URN 的超集，用以取代 URL 和 URN 概念\r\n\r\n## 组成\r\n\r\n组成：schema, user information, host, port, path, query, fragme\r\n\r\n![](http://oss.xiefeng.tech/img/20210801102030.png)\r\n\r\n合法的 URI：\r\n\r\n- `ftp://ftp.is.co.za/rfc/rfc1808.txt`\r\n- `http://www.ietf.org/rfc/rfc2396.txt`\r\n\r\n## 编码\r\n\r\nURL 编码就是是把 URI 中不安全的字符转化为安全字符的过程，对于 URL 中的合法字符，编码和不编码是等价的\r\n\r\nRFC3986 文档规定，URL 中只允许包含英文字母、数字、- _ . ~ 4个特殊字符以及所有保留字符\r\n\r\nRFC3986 中指定了以下字符为保留字符：! * ' ( ) ; : @ \u0026 = + $ , / ? # [ ]\r\n\r\n**保留字符**\r\n\r\nURL 可以划分成若干个组件，协议、主机、路径等，当组件中的**普通数据**包含这些特殊字符时，需要对其进行编码\r\n\r\n1. 一些字符（:/?#[]@）是用作分隔不同组件的\r\n\r\n   例如：`:` 用于分隔协议和主机，`/` 用于分隔主机和路径，`?` 用于分隔路径和查询参数等\r\n\r\n2. 一些字符（!$\u0026'()*+,;=）用于在每个组件中起到分隔作用的\r\n\r\n   例如：`=` 用于表示查询参数中的键值对，`\u0026` 用于分隔查询多个键值对\r\n\r\n**不安全字符**\r\n\r\n有一些字符，当他们直接放在 URL 中的时候，可能会引起解析程序的歧义，这些字符被视为不安全字符，原因有很多。\r\n\r\n- 空格：URL 在传输的过程，或者文本处理程序在处理 URL 时，都有可能引入无关紧要的空格，或者去掉了那些有意义的空格\r\n- 引号和\u003c\u003e：引号和尖括号通常用于在普通文本中起到分隔 URL 的作用\r\n- %：百分号本身用作对不安全字符进行编码时使用的特殊字符，因此本身需要编码\r\n- ......\r\n\r\n**编码方式**\r\n\r\nURL 编码采用 **百分号编码**\r\n\r\nURL 编码默认使用的字符集是 US-ASCII\r\n\r\n百分号编码就是将字符采用 ASCII 编码的十六进制表示，再加上一个 `%`\r\n\r\n对于非 ASCII 字符，需要使用 ASCII 字符集的超集进行编码得到相应的字节，然后对每个字节执行百分号编码\r\n\r\n例如：`#` 在 ASCII 编码中对应的十六进制表示为 `23`，则 `#` 的百分号编码为 `%23`\r\n\r\n# 长连接\r\n\r\n早期 HTTP/1.0 性能上有一个很大的问题：每发起一个请求，都要新建一次 TCP 连接，而且是**串行**请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。 \r\n\r\nHTTP/1.1 提出了长连接的通信方式，即只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。\r\n\r\nHTTP/1.1 默认是长连接，当想要断开连接时只需要指定 `Connection: close`\r\n\r\nHTTP/1.1 之前的版本默认短连接，如果想在旧版本也使用就需要指定 `Connection: Keep-alive`，服务器会返回 `Connection: keep-alive` 和 `Keep-alive: xxxx` 首部\r\n\r\n对于陈旧的代理服务器（不认识 `Connection` 头部）需要使用 `Proxy-Connect` 头部来替代，当浏览器检测到**正向代理**时，就会这么做\r\n\r\n![](http://oss.xiefeng.tech/img/20210402092543.jpg)\r\n\r\n# 内容协商\r\n\r\n- Proactive 主动式内容协商：客户端先在请求头部中提出需要的表述形式，服务器根据这些请求头部提供特定的表述\r\n\r\n- Reactive 响应式内容协商：服务器返回 300 或者 406，由客户端选择一种表述 URI 使用\r\n\r\n**常见的协商要素：**（请求）\r\n\r\n- 质量因子 q：内容的质量、可接受类型的优先级，和内容通过 `;` 分隔，默认为 1\r\n\r\n  ```http\r\n  Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\r\n  ```\r\n\r\n- MIME 类型\r\n\r\n  ```http\r\n  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n  ```\r\n\r\n- 内容编码：主要指压缩算法\r\n\r\n  ```http\r\n  Accept-Encoding: gzip, deflate, br\r\n  ```\r\n\r\n- 表述语言\r\n\r\n  ```http\r\n  Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7\r\n  ```\r\n\r\n- 字符编码：由于 UTF-8 格式广为使用， `Accept-Charset` 已被废弃\r\n\r\n**资源表述的元数据头部：**（响应）\r\n\r\n- 媒体类型、编码\r\n\r\n  ```http\r\n  content-type: text/html; charset=utf-8\r\n  ```\r\n\r\n- 内容编码\r\n\r\n  ```http\r\n  content-encoding: gzip\r\n  ```\r\n\r\n- 语言\r\n\r\n  ```http\r\n  Content-Language: de-DE, en-CA\r\n  ```\r\n\r\n# 包体传输\r\n\r\nHTTP 有两种包体传输方式：定长传输和分块传输\r\n\r\n## 定长传输\r\n\r\n发送 HTTP 消息时已能够确定包体的全部长度，使用 `Content-Length` 明确指明包体长度\r\n\r\n- 使用 10 进制，而不是 16 进制，表示包体中的字节数\r\n\r\n- 必须与实际传输的包体长度一致\r\n- 接收端处理简单\r\n\r\n```http\r\nContent-Length = 1*DIGIT\r\n```\r\n\r\n当 `Content-Length` 指定的字节数小于包体中的数据长度，则浏览器会进行截断处理\r\n\r\n```typescript\r\nimport { createServer } from 'http'\r\n\r\nconst server = createServer((_, res) =\u003e {\r\n  res.setHeader('content-length', 10)\r\n  res.write('hello world')\r\n})\r\n\r\nserver.listen(12306)\r\n```\r\n\r\n当 `Content-Length` 指定的字节数大于包体中的数据长度，页面会加载失败\r\n\r\n## 分块传输\r\n\r\n发送 HTTP 消息时不能确定包体的全部长度，使用 `Transfer-Encoding: chunked` 指明使用 Chunk 传输方式\r\n\r\n- 含 `Transfer-Encoding` 头部后 `Content-Length` 头部应被忽略\r\n- 分块传输则 body 由一些分开发送的  chunked-body  组成\r\n\r\n![](https://oss.xiefeng.tech/images/20210921152832.png)\r\n\r\n- 每一个 chunk 都是一段数据，由 chunk 大小和数据组成\r\n- last-chunk 指的是最后一个 chunk，其中没有数据代表的是 chunk 边界，由多个 0 组成，一般发送一个 0 即可\r\n- trailer-part 是 chunk 传递完之后要传递的 HTTP 头部\r\n  - 可没有该部分，如果有的话首先需要在 `Trailer` 头部声明\r\n  - 该部分可能传递的值：分包传递的这个文件的 MD5 值\r\n\r\n```typescript\r\nimport { createServer } from 'net'\r\n\r\nconst server = createServer((socket) =\u003e {\r\n  socket.on('data', () =\u003e {\r\n    // 头部\r\n    socket.write('HTTP/1.1 200 OK\\r\\n')\r\n    socket.write('Transfer-Encoding: chunked\\r\\n')\r\n    socket.write('\\r\\n')\r\n    // 第一个 chunk\r\n    socket.write('5\\r\\n')\r\n    socket.write('hello\\r\\n')\r\n    // 第二个 chunk\r\n    socket.write('6\\r\\n')\r\n    socket.write(' world\\r\\n')\r\n    // last chunk\r\n    socket.write('0\\r\\n')\r\n    socket.write('\\r\\n')\r\n  })\r\n})\r\nserver.listen(12306)\r\n```\r\n\r\n![](https://oss.xiefeng.tech/images/20210921152737.png)\r\n\r\n如果在 chunk 传递完之后需要传递一些头部，则一开始就需要在 `Trailer` 字段中声明后续 trailer-part 部分要传递的头部字段名\r\n\r\n```typescript\r\nsocket.write('HTTP/1.1 200 OK\\r\\n')\r\nsocket.write('Trailer: Date\\r\\n')\r\nsocket.write('Transfer-Encoding: chunked\\r\\n')\r\nsocket.write('\\r\\n')\r\n\r\nsocket.write('5\\r\\n')\r\nsocket.write('hello\\r\\n')\r\n\r\nsocket.write('0\\r\\n')\r\n\r\nsocket.write(`Date: ${new Date()}\\r\\n`)\r\n\r\nsocket.write('\\r\\n')\r\n```\r\n\r\n但是客户端需要在请求中添加 `TE: trailers` 表明客户端支持处理 `Trailer` 头部\r\n\r\n  有些头部不允许在 `Trailer` 头部中传输：\r\n\r\n  - 用于信息分帧的首部 (例如 `Transfer-Encoding` 和 `Content-Length`)\r\n  - 用于路由用途的首部 (例如 `Host`)\r\n  - 请求修饰首部 (例如控制类和条件类的，如 `Cache-Control`，Max-Forwards，或者 `TE`)\r\n  - 身份验证首部 (例如 `Authorization` 或者 `Set-Cookie`)\r\n  - `Content-Encoding`、`Content-Type`、 `Content-Range`，以及 `Trailer` 自身\r\n\r\nhttps://imququ.com/post/transfer-encoding-header-in-http.html\r\n\r\n  `Content-Disposition` 头部：\r\n\r\n  - `inline`：指定包体是以 `inline` 内联的方式，作为页面的一部分展示\r\n  \r\n  - `attachment`：指定浏览器将包体以附件的方式下载\r\n  \r\n    例如：`Content-Disposition: attachment; filename=“filename.jpg”`\r\n  \r\n  - 在 multipart/form-data 类型应答中，可以用于子消息体部分\r\n  \r\n    例如：`Content-Disposition: form-data; name=\"fieldName\"; filename=\"filename.jpg\"`\r\n\r\n# 表单提交\r\n\r\nPOST 方式下对表单内容在请求包体中的编码方式有两种，并通过 `enctype` 属性控制\r\n\r\n1. `application/x-www-form-urlencoded`\r\n\r\n\t数据被编码成以 ‘\u0026’ 分隔的键值对, 同时以 ‘=’ 分隔键和值，字符以 URL 编码方式编码\r\n\r\n2. `multipart/form-data`\r\n\r\n\t在这种方式下，每个 input 的内容都是一个资源表述，前一种方式所有的 input 内容是一个资源表述\r\n\r\n\t格式特点：1. boundary 分隔符   2. 每部分表述皆有HTTP头部描述子包体，例如 Content-Type   3. last boundary 结尾\r\n\r\n\t`Content-type: multipart/form-data` \r\n\r\n![](http://oss.xiefeng.tech/img/20210403083002.png)\r\n\r\n# Range请求\r\n\r\nHTTP 允许服务器基于客户端的请求只发送响应包体的一部分，而客户端自动将多个片断的包体组合成完整的体积更大的包体\r\n\r\n- 支持断点续传\r\n- 支持多线程下载\r\n- 支持视频播放器实时拖动\r\n\r\n服务器通过 `Accept-Range` 头部表示是否支持 Range 请求：\r\n\r\n- `Accept-Ranges: bytes` 表示支持\r\n- `Accept-Ranges: none` 表示不支持\r\n\r\n## 请求范围\r\n\r\n客户端使用 `Range` 头部传递请求范围：\r\n\r\n- `Range: bytes=0-499`：前 500 字节\r\n- `Range: bytes=500-600,601-999`：多个范围\r\n- `Range: bytes=-500`：最后 500 字节\r\n- `Range: bytes = 9500-`：从当前到结尾\r\n\r\n## 服务器响应\r\n\r\n响应首部 `Content-Range` 显示的是一个数据片段在整个文件中的位置\r\n\r\n```http\r\nContent-Range: \u003cunit\u003e \u003crange-start\u003e-\u003crange-end\u003e/\u003csize\u003e\r\nContent-Range: \u003cunit\u003e \u003crange-start\u003e-\u003crange-end\u003e/*\r\nContent-Range: \u003cunit\u003e */\u003csize\u003e\r\n```\r\n\r\n- `unit`：数据区间所采用的单位，通常是 byte\r\n- `range-start`：表示在给定单位下区间的起始值\r\n- `range-end`：表示在给定单位下，区间的结束值\r\n- `size`：整个文件的大小，如果大小未知则用 `*` 表示\r\n\r\n### 单一范围\r\n\r\n1. 服务器支持 range 请求并且请求范围正确，服务器返回 `206 Partial Content` + `Content-Range`\r\n\r\n  ![](https://oss.xiefeng.tech/images/20210922113300.png)\r\n\r\n2. 请求范围不满足实际资源的大小，服务器返回 `416 Range Not Satisfiable`  +  `Content-Range: bytes */1234`\r\n\r\n  ![](https://oss.xiefeng.tech/images/20210922113443.png)\r\n\r\n3. 服务器不支持 `Range` 请求时，服务器以 200 返回完整的响应包体\r\n\r\n### 多重范围\r\n\r\n当客户端请求多个范围时：\r\n\r\n```shell\r\ncurl https://xiefeng.tech -i -H \"Range: bytes=0-50, 100-150\"\r\n```\r\n\r\n1. 服务器返回 206 Partial Content 状态码\r\n2. 具有头部：`Content-Type：multipart/byteranges; boundary=xxxxxxxx`\r\n3. `Content-Type：multipart/byteranges` 表示这个响应有多个 byterange，并且它们之间使用 boundary 分隔\r\n4. 每一部分 byterange 都有他自己的 `Centen-type` 头部和 `Content-Range`\r\n\r\n![](https://oss.xiefeng.tech/images/20210922113006.png)\r\n\r\n## 条件Range\r\n\r\n如果客户端已经得到了 Range 响应的一部分，并想在这部分响应未过期的情况下，获取其他部分的响应\r\n\r\n则需要将 Range 和 If-Unmodified-Since 或者 If-Match 头部共同使用\r\n\r\n可以使用 `If-Range = entity-tag / HTTP-date`，其值可以为 Etag 或者 Last-Modified\r\n\r\n```http\r\nGET /index.html HTTP/1.1\r\nIf-Range: \"123456\"\r\nRange: bytes=5001-10000\r\n```\r\n\r\n它告知服务器若该字段的值（`ETage` 值 / 时间）和请求资源的 `ETage` 值 / 时间一致时，则作为范围请求处理，否则返回全体资源\r\n\r\n# Cookie\r\n\r\nCookie 是保存在客户端、由浏览器维护、表示应用状态的 HTTP 头部\r\n\r\n服务器通过响应中添加 `Set-Cookie` 来种 Cookie，客户端通过 `Cookie` 字段携带本地存储的 Cookie\r\n\r\n`Set-Cookie` 头部一次只能传递 1 个 name/value 名值对，但是响应中可以含多个 `Set-Cookie` 头部\r\n\r\n**Cookie 字段**\r\n\r\n- `Name=value`：Cookie 的名和值\r\n- `expires`：设置 cookie 的过期时间，如果没有设置则当前会话结束就过期\r\n- `max-age`：cookie 经过多少秒后失效，`max-age` 优先级高于 `expires` 且不能为0，http1.1 出现\r\n- `path`：可以访问此 cookie 的页面路径，子路径也能访问\r\n- `domain`：可以访问此 cookie 的域名\r\n  - 顶级域名只能设置 domain 为顶级域名\r\n  - 二级域名能读取设置了 domain 为顶级域名或者自身的 cookie\r\n  - 将设置 domain 为顶级域名， cookie 可以在多个二级域名中共享\r\n- `Secure`：只有使用 TLS/SSL 协议（https）时才能使用该 cookie\r\n- `HttpOnly`：不能通过 JavaScript 访问到该 cookie\r\n- `SameSite`： 允许服务器要求某个 cookie 在跨站请求时不会被发送，用于阻止 CSRF 攻击\r\n  - None：浏览器会在同站请求、跨站请求下继续发送 cookies\r\n  - Strict：浏览器将只在访问相同站点时发送 cookie\r\n  - Lax：与 Strict 类似，但用e户从外部站点导航至URL时（例如通过链接）除外\r\n\r\n**第三方Cookie** \r\n\r\n浏览器允许对于其他域下的资源（如广告图片）响应中的 `Set-Cookie` 保存，并在后续访问该域时自动使用 Cookie\r\n\r\n# 条件请求\r\n\r\n- `If-Match`\r\n\r\n\t- 服务器会比对该字段值和资源的 `ETage` 值是否一致\r\n\t- 一致则会执行请求\r\n\t- 不一致则返回 412\r\n\t\r\n- `If-Modified-Since`\r\n\r\n\t- 如果在该字段的日期之后资源没有更新，服务器返回 304\r\n\t- 否则返回 200 + `Last-Modified`\r\n\t\r\n- `If-None-Match`\r\n\r\n\t- 和 `If-Match` 相反，当和 `ETag` 值不一致时处理请求\r\n\r\n- `If-Unmodified-Since`\r\n\r\n\t- 和 `If-Unmodified-Since` 相反，如果发生了更新返回 412，没更新处理请求\r\n\r\n- `If-Range`\r\n\r\n\t- 它告知服务器若该字段的值和请求资源的 `ETage` 值 / 时间一致时，则作为范围请求处理，否则返回全体资源\r\n\r\nETag：资源的实体标识，服务器会为每一份资源分配对应的 `ETag` 值，资源更新时，`ETag` 也需要更新\r\n\r\n- 强 `ETag`：不论实体发生多么细微的变化该值都会变化，如：`ETag: \"usagi-1234\"` \r\n\r\n- 弱 `ETag`：只有资源发生了根本的改变，才会改变该值，会在字段开始添加 `W/` 如： `ETag: W/\"usagi-1234\"` \r\n\r\n# 请求上下文\r\n\r\n- `User-Agent` 头部：指明客户端的类型信息，服务器可以据此对资源的表述做抉择\r\n\r\n\t```http\r\n\tUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36(KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36\r\n\t```\r\n\r\n- `Referer` 头部：浏览器对来自某一页面的请求自动添加的头部\r\n\r\n\t- `Referer` 不会被添加的场景\r\n\t\t- 来源页面采用的协议为表示本地文件的 \"`file`\" 或者 \"`data`\" URI\r\n\t\t- 当前请求页面采用的是 `http` 协议，而来源页面采用的是 `https` 协议\r\n\r\n- `From` 头部：主要用于网络爬虫，告诉服务器如何通过邮件联系到爬虫的负责人\r\n\r\n- `Server` 头部：指明服务器上所用软件的信息，用于帮助客户端定位问题或者统计数据\r\n\r\n- `Allow` 头部：告诉客户端，服务器上该 URI 对应的资源允许哪些方法的执行\r\n\r\n# 缓存控制\r\n\r\n- `Cache-Control`\r\n\r\n\t- **请求**\r\n\r\n\t\t- `no-cache`\r\n\r\n\t\t\t告诉服务器，不能直接使用已有缓存作为响应返回，除非带着缓存条件到上游服务端得到 304 验证返回码才可使用现有缓存\r\n\r\n\t\t- `no-store` \r\n\r\n\t\t\t告诉各代理服务器不要对该请求的响应缓存（实际有不少不遵守该规定的代理服务器）\r\n\r\n\t\t- `max-age`\r\n\r\n\t\t\t告诉服务器，客户端不会接受时间超出 `max-age` 的缓存\r\n\r\n\t\t- `min-fresh`\r\n\r\n\t\t\t要求服务器返回至少还未超过指定时间的缓存资源（在指定时间内没有过期的缓存可以返回）\r\n\r\n\t\t\t告诉服务器，`Age` 至少经过 `min-fresh` 秒后缓存才可使用\r\n\r\n\t\t- `max-stale`\r\n\r\n\t\t\t接收缓存即使过期，没指定数值怎样都会接收缓存；如果指定数值，即使过期，只要没有超过指定的时间都可以接收\r\n\r\n\t\t- `no-transform`\r\n\r\n\t\t\t告诉代理服务器不要修改消息包体的内容\r\n\r\n\t\t- `only-if-cached`\r\n\r\n\t\t\t告诉服务器仅能返回缓存的响应，若没有缓存则返回 504 错误码\r\n\r\n\t- **响应**\r\n\r\n\t\t- `public`、`private`\r\n\r\n\t\t\t`public`：表示无论私有缓存或者共享缓存，皆可将该响应缓存\r\n\r\n\t\t\t`private`：表示该响应不能被代理服务器作为共享缓存使用。若 `private` 后指定头部，则在告诉代理服务器不能缓存指定的头部，但可缓存其他部分\r\n\r\n\t\t- `no-cache`\r\n\r\n\t\t\t告诉客户端不能直接使用缓存的响应，使用前必须在源服务器验证得到 304 返回码。如果 `no-cache` 后指定头部，则若客户端的后续请求及响应中不含有这些头则可直接使用缓存\r\n\r\n\t\t- `no-store`\r\n\r\n\t\t\t告诉所有下游节点不能对响应进行缓存\r\n\r\n\t\t- `max-age`\r\n\r\n\t\t\t告诉客户端缓存时间超出 `max-age` 秒后则缓存过期\r\n\r\n\t\t- `s-maxage`\r\n\r\n\t\t\t与 `max-age` 相似，但仅针对共享缓存，且优先级高于 `max-age` 和 `Expires`，告诉缓存最多缓存多久\r\n\r\n\t\t- `no-transform`\r\n\r\n\t\t\t告诉代理服务器不能修改消息包体的内容\r\n\r\n\t\t- `must-revalidate`\r\n\r\n\t\t\t告诉**客户端**一旦缓存过期，必须向服务器验证后才可使用\r\n\r\n\t\t- `proxy-revalidate` \r\n\r\n\t\t\t与 `must-revalidate` 类似，但它仅对**代理服务器**的共享缓存有效\r\n\r\n- `Age`\r\n\r\n\t表示自源服务器发出响应（或者验证过期缓存），到使用缓存的响应发出时经过的秒数\r\n\r\n- `Pragma`\r\n\r\n\t是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义\r\n\r\n\t```http\r\n\tCache-Control: no-cache\r\n\tPragma: no-cache\r\n\t```\r\n\r\n- `Vary`\r\n\r\n\t服务器告诉缓存服务器/客户端，只有请求持有和 该头部指定的值相同且头部的相同 才可以响应缓存\r\n\r\n\t```http\r\n\t// 浏览器 -\u003e 代理\r\n\tGET /sample.html\r\n\tAccept-Language: en-us\r\n\t\r\n\t// 代理 -\u003e 源服务器\r\n\tGET /sample.html\r\n\tAccept-Language: en-us\r\n\t\r\n\t// 源 -\u003e 代理\r\n\tVary: Accept-Language\r\n\t```\r\n\r\n- `Expires`\r\n\r\n\t资源失效的日期\r\n\r\n- `Warning`\r\n\r\n\tHTTP/1.1 的 warning 首部是从 HTTP/1.0 的响应头部（Retry-After）演变过来的，通常会告知用户一些和缓存相关的问题的警告\r\n\r\n\t```http\r\n\tWarning: [警告码] [警告的主机:端口号] \"[警告内容]\"([日期时间])\r\n\t```\r\n\r\n\r\n# 消息的转发\r\n\r\n- `Via`\r\n\r\n\t使用该字段用于追踪客户端和服务器之间的请求和响应报文的传输路径，报文经过代理或网关时，会现在首部字段 `Via` 中附加该服务器的信息，然后再进行转发。\r\n\r\n\t`Via` 首部是为了追踪传输路径，所以经常和 `TRACE` 方法一起使用。代理服务器接收到请求并且 `Max-Forward: 0`，服务器则会加上自身的信息后返回响应\r\n\r\n- `Max-Forwards`\r\n\r\n\t限制 Proxy 代理服务器的最大转发次数，仅对 `TRACE` / `OPTIONS` 方法有效\r\n\r\n- 传递 IP 地址\r\n\r\n\t- `X-Forwarded-For` 传递代理服务器的地址\r\n\t- `X-Real-IP`  传递真正请求的地址\r\n\r\n\t```http\r\n\tX-Forwarded-For: 115.204.33.1, 1.1.1.1\r\n\tX-Real-IP: 115.204.33.1\r\n\t```\r\n\r\n# 重定向\r\n\r\n`Location` 可以将响应接收方引导至某个与请求URI位置不同的资源，和 3xx 配合，提供重定向的 URI\r\n\r\n流程：当浏览器接收到重定向响应码时，需要读取响应头部 Location 头部的值，获取到新的 URI 再跳转访问该页面\r\n\r\n1. 永久重定向，表示资源永久性变更到新的 URI\r\n\t- 301（HTTP/1.0）：重定向请求通常（一些浏览器会把 POST 改为GET）会使用 GET 方法，而不管原请求究竟采用的是什么方法\r\n\t- 308（HTTP/1.1）：重定向请求必须使用原请求的方法和包体发起访问\r\n2. 临时重定向，表示资源只是临时的变更 URI\r\n\t- 302 （HTTP/1.0）：重定向请求通常会使用 GET 方法，而不管原请求究竟采用的是什么方法\r\n\t- 303 （HTTP/1.1）：它并不表示资源变迁，而是用新 URI 的响应表述而为原请求服务，重定向请求会使用 GET 方法\r\n\t\t- 例如表单提交后向用户返回新内容（亦可防止重复提交）\r\n\t- 307 （HTTP/1.1）：重定向请求必须使用原请求的方法和包体发起访问\r\n3. 特殊重定向\r\n\t- 300：响应式内容协商中，告知客户端有多种资源表述，要求客户端选择一种自认为合适的表述\r\n\t- 304：服务器端验证过期缓存有效后，要求客户端使用该缓存\r\n\r\n# Upgrade\r\n\r\n用于检测 HTTP 协议及其它协议是否可以使用更高的版本进行通信，其参数可以用来指定一个完全不同的通信协议，对于 `Upgrade` 请求，服务器可返回 101\r\n\r\n```http\r\nGET /index.html HTTP/1.1\r\nUpgrade: TLS/1.0\r\nConnection: Upgrade\r\n```\r\n\r\n```http\r\nHTTP/1.1 101 Switching Protocols\r\nUpgrade: TLS/1.0, HTTP/1.1\r\nConnection: Upgrade\r\n```\r\n","meta":{"size":29648,"birthTime":1663496641441.6006,"updateTime":1663496641442.051}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["计算机网络","应用层","HTTP1"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>HTTP2 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#HTTP/1.1的缺点" data-target-id="h1-HTTP/1.1的缺点-0">HTTP/1.1的缺点</a><ul><li><a href="#高延迟" data-target-id="h2-高延迟-0">高延迟</a></li><li><a href="#性能优化" data-target-id="h2-性能优化-1">性能优化</a></li></ul></li><li><a href="#HTTP/2" data-target-id="h1-HTTP/2-1">HTTP/2</a><ul><li><a href="#核心概念" data-target-id="h2-核心概念-2">核心概念</a><ul><li><a href="#Frame" data-target-id="h3-Frame-0">Frame</a></li><li><a href="#Stream" data-target-id="h3-Stream-1">Stream</a></li><li><a href="#Message" data-target-id="h3-Message-2">Message</a></li></ul></li><li><a href="#多路复用" data-target-id="h2-多路复用-3">多路复用</a></li><li><a href="#帧格式" data-target-id="h2-帧格式-4">帧格式</a></li><li><a href="#安全性" data-target-id="h2-安全性-5">安全性</a></li><li><a href="#协议升级" data-target-id="h2-协议升级-6">协议升级</a><ul><li><a href="#Magic帧" data-target-id="h3-Magic帧-3">Magic帧</a></li><li><a href="#SETTING帧" data-target-id="h3-SETTING帧-4">SETTING帧</a></li></ul></li><li><a href="#头部压缩" data-target-id="h2-头部压缩-7">头部压缩</a></li><li><a href="#服务器推送" data-target-id="h2-服务器推送-8">服务器推送</a></li></ul></li><li><a href="#HTTP/3" data-target-id="h1-HTTP/3-2">HTTP/3</a><ul><li><a href="#HTTP/2 缺点" data-target-id="h2-HTTP/2 缺点-9">HTTP/2 缺点</a></li><li><a href="#QUIC" data-target-id="h2-QUIC-10">QUIC</a></li></ul></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">HTTP2</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h1>HTTP/1.1的缺点</h1>
<p><strong>HTTP/1.1 发明以来：</strong></p>
<ul>
<li>一个页面请求的消息大小从几 KB到几 MB</li>
<li>每个页面从小于10个资源，到多于100个资源</li>
<li>网站内容从文本为主到富媒体为主</li>
<li>对页面内容实时性高要求的应用越来越多</li>
</ul>
<h2>高延迟</h2>
<p>虽然 HTTP/1.1 使用了长连接，但是随着带宽的提高以及网站资源数量的提升，HTTP/1.1 的缺点慢慢暴露出来：</p>
<ul>
<li>同一连接同时只能在完成一个 HTTP 事务（请求/响应）才能处理下一个事务</li>
<li>即使使用管道网络（只要第一个请求发出去了，就可以发第二个请求），服务器的响应依旧是顺序的，存在队头阻塞的问题</li>
<li>浏览器对一个域名下的并发连接（TCP 连接）有限，Chrome 中同域名下资源加载的最大并发连接数为 6</li>
<li>重复传输一些体积巨大的 HTTP 头部（无状态），导致高传输量</li>
<li>单连接上的串行请求，导致随着带宽的增加，延迟并没有显著下降</li>
<li>不支持服务器的消息推送</li>
</ul>
<h2>性能优化</h2>
<p>为了提高网站的性能，HTTP/1.1 下所做的一些努力：</p>
<ul>
<li>使用雪碧图，将许多张小图片放到一张大图片中，减少请求</li>
<li>将一些图片进行 base64 编码内嵌到 HTML / CSS 文件中，减少请求</li>
<li>将体积较小的 JavaScript 文件打包成一个大 JavaScript 文件，减少请求</li>
<li>Sharding 分片，将同一页面的资源分散到不同域名下，提升 TCP 连接上限</li>
</ul>
<p>可以看到 HTTP/1.1 的主要问题就是并发度不够，一个请求需要等到上一个请求处理完毕才能发送。</p>
<h1>HTTP/2</h1>
<p>HTTP/2 的前身是 SPDY 协议，该协议由Google开发，最早在Chromium中提出，HTTP/2 的关键功能主要来自 SPDY 技术。</p>
<ul>
<li>HTTP/2 没有改变 HTTP 的基本模型，仅在应用层上修改并充分挖掘 TCP 协议性能</li>
<li>支持多路复用，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流</li>
<li>支持消息优先级</li>
<li>传输的数据量大幅减少，全部采用二进制传输，头部会进行压缩</li>
<li>服务器可以推送消息</li>
</ul>
<h2>核心概念</h2>
<ul>
<li>Stream：流是连接中的一个虚拟信道，可以承载双向的消息；</li>
<li>Message：HTTP/1 中的请求/响应，在 HTTP/2 中是一个逻辑上的概念，对应的就是一系列的帧</li>
<li>Frame：是 HTTP/2 通信的最小单位，承载着特定类型的数据，如 HTTP 首部</li>
</ul>
<p><img src="http://oss.xiefeng.tech/img/20210330114734.png" alt="Frame、Stream、Message三者关系"/></p>
<h3>Frame</h3>
<p>HTTP/2 将所有传输的信息分割为更小的<strong>帧</strong>，并采用<strong>二进制</strong>格式对它们编码。</p>
<p>HTTP/1.1 是明文传输，报文的内容就是文本，而 HTTP/2 是一个彻彻底底的二进制协议。</p>
<p>HTTP/2 所有性能增强的核心在于<strong>分帧</strong>，网络传输的数据就是一个一个的帧，在抓包的层面，抓取到的每一个 HTTP/2 报文都是一个<strong>帧</strong>。</p>
<p>帧就是 HTTP/2 的报文，这一点需要和 HTTP/1 严格区分。</p>
<p>帧具有多种类型，就比如：头部帧、数据帧，对应的就是HTTP/1 中的头部和消息体。</p>
<p>HTTP/2 具有很多其他的特性，这些特性往往依托于特定类型的帧实现。</p>
<h3>Stream</h3>
<p>一个流对应的是 HTTP/1 中的一个事务（一个请求和一个响应），一个流中会有很多的<strong>帧</strong>，这些帧都属于这次的请求和响应的消息。</p>
<p>在一个 TCP 连接中，会同时存在很多不同的流，流和流之间是乱序到达的，但是属于同一个流的帧之间是有序的。</p>
<p>每个<strong>帧</strong>都有一个 StreamID 头部，用于标识这个帧属于哪一个流，在到达之后属于同一个流的帧会被组装成消息。</p>
<p>StreamID 是 HTTP/2 实现多路复用的关键，接收端据此实现并发组装消息</p>
<ul>
<li>同一 Stream 内的 frame 必须是有序的</li>
<li>SETTINGS_MAX_CONCURRENT_STREAMS 控制着并发 Stream 数</li>
<li>由客户端主动发送的流的 ID 为奇数</li>
<li>在服务器推送的情况下，流的 ID 为偶数</li>
<li>Stream ID 为 0 的流仅用于传输控制帧</li>
</ul>
<h3>Message</h3>
<p>Message 本质上对应的是一个响应 / 请求，在 HTTP/2 中这其实是一个逻辑上的概念。</p>
<p>因为 HTTP/2 传输的数据都是帧，所以本质上一个 Message 是由多个帧（HEAD 帧 + DATA帧）组成。</p>
<p>Message 这个概念在 HTTP/2 中没什么意义，也没有实体存在，只对上层的应用有意义。</p>
<p><img src="http://oss.xiefeng.tech/img/20210402101326.png" alt="Frame 和 Message 的关系"/></p>
<h2>多路复用</h2>
<p>所谓多路复用，通常表示在一个信道上传输多路信号或数据流的过程和技术。</p>
<p><strong>HTTP/2 实现多路复用的核心就是二进制分帧和流：</strong></p>
<p>有了二进制分帧之后，HTTP/2 不再依赖 TCP去实现多流并行了，发送端可以将 HTTP 消息分解为互不依赖的帧交错发送，最后接收端依据 StreamID 将它们重新组装起来。</p>
<p>多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也更容易实现全速传输（因为TCP具有慢启动的特性）。</p>
<p><strong>多路复用的特点</strong></p>
<ul>
<li>并行交错地发送多个请求，请求之间互不影响</li>
<li>并行交错地发送多个响应，响应之间互不干扰</li>
<li>消除不必要的延迟和提高带宽的利用率，减少页面加载时间</li>
<li>解决了 HTTP/1.1 中存在的队首阻塞问题</li>
</ul>
<p><img src="http://oss.xiefeng.tech/img/20210331192538.png" alt=""/></p>
<h2>帧格式</h2>
<p><img src="http://oss.xiefeng.tech/img/20210402103040.png" alt=""/></p>
<p>在 HTTP/2 中，帧本质上就是该层的报文，31位的 Stream ID 字段指明了该帧对应的 Stream，Frame Payload 存放该帧附带的数据。</p>
<p><img src="https://oss.xiefeng.tech/images/20210923171313.png" alt=""/></p>
<p>HTTP/2 的很多特性都是通过帧来实现的，所以 HTTP/2 具有多种类型的帧，每个帧都有一个编码类型，对应帧的 Type 字段值。</p>
<p><img src="http://oss.xiefeng.tech/img/20210402103535.png" alt=""/></p>
<h2>安全性</h2>
<p>IETF 标准不要求 HTTP/2 必须基于 TLS/SSL 协议，但是浏览器要求使用 HTTP/2 必须基于 TLS/SSL 协议。</p>
<p>所以大部分使用 HTTP/2 的网站都是基于 TLS的。</p>
<ul>
<li>
<p><strong>h2：</strong> 基于 TLS 协议运行的 HTTP/2 被称为 h2</p>
</li>
<li>
<p><strong>h2c：</strong> 直接在 TCP 协议之上运行的 HTTP/2 被称为 h2c</p>
</li>
</ul>
<h2>协议升级</h2>
<p>在不使用 TLS 协议进行协议升级的情况，就像升级 websocket 协议一样。</p>
<p>在 TCP 三次握手之后，客户端发送 <code>Connect: Upgrade</code> 报文，然后服务器返回 101 状态码完成升级。</p>
<p><img src="https://oss.xiefeng.tech/images/20210923151412.png" alt=""/></p>
<p>对于 h2c 协议升级发生在 TLS 握手过程中，在 TLS 层 ALPN 扩展做协商，只认 HTTP/1 的代理服务器不会干扰 HTTP/2。</p>
<h3>Magic帧</h3>
<p>协议升级完成之后还需要发送 Preface，也就是一个 Magic 帧。</p>
<ul>
<li>接收到服务器发送来的 101 Switching Protocols 之后</li>
<li>TLS 握手成功后</li>
</ul>
<p>Magic 一般而言都是一个固定的内容，HTTP/2 Preface 内容：<code>0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a</code></p>
<p>解码之后的内容就是 <code>PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</code></p>
<p><img src="https://oss.xiefeng.tech/images/20210923151822.png" alt=""/></p>
<h3>SETTING帧</h3>
<p>建立起 HTTP/2 连接之后就会发送 SETTING 帧，其对应的 Stream ID 一定为 0</p>
<p>SETTING 帧并不是“协商”，而是发送方向接收方<strong>通知</strong>其特性、能力</p>
<ul>
<li>SETTINGS_HEADER_TABLE_SIZE：通知对端索引表的最大尺寸（单位字节，初始 4096 字节）</li>
<li>SETTINGS_ENABLE_PUSH：设置为 0 时可禁用服务器推送功能，1 表示启用推送功能</li>
<li>SETTINGS_MAX_CONCURRENT_STREAMS：告诉接收端允许的最大并发流数量</li>
<li>SETTINGS_INITIAL_WINDOW_SIZE：声明发送端的窗口大小，用于Stream级别流控，初始值 $2^16-1$字节</li>
<li>SETTINGS_MAX_FRAME_SIZE：设置帧的最大大小，初始值 2^14 (16,384)字节</li>
<li>SETTINGS_MAX_HEADER_LIST_SIZE：知会对端头部索引表的最大尺寸，单位字节，基于未压缩前的头部</li>
</ul>
<p>当 Magic 帧发送完毕之后，客户端紧接着会发一些 SETTING 帧：</p>
<p><img src="https://oss.xiefeng.tech/images/20210923152708.png" alt=""/></p>
<h2>头部压缩</h2>
<p>HTTP/1 使用文本的形式传输 header，每次都可能重复传输几百到几千的字节，尤其在携带 cookie 的情况下</p>
<p>HTTP/2 使用 HPACK 算法来压缩 HTTP 头部，三种压缩方式：</p>
<ul>
<li>静态字典</li>
<li>动态字典</li>
<li>Huffman 压缩算法</li>
</ul>
<p>静态字典就是预先定义了一些头部，这些头部 + 取值对一个一个数字，发送时直接使用数字就可以。</p>
<p>动态字典是在请求过程中维护的一张表，将存储的 header 字段与索引值相关联，类似于静态表。</p>
<p><img src="http://oss.xiefeng.tech/img/20210402183229.png" alt="编码过程"/></p>
<h2>服务器推送</h2>
<p>HTTP/2 的服务器推送是指服务器提前将资源推送至浏览器缓存，所以推送是基于已发送的请求。</p>
<p>例如：浏览器在请求 HTML 页面时，服务器在响应 HTML 文件的同时主动推送页面所需的 CSS 文件。</p>
<p>实现服务器推送的方式：</p>
<ul>
<li>推送资源必须对应一个请求（未来的请求）</li>
<li>请求信息由服务器端 PUSH_PROMISE 帧发送</li>
<li>推送在偶数 ID 的 STREAM 中发送</li>
</ul>
<p>PUSH_PROMISE 帧的作用是通知客户端服务器<strong>即将</strong>推送一个资源，这个资源对应未来的一个请求，请先缓存下来</p>
<p>PUSH_PROMISE 帧中包含该资源对应的请求信息，未来的这个请求请求时直接使用缓存即可</p>
<p>当然了资源会在另一个流中推送过来，并且这个推送资源的流和前一个流可以是并发的，而且 PUSH_PROMISE 帧只有服务器才能发送</p>
<p><img src="https://oss.xiefeng.tech/images/20210923173004.png" alt=""/></p>
<h1>HTTP/3</h1>
<h2>HTTP/2 缺点</h2>
<ul>
<li>
<p>基于 TCP 的 h2c 协议需要先进行三次握手，基于 TLS 的 h2 协议需要进行六次握手</p>
</li>
<li>
<p>TCP 的队头阻塞问题</p>
</li>
</ul>
<p>HTTP/2 基于 TCP 且每个请求会复用 TCP，流虽然是并发发送的，但是 TCP 是需要保证资源的按序到达，一旦前面的一个流在网络中丢包了，就会阻塞后面所有的流。</p>
<p><img src="https://oss.xiefeng.tech/images/20210923173536.png" alt=""/></p>
<h2>QUIC</h2>
<p>QUIC是由 Google 公开，提高了目前使用 TCP 的面向连接的网络应用的性能，基于 UDP。</p>
<p>QUIC 严格来说运行在 HTTP 协议之下，主要就是基于 UDP 实现了可靠的报文传输。</p>
<p><img src="http://oss.xiefeng.tech/img/20210402185101.png" alt=""/></p>
<p>HTTP/3 指的是运行在 QUIC 协议之上的 HTTP</p>
<ul>
<li>TLS3 升级成了最新的 1.3 版本，握手次数减少</li>
<li>允许客户端更换 IP 地址、端口后，仍然可以复用前连接</li>
<li>基于 UDP，不存在队头阻塞问题</li>
</ul><div><a href="/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"HTTP2","article":{"title":"HTTP2","content":"# HTTP/1.1的缺点\n\n**HTTP/1.1 发明以来：**\n\n- 一个页面请求的消息大小从几 KB到几 MB\n- 每个页面从小于10个资源，到多于100个资源\n- 网站内容从文本为主到富媒体为主\n- 对页面内容实时性高要求的应用越来越多\n\n## 高延迟\n\n虽然 HTTP/1.1 使用了长连接，但是随着带宽的提高以及网站资源数量的提升，HTTP/1.1 的缺点慢慢暴露出来：\n\n- 同一连接同时只能在完成一个 HTTP 事务（请求/响应）才能处理下一个事务\n- 即使使用管道网络（只要第一个请求发出去了，就可以发第二个请求），服务器的响应依旧是顺序的，存在队头阻塞的问题\n- 浏览器对一个域名下的并发连接（TCP 连接）有限，Chrome 中同域名下资源加载的最大并发连接数为 6\n- 重复传输一些体积巨大的 HTTP 头部（无状态），导致高传输量\n- 单连接上的串行请求，导致随着带宽的增加，延迟并没有显著下降\n- 不支持服务器的消息推送\n\n## 性能优化\n\n为了提高网站的性能，HTTP/1.1 下所做的一些努力：\n\n- 使用雪碧图，将许多张小图片放到一张大图片中，减少请求\n- 将一些图片进行 base64 编码内嵌到 HTML / CSS 文件中，减少请求\n- 将体积较小的 JavaScript 文件打包成一个大 JavaScript 文件，减少请求\n- Sharding 分片，将同一页面的资源分散到不同域名下，提升 TCP 连接上限\n\n可以看到 HTTP/1.1 的主要问题就是并发度不够，一个请求需要等到上一个请求处理完毕才能发送。\n\n# HTTP/2\n\nHTTP/2 的前身是 SPDY 协议，该协议由Google开发，最早在Chromium中提出，HTTP/2 的关键功能主要来自 SPDY 技术。\n\n- HTTP/2 没有改变 HTTP 的基本模型，仅在应用层上修改并充分挖掘 TCP 协议性能\n- 支持多路复用，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流\n- 支持消息优先级\n- 传输的数据量大幅减少，全部采用二进制传输，头部会进行压缩\n- 服务器可以推送消息\n\n## 核心概念\n\n- Stream：流是连接中的一个虚拟信道，可以承载双向的消息；\n- Message：HTTP/1 中的请求/响应，在 HTTP/2 中是一个逻辑上的概念，对应的就是一系列的帧\n- Frame：是 HTTP/2 通信的最小单位，承载着特定类型的数据，如 HTTP 首部\n\n![Frame、Stream、Message三者关系](http://oss.xiefeng.tech/img/20210330114734.png)\n\n### Frame\n\nHTTP/2 将所有传输的信息分割为更小的**帧**，并采用**二进制**格式对它们编码。\n\nHTTP/1.1 是明文传输，报文的内容就是文本，而 HTTP/2 是一个彻彻底底的二进制协议。\n\nHTTP/2 所有性能增强的核心在于**分帧**，网络传输的数据就是一个一个的帧，在抓包的层面，抓取到的每一个 HTTP/2 报文都是一个**帧**。\n\n帧就是 HTTP/2 的报文，这一点需要和 HTTP/1 严格区分。\n\n帧具有多种类型，就比如：头部帧、数据帧，对应的就是HTTP/1 中的头部和消息体。\n\nHTTP/2 具有很多其他的特性，这些特性往往依托于特定类型的帧实现。\n\n### Stream\n\n一个流对应的是 HTTP/1 中的一个事务（一个请求和一个响应），一个流中会有很多的**帧**，这些帧都属于这次的请求和响应的消息。\n\n在一个 TCP 连接中，会同时存在很多不同的流，流和流之间是乱序到达的，但是属于同一个流的帧之间是有序的。\n\n每个**帧**都有一个 StreamID 头部，用于标识这个帧属于哪一个流，在到达之后属于同一个流的帧会被组装成消息。\n\nStreamID 是 HTTP/2 实现多路复用的关键，接收端据此实现并发组装消息\n\n- 同一 Stream 内的 frame 必须是有序的\n- SETTINGS_MAX_CONCURRENT_STREAMS 控制着并发 Stream 数\n- 由客户端主动发送的流的 ID 为奇数\n- 在服务器推送的情况下，流的 ID 为偶数\n- Stream ID 为 0 的流仅用于传输控制帧\n\n### Message\n\nMessage 本质上对应的是一个响应 / 请求，在 HTTP/2 中这其实是一个逻辑上的概念。\n\n因为 HTTP/2 传输的数据都是帧，所以本质上一个 Message 是由多个帧（HEAD 帧 + DATA帧）组成。\n\nMessage 这个概念在 HTTP/2 中没什么意义，也没有实体存在，只对上层的应用有意义。\n\n![Frame 和 Message 的关系](http://oss.xiefeng.tech/img/20210402101326.png)\n\n## 多路复用\n\n所谓多路复用，通常表示在一个信道上传输多路信号或数据流的过程和技术。\n\n**HTTP/2 实现多路复用的核心就是二进制分帧和流：**\n\n有了二进制分帧之后，HTTP/2 不再依赖 TCP去实现多流并行了，发送端可以将 HTTP 消息分解为互不依赖的帧交错发送，最后接收端依据 StreamID 将它们重新组装起来。\n\n多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也更容易实现全速传输（因为TCP具有慢启动的特性）。\n\n**多路复用的特点**\n\n- 并行交错地发送多个请求，请求之间互不影响\n- 并行交错地发送多个响应，响应之间互不干扰\n- 消除不必要的延迟和提高带宽的利用率，减少页面加载时间\n- 解决了 HTTP/1.1 中存在的队首阻塞问题\n\n![](http://oss.xiefeng.tech/img/20210331192538.png)\n\n## 帧格式\n\n![](http://oss.xiefeng.tech/img/20210402103040.png)\n\n在 HTTP/2 中，帧本质上就是该层的报文，31位的 Stream ID 字段指明了该帧对应的 Stream，Frame Payload 存放该帧附带的数据。\n\n![](https://oss.xiefeng.tech/images/20210923171313.png)\n\nHTTP/2 的很多特性都是通过帧来实现的，所以 HTTP/2 具有多种类型的帧，每个帧都有一个编码类型，对应帧的 Type 字段值。\n\n![](http://oss.xiefeng.tech/img/20210402103535.png)\n\n## 安全性\n\nIETF 标准不要求 HTTP/2 必须基于 TLS/SSL 协议，但是浏览器要求使用 HTTP/2 必须基于 TLS/SSL 协议。\n\n所以大部分使用 HTTP/2 的网站都是基于 TLS的。\n\n- **h2：** 基于 TLS 协议运行的 HTTP/2 被称为 h2\n\n- **h2c：** 直接在 TCP 协议之上运行的 HTTP/2 被称为 h2c\n\n## 协议升级\n\n在不使用 TLS 协议进行协议升级的情况，就像升级 websocket 协议一样。\n\n在 TCP 三次握手之后，客户端发送 `Connect: Upgrade` 报文，然后服务器返回 101 状态码完成升级。\n\n![](https://oss.xiefeng.tech/images/20210923151412.png)\n\n对于 h2c 协议升级发生在 TLS 握手过程中，在 TLS 层 ALPN 扩展做协商，只认 HTTP/1 的代理服务器不会干扰 HTTP/2。\n\n### Magic帧\n\n协议升级完成之后还需要发送 Preface，也就是一个 Magic 帧。\n\n- 接收到服务器发送来的 101 Switching Protocols 之后\n- TLS 握手成功后\n\nMagic 一般而言都是一个固定的内容，HTTP/2 Preface 内容：`0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a`\n\n解码之后的内容就是 `PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n`\n\n![](https://oss.xiefeng.tech/images/20210923151822.png)\n\n### SETTING帧\n\n建立起 HTTP/2 连接之后就会发送 SETTING 帧，其对应的 Stream ID 一定为 0\n\nSETTING 帧并不是“协商”，而是发送方向接收方**通知**其特性、能力\n\n- SETTINGS_HEADER_TABLE_SIZE：通知对端索引表的最大尺寸（单位字节，初始 4096 字节）\n- SETTINGS_ENABLE_PUSH：设置为 0 时可禁用服务器推送功能，1 表示启用推送功能\n- SETTINGS_MAX_CONCURRENT_STREAMS：告诉接收端允许的最大并发流数量\n- SETTINGS_INITIAL_WINDOW_SIZE：声明发送端的窗口大小，用于Stream级别流控，初始值 $2^16-1$字节\n- SETTINGS_MAX_FRAME_SIZE：设置帧的最大大小，初始值 2^14 (16,384)字节\n- SETTINGS_MAX_HEADER_LIST_SIZE：知会对端头部索引表的最大尺寸，单位字节，基于未压缩前的头部\n\n当 Magic 帧发送完毕之后，客户端紧接着会发一些 SETTING 帧：\n\n![](https://oss.xiefeng.tech/images/20210923152708.png)\n\n## 头部压缩\n\nHTTP/1 使用文本的形式传输 header，每次都可能重复传输几百到几千的字节，尤其在携带 cookie 的情况下\n\nHTTP/2 使用 HPACK 算法来压缩 HTTP 头部，三种压缩方式：\n\n- 静态字典\n- 动态字典\n- Huffman 压缩算法\n\n静态字典就是预先定义了一些头部，这些头部 + 取值对一个一个数字，发送时直接使用数字就可以。\n\n动态字典是在请求过程中维护的一张表，将存储的 header 字段与索引值相关联，类似于静态表。\n\n![编码过程](http://oss.xiefeng.tech/img/20210402183229.png)\n\n## 服务器推送\n\nHTTP/2 的服务器推送是指服务器提前将资源推送至浏览器缓存，所以推送是基于已发送的请求。\n\n例如：浏览器在请求 HTML 页面时，服务器在响应 HTML 文件的同时主动推送页面所需的 CSS 文件。\n\n实现服务器推送的方式：\n\n- 推送资源必须对应一个请求（未来的请求）\n- 请求信息由服务器端 PUSH_PROMISE 帧发送\n- 推送在偶数 ID 的 STREAM 中发送\n\nPUSH_PROMISE 帧的作用是通知客户端服务器**即将**推送一个资源，这个资源对应未来的一个请求，请先缓存下来\n\nPUSH_PROMISE 帧中包含该资源对应的请求信息，未来的这个请求请求时直接使用缓存即可\n\n当然了资源会在另一个流中推送过来，并且这个推送资源的流和前一个流可以是并发的，而且 PUSH_PROMISE 帧只有服务器才能发送\n\n![](https://oss.xiefeng.tech/images/20210923173004.png)\n\n# HTTP/3\n\n## HTTP/2 缺点\n\n- 基于 TCP 的 h2c 协议需要先进行三次握手，基于 TLS 的 h2 协议需要进行六次握手\n\n- TCP 的队头阻塞问题\n\nHTTP/2 基于 TCP 且每个请求会复用 TCP，流虽然是并发发送的，但是 TCP 是需要保证资源的按序到达，一旦前面的一个流在网络中丢包了，就会阻塞后面所有的流。\n\n![](https://oss.xiefeng.tech/images/20210923173536.png)\n\n## QUIC\n\nQUIC是由 Google 公开，提高了目前使用 TCP 的面向连接的网络应用的性能，基于 UDP。\n\nQUIC 严格来说运行在 HTTP 协议之下，主要就是基于 UDP 实现了可靠的报文传输。\n\n![](http://oss.xiefeng.tech/img/20210402185101.png)\n\nHTTP/3 指的是运行在 QUIC 协议之上的 HTTP\n\n- TLS3 升级成了最新的 1.3 版本，握手次数减少\n- 允许客户端更换 IP 地址、端口后，仍然可以复用前连接\n- 基于 UDP，不存在队头阻塞问题\n\n","meta":{"size":10545,"birthTime":1663496641442.1204,"updateTime":1663496641442.3496}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["计算机网络","应用层","HTTP2"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
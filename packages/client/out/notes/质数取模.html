<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>质数取模 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">质数取模</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><p>质数取模，其实是利用了同余的概念：当元素是个有规律的等差数列时，并且和基数（数组大小）最大公约数不为1时，就会造成哈希映射时冲突变高（数组某些位置永远不会有值）。比如数列0,6,12,18,24,30...，</p>
<ul>
<li>base为10，取模(0,6,2,8,4,0...)后，放入哈希表中位置将只能在0,2,4,6,8这几个数组位置上；</li>
<li>但我们如果把base取7（数组大小甚至比10小），同样数列取模后(0,6,5,4,3,2,1,0,...)，可以分布在哈希表中的0,1,2,3,4,5,6所有位置上；</li>
</ul>
<p>后续：若x和y的最大公约为z，x和y的最小公倍数就为(x<em>y)/z，很明显，若z为1，也就是俩数的最大公约数为1的时候，那么俩数的最小公倍数就为x</em>y。</p>
<p>那么当一个数为质数时，除了其自身的倍数外，其余数和其的最大公约数都将是1，这时，步长选任何数（除了倍数）都可以满足桶的均匀分布。</p>
<p>所以，以取模计算哈希值在桶中的位置是，用一个质数当作基数时可以使得哈希表中每个位置都“有用武之地”。</p>
<p>Hash表为什么需要使用mod素数？</p>
<ol>
<li>从素数定理出发，我们可以知道素数有如下性质 <em>素数定理：在初等数学中有一个基本定理，任意一个大于1的自然数，要么本身就是质数，要么可以分解为几个质数之积，这种分解本身，具有唯一性</em></li>
<li>在知道素数的性质后，回过头来看Hash表，我们将元素放在Hash表当中，需要解决的一个问题就是尽量解决冲突。</li>
<li><a href="https://blog.csdn.net/zhishengqianjun/article/details/79087525">参考blog</a>给出了一份实验，结论表明：模数的因子会影响数列的冲突，而且因子越多，冲突的可能性就越大。而素数的因子恰好只有1和其本身,就非常适合用于解决冲突。
比如 2 4 6 8 10 12这6个数，如果对 6 取余 得到 2 4 0 2 4 0 只会得到3种HASH值，6的因子有1，2，6。冲突会很多。如果对 7 取余 得到 2 4 6 1 3 5 得到6种HASH值，而7的因子只有1，7。</li>
<li>由3可知，即使1的因子最小，但是在实际中并不用，因为mod1相当于不解决冲突。而初始化的的数组就会非常大。</li>
</ol>
<p>Hash的用途很多，我们在使用Ngnix做负载均衡的时候，同样用的也是Hash的方式。总的来说，要是数据分布均匀一些，在这种时候就可以考虑使用Hash的方式对数据进行处理。</p><div><a href="/notes">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"质数取模","article":{"title":"质数取模","content":"质数取模，其实是利用了同余的概念：当元素是个有规律的等差数列时，并且和基数（数组大小）最大公约数不为1时，就会造成哈希映射时冲突变高（数组某些位置永远不会有值）。比如数列0,6,12,18,24,30...，\n\n- base为10，取模(0,6,2,8,4,0...)后，放入哈希表中位置将只能在0,2,4,6,8这几个数组位置上；\n- 但我们如果把base取7（数组大小甚至比10小），同样数列取模后(0,6,5,4,3,2,1,0,...)，可以分布在哈希表中的0,1,2,3,4,5,6所有位置上；\n\n后续：若x和y的最大公约为z，x和y的最小公倍数就为(x*y)/z，很明显，若z为1，也就是俩数的最大公约数为1的时候，那么俩数的最小公倍数就为x*y。\n\n那么当一个数为质数时，除了其自身的倍数外，其余数和其的最大公约数都将是1，这时，步长选任何数（除了倍数）都可以满足桶的均匀分布。\n\n所以，以取模计算哈希值在桶中的位置是，用一个质数当作基数时可以使得哈希表中每个位置都“有用武之地”。\n\n\n\n\n\nHash表为什么需要使用mod素数？\n\n1. 从素数定理出发，我们可以知道素数有如下性质 *素数定理：在初等数学中有一个基本定理，任意一个大于1的自然数，要么本身就是质数，要么可以分解为几个质数之积，这种分解本身，具有唯一性*\n2. 在知道素数的性质后，回过头来看Hash表，我们将元素放在Hash表当中，需要解决的一个问题就是尽量解决冲突。\n3. [参考blog](https://blog.csdn.net/zhishengqianjun/article/details/79087525)给出了一份实验，结论表明：模数的因子会影响数列的冲突，而且因子越多，冲突的可能性就越大。而素数的因子恰好只有1和其本身,就非常适合用于解决冲突。\n   比如 2 4 6 8 10 12这6个数，如果对 6 取余 得到 2 4 0 2 4 0 只会得到3种HASH值，6的因子有1，2，6。冲突会很多。如果对 7 取余 得到 2 4 6 1 3 5 得到6种HASH值，而7的因子只有1，7。\n4. 由3可知，即使1的因子最小，但是在实际中并不用，因为mod1相当于不解决冲突。而初始化的的数组就会非常大。\n\nHash的用途很多，我们在使用Ngnix做负载均衡的时候，同样用的也是Hash的方式。总的来说，要是数据分布均匀一些，在这种时候就可以考虑使用Hash的方式对数据进行处理。","meta":{"size":2459,"birthTime":1663496641490.4595,"updateTime":1663496641492.6907}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["质数取模"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
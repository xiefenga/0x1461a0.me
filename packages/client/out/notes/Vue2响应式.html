<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>Vue2响应式 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#Observer" data-target-id="h2-Observer-0">Observer</a></li><li><a href="#Dep" data-target-id="h2-Dep-1">Dep</a></li><li><a href="#Watcher" data-target-id="h2-Watcher-2">Watcher</a></li><li><a href="#Scheduler" data-target-id="h2-Scheduler-3">Scheduler</a></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">Vue2响应式</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h2>Observer</h2>
<p>让一个对象变成响应式数据只需要调用 <code>observe</code> 方法即可，当然了只有 <code>object</code> 类型的数据可以实现响应式</p>
<p>该方法的核心逻辑十分简单：</p>
<pre><code class="language-typescript">function observe (value: any): Observer | void {
  if (!isObject(value)) {
    return
  }
  let ob: Observer | void
  if (hasOwn(value, &#x27;__ob__&#x27;) &amp;&amp; value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (Array.isArray(value) || isPlainObject(value)) {
    ob = new Observer(value)
  }
  return ob
}
</code></pre>
<p>从 observe 方法可以看出来 vue2 只支持数组和普通对象的响应式，所以 <code>Set</code> 和 <code>Map</code> 在 vue2 中是没有响应式的</p>
<p>observe 方法中 <code>Observer</code> 类的作用就是关联每一个需要被观察的对象，并劫持其所有属性的 <code>getter</code> 和 <code>setter</code></p>
<p><img src="https://oss.xiefeng.tech/images/20210928091028.png" alt=""/></p>
<p>vue2 中响应式的特点：</p>
<ol>
<li>数组中为原始值的项不具有响应式，但是一些原型方法是具有响应式的</li>
<li>对象中所有的属性都具有响应式，但是新增的属性缺少响应式</li>
</ol>
<p>实现响应式需要 <code>new</code> 一个 <code>Observer</code> 的实例，所以在构造函数中对数组和对象进行了区别对待</p>
<p>实现起来也非常简单：对数组的每一项调用 <code>observe</code> 方法，对象则调用劫持 <code>getter</code> 和 <code>setter</code> 的逻辑（<code>defineReactive</code> 方法）</p>
<pre><code class="language-typescript">/**
 * Walk through all properties and convert them into getter/setters. 
 */
function walk (obj: Object) {
  const keys = Object.keys(obj)
  for (let i = 0; i &lt; keys.length; i++) {
    defineReactive(obj, keys[i])
  }
}

/**
 * Observe a list of Array items.
 */
function observeArray (items: Array&lt;any&gt;) {
  for (let i = 0, l = items.length; i &lt; l; i++) {
    observe(items[i])
  }
}
</code></pre>
<p>为了让数组的原型方法具有响应式，array 模块导出了一个具有响应式数组方法的 <code>arrayMethods</code> 对象</p>
<p>主要的实现思路是通过 <code>Object.create</code> 使得  <code>arrayMethods</code> 继承自数组的原型，重写的方法首先调用原始的方法，接着分发依赖</p>
<p>比较麻烦的是如何让已存在的数组生效，这就涉及到了 JavaScript 中继承的问题：怎么让一个已经存在的对象继承自另一个对象？</p>
<p>JavaScript 通过内部属性 <code>[[Prototype]]</code> 形成的原型链实现继承，通过修改这个属性可以很简单的修改继承关系</p>
<p>ES6 提供了 <code>Object.setPrototypeOf</code> 可以实现修改隐式原型的需求，但是 vue2 是基于 ES5 实现的，没有办法通过标准的方法进行修改</p>
<p>所以 vue2 只能针对实现了 <code>__proto__</code> 和未实现 <code>__proto__</code> 的浏览器分别执行不同的操作：</p>
<ul>
<li>对于实现了 <code>__proto__</code> 的浏览器直接修改该数组的 <code>__proto__</code> 属性让数组继承自 arrayMethods</li>
<li>未实现 <code>__proto__</code> 的浏览器则将 arrayMethods 的那些方法直接定义到数组身上。</li>
</ul>
<p><img src="https://oss.xiefeng.tech/images/20210906205433.png" alt=""/></p>
<h2>Dep</h2>
<p>无论是 <code>defineReactive</code>，<code>set</code>、<code>del</code> 还是数组被重写的原型方法，都需要解决依赖收集和依赖分发的问题</p>
<p>vue2 中使用 Dep 来解决这个问题，Dep 的含义是 Dependency，表示依赖的意思。</p>
<p>vue2 会为响应式对象中的每个具有响应式的属性、对象本身创建一个 Dep 实例。</p>
<p>每个 Dep 实例需要做以下两件事：</p>
<ul>
<li>记录依赖：是谁（函数）在用我对应的数据</li>
<li>派发更新：我对应的数据变了，要通知那些用到数据的函数进行更新</li>
</ul>
<p>在 <code>defineReactive</code> 中利用闭包创建了一个 dep 实例，并且在通过 <code>defineProperty</code> 添加属性描述符时：</p>
<ul>
<li>在 get 中使用 <code>dep.depend()</code> 收集依赖</li>
<li>在 set 中使用 <code>dep.notify()</code> 派发更新</li>
</ul>
<p><img src="http://oss.xiefeng.tech/img/20210319212645.png" alt=""/></p>
<h2>Watcher</h2>
<p>dep 想要获取到当前的正在运行的函数，则需要一个全局的变量来存储正在运行的函数</p>
<p>所以当执行某个函数之前就需要修改该变量，而函数本身是不知道 vue 所做的这些所以也不会去设置该变量</p>
<p>vue 通过一种巧妙的办法来解决这个问题，我们不要直接执行函数，而是把函数交给一个叫做 watcher 的东西去执行。</p>
<p>响应式的本质就是：数据发生了变化就去运行一些函数。vue 中这函数我们是知道的，总共就三类：render、computed、watch。</p>
<p>所以这些函数在初始化的时候都创建一个 Watcher 实例，最后是通过这个实例去执行原本的函数</p>
<p>所以所谓的依赖收集就是收集这些 Watcher 实例，而分发依赖则是让这些 Watcher 实例执行原本的函数</p>
<p><img src="http://oss.xiefeng.tech/img/20210319210527.png" alt=""/></p>
<p>具体的做法：</p>
<ol>
<li>vue 会为每一个响应式数据都创建一个 Dep 实例，每个依赖响应式数据的函数都对应一个 watcher</li>
<li>每一个 dep 实例都具有一个属性 subs 记录该 dep 对应的响应式数据被依赖的函数对应的 watcher</li>
<li><code>Dep.target</code> 在全局用来记录正在执行的 watcher 实例</li>
<li>当用到响应时数据时，函数是通过 Watcher 实例执行，在执行前将 Dep.target 设为自己</li>
<li>当用到响应时数据时会调用 <code>dep.depend</code> 就会将现在这个 watcher 加入到 subs 中，也就是所谓的依赖记录</li>
<li>当响应时数据发生改变，会运行 setter，从而运行 <code>dp.notify</code> 派发更新</li>
</ol>
<h2>Scheduler</h2>
<p>Watcher 实例具有两个方法：run 和 update，其中 run 方法，就是运行和 watcher 对应的函数</p>
<p><code>dp.notify</code> 派发更新运行的是每一个 watcher 的 update 方法，该方法把自己交给一个叫调度器的东西，让调度器来调度自己的运行</p>
<pre><code class="language-typescript">update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true
  } else if (this.sync) {
    this.run()
  } else {
    queueWatcher(this)
  }
}
</code></pre>
<p>调度器通过 scheduler 模块实现，该模块维护一个执行队列，该队列中同一个 watcher 仅会存在一次</p>
<p>scheduler 模块具有一个 <code>flushSchedulerQueue</code> 函数，用于清空执行队列，该函数会被传递给 next-tick 模块中 nextTick 函数。</p>
<p>next-tick 模块用于执行一些异步的微任务，该模块维护了一个任务队列，nextTick 方法会将需要执行的任务放入为微队列中</p>
<p>nextTick 函数通过 <code>$nextTick</code> 暴露给我们，如果在数据更新操作后使用 nextTick 和获取更新后的 DOM</p>
<p><img src="http://oss.xiefeng.tech/img/20210319215147.png" alt=""/></p><div><a href="/notes">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"Vue2响应式","article":{"title":"Vue2响应式","content":"## Observer\n\n让一个对象变成响应式数据只需要调用 `observe` 方法即可，当然了只有 `object` 类型的数据可以实现响应式\n\n该方法的核心逻辑十分简单：\n\n```typescript\nfunction observe (value: any): Observer | void {\n  if (!isObject(value)) {\n    return\n  }\n  let ob: Observer | void\n  if (hasOwn(value, '__ob__') \u0026\u0026 value.__ob__ instanceof Observer) {\n    ob = value.__ob__\n  } else if (Array.isArray(value) || isPlainObject(value)) {\n    ob = new Observer(value)\n  }\n  return ob\n}\n```\n\n从 observe 方法可以看出来 vue2 只支持数组和普通对象的响应式，所以 `Set` 和 `Map` 在 vue2 中是没有响应式的\n\nobserve 方法中 `Observer` 类的作用就是关联每一个需要被观察的对象，并劫持其所有属性的 `getter` 和 `setter`\n\n![](https://oss.xiefeng.tech/images/20210928091028.png)\n\nvue2 中响应式的特点：\n\n1. 数组中为原始值的项不具有响应式，但是一些原型方法是具有响应式的\n2. 对象中所有的属性都具有响应式，但是新增的属性缺少响应式\n\n实现响应式需要 `new` 一个 `Observer` 的实例，所以在构造函数中对数组和对象进行了区别对待\n\n实现起来也非常简单：对数组的每一项调用 `observe` 方法，对象则调用劫持 `getter` 和 `setter` 的逻辑（`defineReactive` 方法）\n\n```typescript\n/**\n * Walk through all properties and convert them into getter/setters. \n */\nfunction walk (obj: Object) {\n  const keys = Object.keys(obj)\n  for (let i = 0; i \u003c keys.length; i++) {\n    defineReactive(obj, keys[i])\n  }\n}\n\n/**\n * Observe a list of Array items.\n */\nfunction observeArray (items: Array\u003cany\u003e) {\n  for (let i = 0, l = items.length; i \u003c l; i++) {\n    observe(items[i])\n  }\n}\n```\n\n为了让数组的原型方法具有响应式，array 模块导出了一个具有响应式数组方法的 `arrayMethods` 对象\n\n主要的实现思路是通过 `Object.create` 使得  `arrayMethods` 继承自数组的原型，重写的方法首先调用原始的方法，接着分发依赖\n\n比较麻烦的是如何让已存在的数组生效，这就涉及到了 JavaScript 中继承的问题：怎么让一个已经存在的对象继承自另一个对象？\n\nJavaScript 通过内部属性 `[[Prototype]]` 形成的原型链实现继承，通过修改这个属性可以很简单的修改继承关系\n\nES6 提供了 `Object.setPrototypeOf` 可以实现修改隐式原型的需求，但是 vue2 是基于 ES5 实现的，没有办法通过标准的方法进行修改\n\n所以 vue2 只能针对实现了 `__proto__` 和未实现 `__proto__` 的浏览器分别执行不同的操作：\n\n- 对于实现了 `__proto__` 的浏览器直接修改该数组的 `__proto__` 属性让数组继承自 arrayMethods\n- 未实现 `__proto__` 的浏览器则将 arrayMethods 的那些方法直接定义到数组身上。\n\n![](https://oss.xiefeng.tech/images/20210906205433.png)\n\n## Dep\n\n无论是 `defineReactive`，`set`、`del` 还是数组被重写的原型方法，都需要解决依赖收集和依赖分发的问题\n\nvue2 中使用 Dep 来解决这个问题，Dep 的含义是 Dependency，表示依赖的意思。\n\nvue2 会为响应式对象中的每个具有响应式的属性、对象本身创建一个 Dep 实例。\n\n每个 Dep 实例需要做以下两件事：\n\n- 记录依赖：是谁（函数）在用我对应的数据\n- 派发更新：我对应的数据变了，要通知那些用到数据的函数进行更新\n\n在 `defineReactive` 中利用闭包创建了一个 dep 实例，并且在通过 `defineProperty` 添加属性描述符时：\n\n- 在 get 中使用 `dep.depend()` 收集依赖\n- 在 set 中使用 `dep.notify()` 派发更新\n\n![](http://oss.xiefeng.tech/img/20210319212645.png)\n\n## Watcher\n\ndep 想要获取到当前的正在运行的函数，则需要一个全局的变量来存储正在运行的函数\n\n所以当执行某个函数之前就需要修改该变量，而函数本身是不知道 vue 所做的这些所以也不会去设置该变量\n\nvue 通过一种巧妙的办法来解决这个问题，我们不要直接执行函数，而是把函数交给一个叫做 watcher 的东西去执行。\n\n响应式的本质就是：数据发生了变化就去运行一些函数。vue 中这函数我们是知道的，总共就三类：render、computed、watch。\n\n所以这些函数在初始化的时候都创建一个 Watcher 实例，最后是通过这个实例去执行原本的函数\n\n所以所谓的依赖收集就是收集这些 Watcher 实例，而分发依赖则是让这些 Watcher 实例执行原本的函数\n\n![](http://oss.xiefeng.tech/img/20210319210527.png)\n\n具体的做法：\n\n1. vue 会为每一个响应式数据都创建一个 Dep 实例，每个依赖响应式数据的函数都对应一个 watcher\n2. 每一个 dep 实例都具有一个属性 subs 记录该 dep 对应的响应式数据被依赖的函数对应的 watcher\n3. `Dep.target` 在全局用来记录正在执行的 watcher 实例\n4. 当用到响应时数据时，函数是通过 Watcher 实例执行，在执行前将 Dep.target 设为自己\n5. 当用到响应时数据时会调用 `dep.depend` 就会将现在这个 watcher 加入到 subs 中，也就是所谓的依赖记录\n6. 当响应时数据发生改变，会运行 setter，从而运行 `dp.notify` 派发更新\n\n## Scheduler\n\nWatcher 实例具有两个方法：run 和 update，其中 run 方法，就是运行和 watcher 对应的函数\n\n`dp.notify` 派发更新运行的是每一个 watcher 的 update 方法，该方法把自己交给一个叫调度器的东西，让调度器来调度自己的运行\n\n```typescript\nupdate () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true\n  } else if (this.sync) {\n    this.run()\n  } else {\n    queueWatcher(this)\n  }\n}\n```\n\n调度器通过 scheduler 模块实现，该模块维护一个执行队列，该队列中同一个 watcher 仅会存在一次\n\nscheduler 模块具有一个 `flushSchedulerQueue` 函数，用于清空执行队列，该函数会被传递给 next-tick 模块中 nextTick 函数。\n\nnext-tick 模块用于执行一些异步的微任务，该模块维护了一个任务队列，nextTick 方法会将需要执行的任务放入为微队列中\n\nnextTick 函数通过 `$nextTick` 暴露给我们，如果在数据更新操作后使用 nextTick 和获取更新后的 DOM\n\n![](http://oss.xiefeng.tech/img/20210319215147.png)\n\n\n\n","meta":{"size":6415,"birthTime":1663496641418.4814,"updateTime":1663496641418.666}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["Vue2响应式"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
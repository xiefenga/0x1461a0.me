<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>多线程 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#消息传递" data-target-id="h2-消息传递-0">消息传递</a><ul><li><a href="#发送端" data-target-id="h3-发送端-0">发送端</a></li><li><a href="#接收端" data-target-id="h3-接收端-1">接收端</a></li><li><a href="#消息通道" data-target-id="h3-消息通道-2">消息通道</a></li><li><a href="#关闭通道" data-target-id="h3-关闭通道-3">关闭通道</a></li></ul></li><li><a href="#共享内存" data-target-id="h2-共享内存-1">共享内存</a></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">多线程</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h2>消息传递</h2>
<p><strong>消息传递</strong>是一个日益流行的确保安全并发的方式，Rust 在标准库里提供了 <code>channel</code> 来实现消息传递</p>
<p>标准库提供了 <code>std::sync::mpsc</code> 创建 <code>channel</code></p>
<pre><code class="language-rust">use std::sync::mpsc;
use std::thread;

let (tx, rx) = mpsc::channel();

thread::spawn(move || tx.send(1).unwrap());

println!(&quot;receive {}&quot;, rx.recv().unwrap());
</code></pre>
<p><code>mpsc</code> 代表<strong>多个生产者，单个消费者</strong>，即 <em>multiple producer, single consumer</em></p>
<p>所以标准库实现的信道可以有多个<strong>发送</strong>端，但只能有一个消费这些值的<strong>接收</strong>端</p>
<p><code>mpsc::channel</code> 返回一个元组：<code>(发送端，接收端)</code></p>
<p>历史原因，<code>tx</code> 和 <code>rx</code> 通常作为 <strong>发送者</strong>（<em>transmitter</em>）和 <strong>接收者</strong>（<em>receiver</em>）的缩写</p>
<h3>发送端</h3>
<p>发送端通过 <code>send</code> 方法发送数据，发送端类型为 <code>mpsc::Sender&lt;T&gt;</code>，该通道只能传递对应类型的值</p>
<p><code>send</code>方法返回一个 <code>Result&lt;T,E&gt;</code>，说明它有可能返回一个错误</p>
<p>例如接收者被 <code>drop</code> 导致了没有接收端，此时继续发送毫无意义，返回一个错误最为合适</p>
<pre><code class="language-rust">let (tx, rx) = mpsc::channel();
let tx1 = tx.clone();

thread::spawn(move || tx.send(String::from(&quot;hi from tx&quot;)).unwrap());

thread::spawn(move || tx1.send(String::from(&quot;hi from tx1&quot;)).unwrap());
</code></pre>
<h3>接收端</h3>
<p>接收端有两个接收的方法：<code>recv</code> 和 <code>try_recv</code></p>
<p><code>try_recv</code> 尝试接收一次消息，该方法并<strong>不会阻塞线程</strong>，当通道中没有消息时，它会立刻返回一个错误</p>
<pre><code class="language-rust">let (tx, rx) = mpsc::channel();

thread::spawn(move || tx.send(1).unwrap());

println!(&quot;receive {:?}&quot;, rx.try_recv()); // receive Err(Empty)
</code></pre>
<p><code>recv</code> 方法会<strong>阻塞当前线程</strong>，直到读取到值或者通道被关闭</p>
<p><code>recv</code> 也返回一个<code>Result&lt;T, E&gt;</code>，当所有发送端都 <code>drop</code> 了就会返回 <code>Err</code> 表明不会再有新消息了</p>
<p>可以使用 <code>for</code> 循环<strong>阻塞</strong>的从 <code>rx</code> <strong>迭代器</strong>中接收消息，当收到错误时结束循环</p>
<p>需要注意的是只有当所有的发送端都 <code>drop</code> 之后才会收到错误结束循环</p>
<pre><code class="language-rust">let (tx, rx) = mpsc::channel();
let txs = [tx.clone(), tx.clone()];

// important
drop(tx);

for (i, tx) in txs.into_iter().enumerate() {
  thread::spawn(move || tx.send(format!(&quot;hello from tx{}&quot;, i)).unwrap());
}

for received in rx {
  println!(&quot;Got: {}&quot;, received);
}
</code></pre>
<h3>消息通道</h3>
<p>标准库的 <code>mpsc</code> 通道分为两种类型：同步和异步</p>
<p><code>mpsc::channel</code> 创建的是异步通道，其含义为：发送端不会被接收端阻塞</p>
<p>同步通道通过 <code>mpsc::sync_channel</code> 创建，特点是**发送消息是阻塞的，在消息被接收后才解除阻塞 **</p>
<pre><code class="language-rust">let (tx, rx)= mpsc::sync_channel(0);

let handle = thread::spawn(move || {
  println!(&quot;发送之前&quot;);
  tx.send(1).unwrap();
  println!(&quot;发送之后&quot;);
});

println!(&quot;睡眠之前&quot;);
thread::sleep(Duration::from_secs(3));
println!(&quot;睡眠之后&quot;);

println!(&quot;receive {}&quot;, rx.recv().unwrap());
handle.join().unwrap();
</code></pre>
<p>运行结果为：</p>
<pre><code>睡眠之前
发送之前
睡眠之后
receive 1
发送之后
</code></pre>
<p><code>mpsc::sync_channel</code> 需要传递一个参数，用来指定同步通道的消息缓存条数</p>
<p>当消息缓冲队列满了后，新的消息发送将被阻塞</p>
<p><code>mpsc::channel</code> 相当于 <code>mpsc::sync_channel(infinity)</code>，其缓存大小限取决于内存大小</p>
<p>通道中消息的发送顺序和接收顺序是一致的，满足<code>FIFO</code>原则(先进先出)</p>
<h3>关闭通道</h3>
<p>当所有发送端被 <code>drop</code> 或者所有接收端被 <code>drop</code> 后，通道会自动关闭</p>
<p>当通道关闭后，发送消息或接收消息将会返回错误</p>
<h2>共享内存</h2>
<p><strong>互斥器</strong>（<em>mutex</em>）是 <em>mutual exclusion</em> 的缩写，也就是说，任意时刻，其只允许一个线程访问某些数据。为了访问互斥器中的数据，线程首先需要通过获取互斥器的 <strong>锁</strong>（<em>lock</em>）来表明其希望访问数据。锁是一个作为互斥器一部分的数据结构，它记录谁有数据的排他访问权。因此，我们描述互斥器为通过锁系统 <strong>保护</strong>（<em>guarding</em>）其数据。</p>
<p>使用 <code>lock</code> 方法获取锁，以访问互斥器中的数据。这个调用会阻塞当前线程，直到我们拥有锁为止</p>
<p>如果另一个线程拥有锁，并且那个线程 panic 了，则 <code>lock</code> 调用会失败。在这种情况下，没人能够再获取锁，所以这里选择 <code>unwrap</code> 并在遇到这种情况时使线程 panic。</p>
<p><code>Mutex&lt;T&gt;</code> 是一个智能指针。更准确的说，<code>lock</code> 调用 <strong>返回</strong> 一个叫做 <code>MutexGuard</code> 的智能指针。这个智能指针实现了 <code>Deref</code> 来指向其内部数据；其也提供了一个 <code>Drop</code> 实现当 <code>MutexGuard</code> 离开作用域时自动释放锁，为此，我们不会冒忘记释放锁并阻塞互斥器为其它线程所用的风险，因为锁的释放是自动发生的。</p><div><a href="/notes/rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"多线程","article":{"title":"多线程","content":"## 消息传递\n\n**消息传递**是一个日益流行的确保安全并发的方式，Rust 在标准库里提供了 `channel` 来实现消息传递\n\n标准库提供了 `std::sync::mpsc` 创建 `channel` \n\n```rust\nuse std::sync::mpsc;\nuse std::thread;\n\nlet (tx, rx) = mpsc::channel();\n\nthread::spawn(move || tx.send(1).unwrap());\n\nprintln!(\"receive {}\", rx.recv().unwrap());\n```\n\n`mpsc` 代表**多个生产者，单个消费者**，即 *multiple producer, single consumer* \n\n所以标准库实现的信道可以有多个**发送**端，但只能有一个消费这些值的**接收**端\n\n`mpsc::channel` 返回一个元组：`(发送端，接收端)` \n\n历史原因，`tx` 和 `rx` 通常作为 **发送者**（*transmitter*）和 **接收者**（*receiver*）的缩写\n\n### 发送端\n\n发送端通过 `send` 方法发送数据，发送端类型为 `mpsc::Sender\u003cT\u003e`，该通道只能传递对应类型的值\n\n`send`方法返回一个 `Result\u003cT,E\u003e`，说明它有可能返回一个错误\n\n例如接收者被 `drop` 导致了没有接收端，此时继续发送毫无意义，返回一个错误最为合适\n\n```rust\nlet (tx, rx) = mpsc::channel();\nlet tx1 = tx.clone();\n\nthread::spawn(move || tx.send(String::from(\"hi from tx\")).unwrap());\n\nthread::spawn(move || tx1.send(String::from(\"hi from tx1\")).unwrap());\n```\n\n### 接收端\n\n接收端有两个接收的方法：`recv` 和 `try_recv` \n\n`try_recv` 尝试接收一次消息，该方法并**不会阻塞线程**，当通道中没有消息时，它会立刻返回一个错误\n\n```rust\nlet (tx, rx) = mpsc::channel();\n\nthread::spawn(move || tx.send(1).unwrap());\n\nprintln!(\"receive {:?}\", rx.try_recv()); // receive Err(Empty)\n```\n\n`recv` 方法会**阻塞当前线程**，直到读取到值或者通道被关闭\n\n`recv` 也返回一个`Result\u003cT, E\u003e`，当所有发送端都 `drop` 了就会返回 `Err` 表明不会再有新消息了\n\n可以使用 `for` 循环**阻塞**的从 `rx` **迭代器**中接收消息，当收到错误时结束循环\n\n需要注意的是只有当所有的发送端都 `drop` 之后才会收到错误结束循环\n\n```rust\nlet (tx, rx) = mpsc::channel();\nlet txs = [tx.clone(), tx.clone()];\n\n// important\ndrop(tx);\n\nfor (i, tx) in txs.into_iter().enumerate() {\n  thread::spawn(move || tx.send(format!(\"hello from tx{}\", i)).unwrap());\n}\n\nfor received in rx {\n  println!(\"Got: {}\", received);\n}\n```\n\n### 消息通道\n\n标准库的 `mpsc` 通道分为两种类型：同步和异步\n\n`mpsc::channel` 创建的是异步通道，其含义为：发送端不会被接收端阻塞\n\n同步通道通过 `mpsc::sync_channel` 创建，特点是**发送消息是阻塞的，在消息被接收后才解除阻塞 **\n\n```rust\nlet (tx, rx)= mpsc::sync_channel(0);\n\nlet handle = thread::spawn(move || {\n  println!(\"发送之前\");\n  tx.send(1).unwrap();\n  println!(\"发送之后\");\n});\n\nprintln!(\"睡眠之前\");\nthread::sleep(Duration::from_secs(3));\nprintln!(\"睡眠之后\");\n\nprintln!(\"receive {}\", rx.recv().unwrap());\nhandle.join().unwrap();\n```\n\n运行结果为：\n\n```\n睡眠之前\n发送之前\n睡眠之后\nreceive 1\n发送之后\n```\n\n`mpsc::sync_channel` 需要传递一个参数，用来指定同步通道的消息缓存条数\n\n当消息缓冲队列满了后，新的消息发送将被阻塞\n\n`mpsc::channel` 相当于 `mpsc::sync_channel(infinity)`，其缓存大小限取决于内存大小\n\n通道中消息的发送顺序和接收顺序是一致的，满足`FIFO`原则(先进先出)\n\n### 关闭通道\n\n当所有发送端被 `drop` 或者所有接收端被 `drop` 后，通道会自动关闭\n\n当通道关闭后，发送消息或接收消息将会返回错误\n\n## 共享内存\n\n**互斥器**（*mutex*）是 *mutual exclusion* 的缩写，也就是说，任意时刻，其只允许一个线程访问某些数据。为了访问互斥器中的数据，线程首先需要通过获取互斥器的 **锁**（*lock*）来表明其希望访问数据。锁是一个作为互斥器一部分的数据结构，它记录谁有数据的排他访问权。因此，我们描述互斥器为通过锁系统 **保护**（*guarding*）其数据。\n\n\n\n使用 `lock` 方法获取锁，以访问互斥器中的数据。这个调用会阻塞当前线程，直到我们拥有锁为止\n\n如果另一个线程拥有锁，并且那个线程 panic 了，则 `lock` 调用会失败。在这种情况下，没人能够再获取锁，所以这里选择 `unwrap` 并在遇到这种情况时使线程 panic。\n\n\n\n`Mutex\u003cT\u003e` 是一个智能指针。更准确的说，`lock` 调用 **返回** 一个叫做 `MutexGuard` 的智能指针。这个智能指针实现了 `Deref` 来指向其内部数据；其也提供了一个 `Drop` 实现当 `MutexGuard` 离开作用域时自动释放锁，为此，我们不会冒忘记释放锁并阻塞互斥器为其它线程所用的风险，因为锁的释放是自动发生的。\n\n","meta":{"size":4853,"birthTime":1663496641423.3574,"updateTime":1663496641423.5781}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["rust学习笔记","多线程"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>模块化 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#package" data-target-id="h2-package-0">package</a></li><li><a href="#crate" data-target-id="h2-crate-1">crate</a><ul><li><a href="#module" data-target-id="h3-module-0">module</a><ul><li><a href="#模块树" data-target-id="h4-模块树-0">模块树</a></li><li><a href="#路径引用" data-target-id="h4-路径引用-1">路径引用</a></li><li><a href="#可见性" data-target-id="h4-可见性-2">可见性</a></li><li><a href="#受限可见性" data-target-id="h4-受限可见性-3">受限可见性</a></li></ul></li></ul></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">模块化</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h2>package</h2>
<p>一个 package 就是一个项目，其中包含有一个 <strong>Cargo.toml</strong> 文件，就类比于一个 node 项目都会有一个 package.json 文件</p>
<p>package 中可以包含任意多个二进制 crate，但是必须至少包含一个 crate （库类型或者二进制类型）</p>
<p>通过 <code>cargo new</code> 就创建了一个 package</p>
<p>Cargo 的惯例</p>
<ol>
<li>src/main.rs 是二进制 crate 的根文件，且该 crate 名跟所属 package 相同</li>
<li>src/lib.rs 是库 crate 的根文件，且该 crate 跟 package 名称相同</li>
</ol>
<p>package 是一个项目工程，而 crate 只是一个编译单元，src/main.rs 和 src/lib.rs 都是编译单元，因此它们都是 crate</p>
<h2>crate</h2>
<p>crate 是一个独立的<strong>可编译单元</strong>，它编译后会生成一个可执行文件或者一个库</p>
<p>crate root 是 Rust 编译器编译的起始源文件，库 package 为 src/lib.rs，二进制 package 为 src/main.rs</p>
<p>crate 本质上是一个从 crate root 起始的一个模块的树形结构，编译器从 root crate 起始会生成一个可执行文件或者库</p>
<p>如果一个 package 同时拥有 src/main.rs 和 src/lib.rs，那就意味着它同时包含<strong>库 crate</strong> 和<strong>二进制 crate</strong>，并且这两个 crate 也都和 package 同名。</p>
<p>crate 分为二进制 crate 和 库 crate</p>
<p><em>src/bin</em> 下的每个文件都会被编译成一个独立的二进制 crate，通过将文件放在该目录下，一个 package 可以拥有多个二进制 crate</p>
<h3>module</h3>
<p><strong>模块</strong>让我们可以将一个 crate 中的代码进行分组，以提高可读性与重用性</p>
<p>以 <code>mod</code> 关键字定义一个模块，在模块内还可以定义其他的模块，mod 本质上就是一个命名空间用来分割不同的代码</p>
<pre><code class="language-rust">// src/lib.rs
fn demo() { }

mod ds {
  mod list { 
    fn create_list() { }
  }
  mod tree {
    fn create_tree() { }
  }
}

mod func { 
	fn compose() { }
}
</code></pre>
<h4>模块树</h4>
<p>src/main.rs 和 src/lib.rs 这两个文件的内容都分别在 crate 模块结构的根组成了一个名为 <code>crate</code> 的模块</p>
<p>文件的所有内容都在 <code>crate</code> 这个<strong>隐式模块</strong>下，相当于这文件的内容都包含在 <code>mod crate { }</code> 中</p>
<p>最终形成的这个树形结构被称为<strong>模块树</strong></p>
<pre><code class="language-rust">crate
 ├── demo
 ├── ds
 │   ├── list
 │   │    └── create_list
 │   └── tree
 │        └── create_tree
 └── func
     └── compose
</code></pre>
<h4>路径引用</h4>
<p>Rust 在模块树中找到某一项的位置有两种方式：</p>
<ul>
<li><strong>绝对路径</strong>：从 crate 根开始，以 crate 名或者字面值 <code>crate</code> 开头</li>
<li><strong>相对路径</strong>：从当前模块开始，以 <code>self</code>、<code>super</code> 或当前模块的标识符开头</li>
</ul>
<pre><code class="language-rust">// absolute
crate::ds::list::create_list(); // in src/lib.rs

package_name::ds::list::create_list(); // in src/main.rs

//  relative
ds::list::create_list() / self::ds::list::create_list(); // in src/lib.rs crate root
</code></pre>
<h4>可见性</h4>
<p>默认情况下，所有的类型都是私有化的，包括函数、方法、结构体、枚举、常量，甚至就连<strong>模块本身也是私有的</strong></p>
<p>模块的可见性仅仅是允许其它模块去引用它，想要能够访问模块内部的项，还得继续将对应的项标记为 <code>pub</code></p>
<p>Rust 中<strong>父模块完全无法访问子模块中的私有项，但是子模块却可以访问所有祖先模块的私有项</strong></p>
<p>所谓的可见指的是从模块外部能够访问模块内部，所以可见性限制的是从祖先模块级别进行的访问，兄弟/同模块之间不存在限制</p>
<pre><code class="language-rust">pub fn demo() {
  ds::tree // 无法引用 tree
}

pub mod ds {
  pub mod list {
    pub fn create_list() {
      super::tree::create_tree(); // ok
    }
  }
  mod tree {
    pub fn create_tree() {}
  }
}
</code></pre>
<p><code>super</code> 代表的是父模块为开始的引用方式，可见性也以父模块的视角（个人总结）</p>
<p>结构体和枚举的成员字段拥有完全不同的可见性</p>
<ul>
<li>将结构体设置为 <code>pub</code>，但它的所有字段依然是私有的</li>
<li>将枚举设置为 <code>pub</code>，它的所有字段也将对外可见</li>
</ul>
<h4>受限可见性</h4>
<p><code>pub(crate)</code> 或 <code>pub(in crate::a)</code> 就是限制可见性语法，限制在哪些模块可见</p>
<ul>
<li><code>pub</code> 意味着可见性无任何限制</li>
<li><code>pub(crate)</code> 表示在当前包可见</li>
<li><code>pub(self)</code> 在当前模块可见</li>
<li><code>pub(super)</code> 在父模块可见</li>
<li><code>pub(in &lt;path&gt;)</code> 表示在某个路径代表的模块中可见，其中 <code>path</code> 必须是父模块或者祖先模块</li>
</ul><div><a href="/notes/rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"模块化","article":{"title":"模块化","content":"## package\n\n一个 package 就是一个项目，其中包含有一个 **Cargo.toml** 文件，就类比于一个 node 项目都会有一个 package.json 文件\n\npackage 中可以包含任意多个二进制 crate，但是必须至少包含一个 crate （库类型或者二进制类型）\n\n通过 `cargo new` 就创建了一个 package\n\nCargo 的惯例\n\n1. src/main.rs 是二进制 crate 的根文件，且该 crate 名跟所属 package 相同\n2. src/lib.rs 是库 crate 的根文件，且该 crate 跟 package 名称相同\n\npackage 是一个项目工程，而 crate 只是一个编译单元，src/main.rs 和 src/lib.rs 都是编译单元，因此它们都是 crate\n\n## crate\n\ncrate 是一个独立的**可编译单元**，它编译后会生成一个可执行文件或者一个库\n\ncrate root 是 Rust 编译器编译的起始源文件，库 package 为 src/lib.rs，二进制 package 为 src/main.rs\n\ncrate 本质上是一个从 crate root 起始的一个模块的树形结构，编译器从 root crate 起始会生成一个可执行文件或者库\n\n如果一个 package 同时拥有 src/main.rs 和 src/lib.rs，那就意味着它同时包含**库 crate** 和**二进制 crate**，并且这两个 crate 也都和 package 同名。\n\ncrate 分为二进制 crate 和 库 crate\n\n*src/bin* 下的每个文件都会被编译成一个独立的二进制 crate，通过将文件放在该目录下，一个 package 可以拥有多个二进制 crate\n\n### module\n\n**模块**让我们可以将一个 crate 中的代码进行分组，以提高可读性与重用性\n\n以 `mod` 关键字定义一个模块，在模块内还可以定义其他的模块，mod 本质上就是一个命名空间用来分割不同的代码\n\n```rust\n// src/lib.rs\nfn demo() { }\n\nmod ds {\n  mod list { \n    fn create_list() { }\n  }\n  mod tree {\n    fn create_tree() { }\n  }\n}\n\nmod func { \n\tfn compose() { }\n}\n```\n\n#### 模块树\n\nsrc/main.rs 和 src/lib.rs 这两个文件的内容都分别在 crate 模块结构的根组成了一个名为 `crate` 的模块\n\n文件的所有内容都在 `crate` 这个**隐式模块**下，相当于这文件的内容都包含在 `mod crate { }` 中\n\n最终形成的这个树形结构被称为**模块树** \n\n```rust\ncrate\n ├── demo\n ├── ds\n │   ├── list\n │   │    └── create_list\n │   └── tree\n │        └── create_tree\n └── func\n     └── compose\n```\n\n#### 路径引用\n\nRust 在模块树中找到某一项的位置有两种方式：\n\n- **绝对路径**：从 crate 根开始，以 crate 名或者字面值 `crate` 开头\n- **相对路径**：从当前模块开始，以 `self`、`super` 或当前模块的标识符开头\n\n```rust\n// absolute\ncrate::ds::list::create_list(); // in src/lib.rs\n\npackage_name::ds::list::create_list(); // in src/main.rs\n\n//  relative\nds::list::create_list() / self::ds::list::create_list(); // in src/lib.rs crate root\n```\n\n#### 可见性\n\n默认情况下，所有的类型都是私有化的，包括函数、方法、结构体、枚举、常量，甚至就连**模块本身也是私有的** \n\n模块的可见性仅仅是允许其它模块去引用它，想要能够访问模块内部的项，还得继续将对应的项标记为 `pub` \n\nRust 中**父模块完全无法访问子模块中的私有项，但是子模块却可以访问所有祖先模块的私有项** \n\n所谓的可见指的是从模块外部能够访问模块内部，所以可见性限制的是从祖先模块级别进行的访问，兄弟/同模块之间不存在限制\n\n```rust\npub fn demo() {\n  ds::tree // 无法引用 tree\n}\n\npub mod ds {\n  pub mod list {\n    pub fn create_list() {\n      super::tree::create_tree(); // ok\n    }\n  }\n  mod tree {\n    pub fn create_tree() {}\n  }\n}\n```\n\n`super` 代表的是父模块为开始的引用方式，可见性也以父模块的视角（个人总结）\n\n结构体和枚举的成员字段拥有完全不同的可见性\n\n- 将结构体设置为 `pub`，但它的所有字段依然是私有的\n- 将枚举设置为 `pub`，它的所有字段也将对外可见\n\n#### 受限可见性\n\n`pub(crate)` 或 `pub(in crate::a)` 就是限制可见性语法，限制在哪些模块可见\n\n- `pub` 意味着可见性无任何限制\n- `pub(crate)` 表示在当前包可见\n- `pub(self)` 在当前模块可见\n- `pub(super)` 在父模块可见\n- `pub(in \u003cpath\u003e)` 表示在某个路径代表的模块中可见，其中 `path` 必须是父模块或者祖先模块","meta":{"size":4439,"birthTime":1663496641424.3618,"updateTime":1663496641424.5562}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["rust学习笔记","模块化"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
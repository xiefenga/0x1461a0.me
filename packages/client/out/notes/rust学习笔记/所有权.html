<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>所有权 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#内存分配" data-target-id="h2-内存分配-0">内存分配</a></li><li><a href="#所有权" data-target-id="h2-所有权-1">所有权</a><ul><li><a href="#Move 语义" data-target-id="h3-Move 语义-0">Move 语义</a></li><li><a href="#Copy 语义" data-target-id="h3-Copy 语义-1">Copy 语义</a></li><li><a href="#Borrow 语义" data-target-id="h3-Borrow 语义-2">Borrow 语义</a></li></ul></li><li><a href="#引用" data-target-id="h2-引用-2">引用</a><ul><li><a href="#和指针的区别" data-target-id="h3-和指针的区别-3">和指针的区别</a></li><li><a href="#引用的限制" data-target-id="h3-引用的限制-4">引用的限制</a></li></ul></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">所有权</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h2>内存分配</h2>
<p>在编译时<strong>大小未知</strong>或<strong>大小可能变化</strong>的数据都应该存储在堆上</p>
<p>入栈比在堆上分配内存要快，入栈无需搜索内存空间并且位置总是在栈顶，在堆上分配内存则需要搜寻并做记录</p>
<p>访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问进行跳转，而现代 CPU 由于 cache 的存在访问附近的内存会更加快</p>
<p>堆内存的使用场景：</p>
<ol>
<li>存放栈无法处理的内存（过大，或者长度不定，或者需要动态增长）</li>
<li>在同一个调用栈中真正需要被多个数据结构共享</li>
<li>在多个调用栈中共享</li>
</ol>
<h2>所有权</h2>
<p>rust 使用单一所有权来解决内存管理的问题</p>
<ul>
<li>一个值进行了变量绑定，这个变量被称为该值的<strong>所有者</strong></li>
<li>一个值同一时刻只能有一个所有者</li>
<li>当所有者离开作用域时，其拥有的值也被丢弃<!-- -->
<ul>
<li>栈内存被销毁</li>
<li>堆内存被释放</li>
</ul>
</li>
</ul>
<pre><code class="language-rust">{                      // s 在这里无效，它尚未声明
    let s = &quot;hello&quot;;   // 从此处起，s 是有效的
    // 使用 s
}      								// 此作用域已结束，s不再有效
</code></pre>
<p>在这种单一所有权的约束下，堆内存的生命周期和其所对应的栈的生命周期保持一致，即指向该堆内存的栈空间被销毁，该堆内存也被释放，避免内存泄露的机会。</p>
<blockquote>
<p>堆变量的生命周期不具备任意长短的灵活性，因为堆上内存的生死存亡，跟栈上的所有者牢牢绑定。而栈上内存的生命周期，又跟栈的生命周期相关，所以我们核心只需要关心调用栈的生命周期。</p>
</blockquote>
<h3>Move 语义</h3>
<p>Move 语义指的是变量赋值、参数传递、函数返回等行为，旧的所有者会把值的所有权转移给新的所有者，旧的所有者不再拥有所有权（即变量无法再使用），以保证单一所有者的约束。</p>
<pre><code class="language-rust">let x = String::from(&quot;hello&quot;);
let y = x;  // value moved here
println!(&quot;{:?}&quot;, x); // value borrowed here after move
println!(&quot;{:?}&quot;, y);
</code></pre>
<p>Move 语义本质是栈内存的<strong>浅拷贝</strong>，和 Copy 语义的行为是相同的，只不过在 Move 语义下编译器会不再允许使用所有权已被转移的变量。</p>
<p>浅拷贝：仅仅对栈上内容的进行复制</p>
<p>深拷贝：栈以及栈所指向的堆上的数据都进行复制</p>
<h3>Copy 语义</h3>
<p>Copy 语义即在发生赋值或者传参等行为时，值会自动按位拷贝，而不是进行所有权的转移</p>
<p>实现了 Copy trait 的类型在赋值时会自动使用 Copy 语义，而不是 Move 语义</p>
<pre><code class="language-rust">let x = 10;
let y = x;
println!(&quot;{x} {y}&quot;); 
</code></pre>
<p>使用 <code>drive(Copy)</code> 即可让一个类型实现 Copy trait，但是实现 Copy trait 需要先实现 Clone trait</p>
<p>rust 中 Copy trait 和 Drop trait 不能共存，保证了无法为一个在堆上分配内存的结构实现 Copy</p>
<p>要么不实现 Copy，要么不实现 Drop：</p>
<ul>
<li>不实现 Drop，会导致内存泄漏，但它不会对正确性有任何破坏（不会出现 use after free 这样的问题）</li>
<li>不实现 Copy，就只能使用 Move 语义，确保内存安全</li>
</ul>
<p>Copy trait 和 Drop trait 是互斥的，两者不能共存，当你尝试为同一种数据类型实现 Copy 时，也实现 Drop，编译器就会报错。这其实很好理解：Copy 是按位做浅拷贝，那么它会默认拷贝的数据没有需要释放的资源；而 Drop 恰恰是为了释放额外的资源而生的。</p>
<p>虽然 RawBuffer 可以实现 Copy trait，但这样一来就无法实现 Drop trait。如果程序非要这么写，会导致内存泄漏，因为该释放的堆内存没有释放。</p>
<p>但是这个操作不会破坏 Rust 的正确性保证：即便你 Copy 了 N 份 RawBuffer，由于无法实现 Drop trait，RawBuffer 指向的那同一块堆内存不会释放，所以不会出现 use after free 的内存安全问题</p>
<p>对于代码安全来说，内存泄漏危害大？还是 use after free 危害大呢？肯定是后者。Rust 的底线是内存安全，所以两害相权取其轻。</p>
<h3>Borrow 语义</h3>
<p>Borrow 语义允许一个值在所有权不发生转移的情况下被其它上下文使用，也就是只有<strong>临时使用权</strong>但没有所有权</p>
<p>Borrow 语义通过引用语法（<code>&amp;</code> 或者 <code>&amp;mut</code>）来实现</p>
<p>Rust 下的所有的引用都只是借用了“临时使用权”，并没有破坏值的单一所有权约束</p>
<h2>引用</h2>
<p><strong>引用</strong>（<em>reference</em>）就是一个指针，存储着所指向的那个值的地址，创建一个引用的行为称为<strong>借用</strong>（<em>borrowing</em>）</p>
<p>在 Rust 中“借用”和“引用”是一个概念，只不过和其他语言中引用的意义，便于区分所以提出了新概念“借用”</p>
<pre><code class="language-rust">let x = 2;
assert_eq!(std::mem::size_of_val(&amp;&amp;x), std::mem::size_of::&lt;usize&gt;());
assert_eq!(std::mem::size_of::&lt;&amp;i32&gt;(), std::mem::size_of::&lt;usize&gt;());
assert_eq!(std::mem::size_of::&lt;&amp;String&gt;(), std::mem::size_of::&lt;usize&gt;());
</code></pre>
<p>不可变引用实现了 Copy trait，可变引用没有实现 Copy trait（因为不可以同时存在多个可变引用）</p>
<pre><code class="language-rust">let mut y = 10;
let x = &amp;mut y;
let z = x; // value moved here
println!(&quot;{} {}&quot;, x, z); // value borrowed here after move
</code></pre>
<h3>和指针的区别</h3>
<p>引用和指针是一个持有内存地址的值，可以通过解引用（dereference）来访问它指向的内存地址</p>
<ul>
<li>
<p>指针理论上可以解引用到任意数据类型</p>
</li>
<li>
<p>引用的解引用访问是受限的，只能解引用到它引用数据的类型，不能用作它用</p>
</li>
</ul>
<p>即在 rust 中的引用是一个<strong>受控</strong>的<strong>指针</strong>，指向某个<strong>特定的类型</strong></p>
<p>因为如果可变引用实现了 Copy trait，那么生成一个可变引用然后把它赋值给另一个变量时，就会违背所有权规则：同一个作用域下只能有一个可变引用</p>
<h3>引用的限制</h3>
<ol>
<li>借用不能超过值的生存期</li>
<li>不可以同时存在多个活跃的可变引用</li>
<li>活跃的可变引用和不可变引用不可以同时存在</li>
<li>引用的作用域从声明的地方开始一直持续到最后一次使用为止，而不是词法作用域结束，这种能力称之为<strong>非词法作用域生命周期</strong></li>
</ol><div><a href="/notes/rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"所有权","article":{"title":"所有权","content":"## 内存分配\n\n在编译时**大小未知**或**大小可能变化**的数据都应该存储在堆上\n\n入栈比在堆上分配内存要快，入栈无需搜索内存空间并且位置总是在栈顶，在堆上分配内存则需要搜寻并做记录\n\n访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问进行跳转，而现代 CPU 由于 cache 的存在访问附近的内存会更加快\n\n堆内存的使用场景：\n\n1. 存放栈无法处理的内存（过大，或者长度不定，或者需要动态增长）\n2. 在同一个调用栈中真正需要被多个数据结构共享\n3. 在多个调用栈中共享 \n\n## 所有权\n\nrust 使用单一所有权来解决内存管理的问题\n\n- 一个值进行了变量绑定，这个变量被称为该值的**所有者** \n- 一个值同一时刻只能有一个所有者\n- 当所有者离开作用域时，其拥有的值也被丢弃\n  - 栈内存被销毁\n  - 堆内存被释放\n\n```rust\n{                      // s 在这里无效，它尚未声明\n    let s = \"hello\";   // 从此处起，s 是有效的\n    // 使用 s\n}      \t\t\t\t\t\t\t\t// 此作用域已结束，s不再有效\n```\n\n在这种单一所有权的约束下，堆内存的生命周期和其所对应的栈的生命周期保持一致，即指向该堆内存的栈空间被销毁，该堆内存也被释放，避免内存泄露的机会。\n\n\u003e 堆变量的生命周期不具备任意长短的灵活性，因为堆上内存的生死存亡，跟栈上的所有者牢牢绑定。而栈上内存的生命周期，又跟栈的生命周期相关，所以我们核心只需要关心调用栈的生命周期。\n\n### Move 语义\n\nMove 语义指的是变量赋值、参数传递、函数返回等行为，旧的所有者会把值的所有权转移给新的所有者，旧的所有者不再拥有所有权（即变量无法再使用），以保证单一所有者的约束。\n\n```rust\nlet x = String::from(\"hello\");\nlet y = x;  // value moved here\nprintln!(\"{:?}\", x); // value borrowed here after move\nprintln!(\"{:?}\", y);\n```\n\nMove 语义本质是栈内存的**浅拷贝**，和 Copy 语义的行为是相同的，只不过在 Move 语义下编译器会不再允许使用所有权已被转移的变量。\n\n浅拷贝：仅仅对栈上内容的进行复制\n\n深拷贝：栈以及栈所指向的堆上的数据都进行复制\n\n### Copy 语义\n\nCopy 语义即在发生赋值或者传参等行为时，值会自动按位拷贝，而不是进行所有权的转移\n\n实现了 Copy trait 的类型在赋值时会自动使用 Copy 语义，而不是 Move 语义\n\n```rust\nlet x = 10;\nlet y = x;\nprintln!(\"{x} {y}\"); \n```\n\n使用 `drive(Copy)` 即可让一个类型实现 Copy trait，但是实现 Copy trait 需要先实现 Clone trait\n\nrust 中 Copy trait 和 Drop trait 不能共存，保证了无法为一个在堆上分配内存的结构实现 Copy\n\n要么不实现 Copy，要么不实现 Drop：\n\n- 不实现 Drop，会导致内存泄漏，但它不会对正确性有任何破坏（不会出现 use after free 这样的问题）\n- 不实现 Copy，就只能使用 Move 语义，确保内存安全\n\n\n\nCopy trait 和 Drop trait 是互斥的，两者不能共存，当你尝试为同一种数据类型实现 Copy 时，也实现 Drop，编译器就会报错。这其实很好理解：Copy 是按位做浅拷贝，那么它会默认拷贝的数据没有需要释放的资源；而 Drop 恰恰是为了释放额外的资源而生的。\n\n虽然 RawBuffer 可以实现 Copy trait，但这样一来就无法实现 Drop trait。如果程序非要这么写，会导致内存泄漏，因为该释放的堆内存没有释放。\n\n但是这个操作不会破坏 Rust 的正确性保证：即便你 Copy 了 N 份 RawBuffer，由于无法实现 Drop trait，RawBuffer 指向的那同一块堆内存不会释放，所以不会出现 use after free 的内存安全问题\n\n\n\n对于代码安全来说，内存泄漏危害大？还是 use after free 危害大呢？肯定是后者。Rust 的底线是内存安全，所以两害相权取其轻。\n\n### Borrow 语义\n\nBorrow 语义允许一个值在所有权不发生转移的情况下被其它上下文使用，也就是只有**临时使用权**但没有所有权\n\nBorrow 语义通过引用语法（`\u0026` 或者 `\u0026mut`）来实现\n\nRust 下的所有的引用都只是借用了“临时使用权”，并没有破坏值的单一所有权约束\n\n## 引用\n\n**引用**（*reference*）就是一个指针，存储着所指向的那个值的地址，创建一个引用的行为称为**借用**（*borrowing*）\n\n在 Rust 中“借用”和“引用”是一个概念，只不过和其他语言中引用的意义，便于区分所以提出了新概念“借用”\n\n```rust\nlet x = 2;\nassert_eq!(std::mem::size_of_val(\u0026\u0026x), std::mem::size_of::\u003cusize\u003e());\nassert_eq!(std::mem::size_of::\u003c\u0026i32\u003e(), std::mem::size_of::\u003cusize\u003e());\nassert_eq!(std::mem::size_of::\u003c\u0026String\u003e(), std::mem::size_of::\u003cusize\u003e());\n```\n\n不可变引用实现了 Copy trait，可变引用没有实现 Copy trait（因为不可以同时存在多个可变引用）\n\n```rust\nlet mut y = 10;\nlet x = \u0026mut y;\nlet z = x; // value moved here\nprintln!(\"{} {}\", x, z); // value borrowed here after move\n```\n\n### 和指针的区别\n\n引用和指针是一个持有内存地址的值，可以通过解引用（dereference）来访问它指向的内存地址\n\n- 指针理论上可以解引用到任意数据类型\n\n- 引用的解引用访问是受限的，只能解引用到它引用数据的类型，不能用作它用\n\n即在 rust 中的引用是一个**受控**的**指针**，指向某个**特定的类型** \n\n因为如果可变引用实现了 Copy trait，那么生成一个可变引用然后把它赋值给另一个变量时，就会违背所有权规则：同一个作用域下只能有一个可变引用\n\n### 引用的限制\n\n1. 借用不能超过值的生存期\n2. 不可以同时存在多个活跃的可变引用\n3. 活跃的可变引用和不可变引用不可以同时存在\n4. 引用的作用域从声明的地方开始一直持续到最后一次使用为止，而不是词法作用域结束，这种能力称之为**非词法作用域生命周期** \n\n\n\n","meta":{"size":6162,"birthTime":1663496641423.6619,"updateTime":1663496641423.9763}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["rust学习笔记","所有权"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
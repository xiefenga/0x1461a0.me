<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>生命周期 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#悬垂引用" data-target-id="h2-悬垂引用-0">悬垂引用</a></li><li><a href="#借用检查器" data-target-id="h2-借用检查器-1">借用检查器</a></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">生命周期</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><p>rust 中的每一个引用都有其<strong>生命周期</strong>，也就是引用<strong>保持有效</strong>的作用域。</p>
<p>大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用泛型生命周期参数来注明他们的关系，这样就能确保运行时实际使用的引用绝对是有效的。</p>
<h2>悬垂引用</h2>
<p>生命周期的目的是为了避免<strong>悬垂引用</strong></p>
<p>悬垂引用：指针指向的内存已经被释放，但是该指针没有作任何的修改，以至于该指针仍旧指向已被回收的内存地址</p>
<p>与之对应的另一种指针是<strong>野指针</strong>，在首次使用之前没有进行必要的初始化会产生一个野指针</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;

int *func(int y) {
  int x = y;
  int *p = &amp;x;
  return p;
}

int main(int argc, char const *argv[]) {
  int *p1 = func(5);
  func(10);
  printf(&quot;%p: %d\n&quot;, p1, *p1);
  return 0;
}
// 0x16fc86d18: 10
</code></pre>
<p>在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。</p>
<pre><code class="language-rust">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);
    &amp;s
}

// error[E0106]: missing lifetime specifier
// 	--&gt; src/main.rs:5:16
// 	 |
// 5 | fn dangle() -&gt; &amp;String {
//   |                ^ expected named lifetime parameter
//	 |
//   = help: this function&#x27;s return type contains a borrowed value, but there is no value for it to be borrowed from
//  help: consider using the `&#x27;static` lifetime
//   |
// 5 | fn dangle() -&gt; &amp;&#x27;static String {
//   |                ~~~~~~~~
</code></pre>
<h2>借用检查器</h2>
<p>Rust 编译器有一个 <strong>借用检查器</strong>（<em>borrow checker</em>），它比较作用域来确保所有的借用都是有效的。</p>
<pre><code class="language-rust">{
    let r;                // ---------+-- &#x27;a
                          //          |
    {                     //          |
        let x = 5;        // -+-- &#x27;b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!(&quot;r: {}&quot;, r); //          |
}                         
</code></pre>
<p>编译器在编译某个函数时，并不知道这个函数将来有谁调用、怎么调用，所以，函数本身携带的信息，就是编译器在编译时使用的全部信息。</p>
<p>我们在函数签名中提供生命周期的信息，也就是生命周期标注（lifetime specifier）</p>
<p>在生命周期标注时，使用的参数叫生命周期参数（lifetime parameter）。通过生命周期标注，我们告诉编译器这些引用间生命周期的约束</p>
<p>生命周期参数，描述的是参数和参数之间、参数和返回值之间的关系，并不改变原有的生命周期。</p>
<p>添加了生命周期参数后，只要实参的生命周期大于等于（outlive） 标注的生命周期，就符合参数的约束，而返回值的生命周期同理，也需要大于等于标注。</p>
<p>所有使用了引用的函数都需要生命周期的标注。为了尽可能减轻开发者的负担，编译器会通过一些简单的规则为函数自动添加标注：</p>
<ol>
<li>所有引用类型的参数都有独立的生命周期  &#x27;a 、&#x27;b 等</li>
<li>如果只有一个引用型输入，它的生命周期会赋给所有输出</li>
<li>如果有多个引用类型的参数，其中一个是 self，那么它的生命周期会赋给所有输出</li>
</ol>
<p>规则 3 适用于 trait 或者自定义数据类型</p>
<p>在处理生命周期时，编译器会根据一定规则自动添加生命周期的标注。然而，当自动标注产生冲突时，需要我们手工标注</p>
<p>生命周期标注的目的是，在参数和返回值之间建立联系或者约束。调用函数时，传入的参数的生命周期需要大于等于（outlive）标注的生命周期。</p>
<p>一般，我们只需要确定好返回值和哪个参数的生命周期相关就可以了</p>
<pre><code class="language-rust">fn strtok&lt;&#x27;a&gt;(s: &amp;&#x27;a mut &amp;str, delimiter: char) -&gt; &amp;&#x27;a str {
    if let Some(i) = s.find(delimiter) {
        let prefix = &amp;s[..i];
        // 由于 delimiter 可以是 utf8，所以我们需要获得其 utf8 长度，
        // 直接使用 len 返回的是字节长度，会有问题
        let suffix = &amp;s[(i + delimiter.len_utf8())..];
        *s = suffix;
        prefix
    } else {
        // 如果没找到，返回整个字符串，把原字符串指针 s 指向空串
        let prefix = *s;
        *s = &quot;&quot;;
        prefix
    }
}

pub fn main() {
    let s = &quot;hello world&quot;.to_owned();
    let mut s1 = s.as_str();
    let hello = strtok(&amp;mut s1, &#x27; &#x27;);
    println!(&quot;hello is: {}, s1: {}, s: {}&quot;, hello, s1, s);
}
</code></pre>
<pre><code class="language-shell">--&gt; src/bin/demo/lifetime.rs:23:52
   |
22 |     let hello = strtok(&amp;mut s1, &#x27; &#x27;);
   |                        ------- mutable borrow occurs here
23 |     println!(&quot;hello is: {}, s1: {}, s: {}&quot;, hello, s1, s);
   |     -----------------------------------------------^^----
   |     |                                              |
   |     |                                              immutable borrow occurs here
   |     mutable borrow later used here
   |
   = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)
</code></pre>
<p>参考理解：</p>
<p>![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220424161305828.png)</p>
<p>![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220424161445519.png)</p>
<p>![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220424161543097.png)</p>
<p>![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220424161659709.png)</p><div><a href="/notes/rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"生命周期","article":{"title":"生命周期","content":"rust 中的每一个引用都有其**生命周期**，也就是引用**保持有效**的作用域。\n\n大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用泛型生命周期参数来注明他们的关系，这样就能确保运行时实际使用的引用绝对是有效的。\n\n## 悬垂引用\n\n生命周期的目的是为了避免**悬垂引用**\n\n悬垂引用：指针指向的内存已经被释放，但是该指针没有作任何的修改，以至于该指针仍旧指向已被回收的内存地址\n\n与之对应的另一种指针是**野指针**，在首次使用之前没有进行必要的初始化会产生一个野指针\n\n```c\n#include\u003cstdio.h\u003e\n\nint *func(int y) {\n  int x = y;\n  int *p = \u0026x;\n  return p;\n}\n\nint main(int argc, char const *argv[]) {\n  int *p1 = func(5);\n  func(10);\n  printf(\"%p: %d\\n\", p1, *p1);\n  return 0;\n}\n// 0x16fc86d18: 10\n```\n\n在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。\n\n```rust\nfn main() {\n    let reference_to_nothing = dangle();\n}\n\nfn dangle() -\u003e \u0026String {\n    let s = String::from(\"hello\");\n    \u0026s\n}\n\n// error[E0106]: missing lifetime specifier\n// \t--\u003e src/main.rs:5:16\n// \t |\n// 5 | fn dangle() -\u003e \u0026String {\n//   |                ^ expected named lifetime parameter\n//\t |\n//   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n//  help: consider using the `'static` lifetime\n//   |\n// 5 | fn dangle() -\u003e \u0026'static String {\n//   |                ~~~~~~~~\n```\n\n## 借用检查器\n\nRust 编译器有一个 **借用检查器**（*borrow checker*），它比较作用域来确保所有的借用都是有效的。\n\n```rust\n{\n    let r;                // ---------+-- 'a\n                          //          |\n    {                     //          |\n        let x = 5;        // -+-- 'b  |\n        r = \u0026x;           //  |       |\n    }                     // -+       |\n                          //          |\n    println!(\"r: {}\", r); //          |\n}                         \n```\n\n\n\n\n\n\n\n编译器在编译某个函数时，并不知道这个函数将来有谁调用、怎么调用，所以，函数本身携带的信息，就是编译器在编译时使用的全部信息。\n\n\n\n我们在函数签名中提供生命周期的信息，也就是生命周期标注（lifetime specifier）\n\n\n\n\n\n在生命周期标注时，使用的参数叫生命周期参数（lifetime parameter）。通过生命周期标注，我们告诉编译器这些引用间生命周期的约束\n\n\n\n生命周期参数，描述的是参数和参数之间、参数和返回值之间的关系，并不改变原有的生命周期。\n\n\n\n添加了生命周期参数后，只要实参的生命周期大于等于（outlive） 标注的生命周期，就符合参数的约束，而返回值的生命周期同理，也需要大于等于标注。\n\n\n\n\n\n所有使用了引用的函数都需要生命周期的标注。为了尽可能减轻开发者的负担，编译器会通过一些简单的规则为函数自动添加标注：\n\n1. 所有引用类型的参数都有独立的生命周期  'a 、'b 等\n2. 如果只有一个引用型输入，它的生命周期会赋给所有输出\n3. 如果有多个引用类型的参数，其中一个是 self，那么它的生命周期会赋给所有输出\n\n规则 3 适用于 trait 或者自定义数据类型\n\n\n\n\n\n在处理生命周期时，编译器会根据一定规则自动添加生命周期的标注。然而，当自动标注产生冲突时，需要我们手工标注\n\n\n\n\n\n生命周期标注的目的是，在参数和返回值之间建立联系或者约束。调用函数时，传入的参数的生命周期需要大于等于（outlive）标注的生命周期。\n\n\n\n一般，我们只需要确定好返回值和哪个参数的生命周期相关就可以了\n\n\n\n```rust\nfn strtok\u003c'a\u003e(s: \u0026'a mut \u0026str, delimiter: char) -\u003e \u0026'a str {\n    if let Some(i) = s.find(delimiter) {\n        let prefix = \u0026s[..i];\n        // 由于 delimiter 可以是 utf8，所以我们需要获得其 utf8 长度，\n        // 直接使用 len 返回的是字节长度，会有问题\n        let suffix = \u0026s[(i + delimiter.len_utf8())..];\n        *s = suffix;\n        prefix\n    } else {\n        // 如果没找到，返回整个字符串，把原字符串指针 s 指向空串\n        let prefix = *s;\n        *s = \"\";\n        prefix\n    }\n}\n\npub fn main() {\n    let s = \"hello world\".to_owned();\n    let mut s1 = s.as_str();\n    let hello = strtok(\u0026mut s1, ' ');\n    println!(\"hello is: {}, s1: {}, s: {}\", hello, s1, s);\n}\n```\n\n\n\n```shell\n--\u003e src/bin/demo/lifetime.rs:23:52\n   |\n22 |     let hello = strtok(\u0026mut s1, ' ');\n   |                        ------- mutable borrow occurs here\n23 |     println!(\"hello is: {}, s1: {}, s: {}\", hello, s1, s);\n   |     -----------------------------------------------^^----\n   |     |                                              |\n   |     |                                              immutable borrow occurs here\n   |     mutable borrow later used here\n   |\n   = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)\n```\n\n\n\n参考理解：\n\n![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220424161305828.png)\n\n\n\n![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220424161445519.png)\n\n\n\n![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220424161543097.png)\n\n\n\n![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220424161659709.png)\n","meta":{"size":5873,"birthTime":1663496641424.6401,"updateTime":1663496641424.8245}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["rust学习笔记","生命周期"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>闭包 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#概述" data-target-id="h2-概述-0">概述</a></li><li><a href="#变量捕获" data-target-id="h2-变量捕获-1">变量捕获</a></li><li><a href="#move" data-target-id="h2-move-2">move</a></li><li><a href="#本质" data-target-id="h2-本质-3">本质</a></li><li><a href="#闭包类型" data-target-id="h2-闭包类型-4">闭包类型</a></li><li><a href="#Copy trait" data-target-id="h2-Copy trait-5">Copy trait</a></li><li><a href="#函数" data-target-id="h2-函数-6">函数</a></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">闭包</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h2>概述</h2>
<p>闭包是将代码和其环境一起存储的一种数据结构，闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分。</p>
<p>rust 中的闭包的语法：</p>
<pre><code class="language-rust">let cb = |x: i32, y: i32| -&gt; i32 { x + y }
</code></pre>
<p>其中的类型注解可以省略，编译器会进行类型推导，推导完类型会被锁定进闭包中，无法多次推导为不同类型的闭包</p>
<pre><code class="language-rust">let example_closure = |x| x;
let s = example_closure(String::from(&quot;hello&quot;));

// 已经推导为 |String| -&gt; String，会报错
let n = example_closure(5);
</code></pre>
<h2>变量捕获</h2>
<p>闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分</p>
<p>和变量的使用方式一样，变量捕获的方式有三种：</p>
<ul>
<li>不可变借用</li>
<li>可变借用</li>
<li>获取所有权（闭包会根据其语义进行 Move 或 Copy）</li>
</ul>
<p>闭包会根据内部对变量的使用情况，采取不同的方式捕获环境中的自由变量</p>
<pre><code class="language-rust">// 不可变借用
let c = || println!(&quot;hello: {}&quot;, name);

// Move
let c = || {
  let name = name;
  println!(&quot;hello: {}&quot;, name)
};
</code></pre>
<h2>move</h2>
<p>在闭包的参数列表前使用 <code>move</code> 关键字会强制闭包获取其使用变量的所有权</p>
<p><code>move</code> 通常用于使闭包的生命周期大于所捕获的变量的原生命周期，一般用于将闭包返回或移至其他线程</p>
<pre><code class="language-rust">fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!(&quot;can&#x27;t use x here: {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
</code></pre>
<p>如果闭包捕获的变量为引用，使用 <code>move</code> 之后闭包会根据所引用的对象的语义获取所有权（Copy 或 Move）</p>
<h2>本质</h2>
<blockquote>
<p>A closure expression produces a closure value with a unique, anonymous type that cannot be written out. A closure type is approximately equivalent to a struct which contains the captured variables.</p>
</blockquote>
<p>Rust 中的闭包是一种匿名类型，类似于一个结构体，其中存储了该结构体所捕获的变量。</p>
<p>并且一旦声明，就会产生一个新的类型。</p>
<p>闭包的大小跟参数、局部变量都无关，只跟捕获的变量有关。</p>
<p>参数和局部变量是在调用时才在栈上产生的内存分配，和闭包类型本身是无关的，所以跟闭包的大小也无关。</p>
<p>所以闭包是一个 DST</p>
<pre><code class="language-rust">// 有参、无捕获
let c1 = |i: i32| println!(&quot;hello: {}&quot;, i);

let name1 = String::from(&quot;tyr&quot;);
// 捕获一个引用，closure 长度为 8
let c2 = || println!(&quot;hello: {}&quot;, name1);

let name2 = name.clone();
// 捕获了一个 String，closure 长度 24
let c3 = move || {
  let x = 1;
  let name3 = String::from(&quot;lindsey&quot;);
  println!(&quot;hello: {}, {:?}, {:?}&quot;, x, name2, name3);
};

println!(
  &quot;c1: {}, c2: {}, c3: {}, main: {}&quot;,
  size_of_val(&amp;c1),
  size_of_val(&amp;c2),
  size_of_val(&amp;c3),
  size_of_val(&amp;main),
);
// c1: 0, c2: 8, c3: 24, main: 0
</code></pre>
<p>通过 gdb 的输出，可以发现闭包产生的匿名数据类型，格式和 struct 是一样的。</p>
<p>而且闭包是存储在栈上，并且除了捕获的数据外，闭包本身不包含任何额外函数指针指向闭包的代码。</p>
<p>Rust 为每个闭包生成一个新的类型，使得调用闭包时可以直接和代码对应，省去了使用函数指针再转一道手的额外消耗。</p>
<h2>闭包类型</h2>
<p>Rust 中闭包有三种类型约束：</p>
<pre><code class="language-rust">pub trait FnOnce&lt;Args&gt; {
    type Output;
    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
}

pub trait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;
}

pub trait Fn&lt;Args&gt;: FnMut&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call(&amp;self, args: Args) -&gt; Self::Output;
}
</code></pre>
<p>闭包实现了哪一个 <code>trait</code>，只与该闭包<strong>如何使用</strong>捕获环境中的变量有关：</p>
<ol>
<li>闭包<strong>移出</strong>了所捕获变量的<strong>所有权</strong>，则只会实现 <code>FnOnce</code></li>
<li>闭包通过<strong>可变借用</strong>使用捕获的变量，则会实现 <code>FnMut</code></li>
<li>闭包通过<strong>不可变借用</strong>使用捕获的变量/没有捕获变量，则会实现 <code>Fn</code></li>
</ol>
<p>闭包实现了哪一个 <code>trait</code> 只与闭包如何使用所捕获的变量有关，与如何捕获变量无关。</p>
<p>关键字 <code>move</code> 影响的是闭包如何捕获变量，因此对闭包实现 <code>FnOnce</code>、<code>FnMut</code> 和 <code>Fn</code> 没有任何影响。</p>
<p>只有移出所有权不太好理解：</p>
<pre><code class="language-rust">let s = String::from(&quot;fadsfda&quot;);
let c = || {
  let s = s;
  println!(&quot;{}&quot;, s);
};
c();
c();
</code></pre>
<p>由于 <code>let s = s</code> 移出了所有权，所以该闭包只实现了 <code>FnOnce</code></p>
<pre><code class="language-shell"> |
 |         let s = s;
 |                 ^
note: this value implements `FnOnce`, which causes it to be moved when called
</code></pre>
<p>只要是将所捕获的变量转移了所有权的使用方法，都会使闭包（仅实现 <code>FnOnce</code>）只能调用一次</p>
<p>如果一个闭包被当做 <code>FnOnce </code> 调用，那么它就无法再次被调用</p>
<p>原因就是 <code>FnOnce</code> 的调用使用 <code>call_once</code> 方法，该方法的第一个参数为 <code>self</code> 获取了所有权</p>
<h2>Copy trait</h2>
<p>闭包可以看做一个匿名结构体，其本身是否会实现 Copy trait 取决于捕获的变量</p>
<ul>
<li>捕获的变量为不可变引用&amp;T或具有Copy语义时，闭包会实现 Copy trait</li>
<li>捕获的变量为可变引用&amp;mut T或具有Move语义时，则闭包不会实现 Copy trait</li>
</ul>
<p>闭包是否实现Copy trait，只与如何捕获变量以及捕获的变量是否实现 Copy trait 有关···</p>
<pre><code class="language-rust">let s = &quot;sss&quot;;

let c = move || {
  println!(&quot;{}&quot;, s);
};

call_copy(c);

fn call_copy&lt;F: Fn() + Copy&gt;(c: F) {
    c();
}
</code></pre>
<ul>
<li><code>move</code> 不会影响闭包对 <code>Fn</code>，<code>FnMut</code>，<code>FnOnce</code> 的实现</li>
<li><code>move</code> 会捕获变量所有权，会影响闭包自动实现 Copy trait</li>
</ul>
<h2>函数</h2>
<p><code>fn</code> 是函数指针类型，也实现了闭包的所有 trait，所以只要接口一致 <code>fn</code> 也可以传递</p>
<p>声明参数的时候，可以统一使用泛型<code>Fnxx</code>，无论传闭包还是传函数指针都是可以调用</p>
<pre><code class="language-rust">fn call_once&lt;F: FnOnce(String)&gt;(arg: String, c: F) {
  c(arg);
}

fn not_closure(arg: String) {
  println!(&quot;{}&quot;, arg);
}

call_once(&quot;hello&quot;.into(), not_closure);

call_once(&quot;hello&quot;.into(), |arg| println!(&quot;{}&quot;, arg));
</code></pre><div><a href="/notes/rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"闭包","article":{"title":"闭包","content":"## 概述\n\n闭包是将代码和其环境一起存储的一种数据结构，闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分。\n\nrust 中的闭包的语法：\n\n```rust\nlet cb = |x: i32, y: i32| -\u003e i32 { x + y }\n```\n\n其中的类型注解可以省略，编译器会进行类型推导，推导完类型会被锁定进闭包中，无法多次推导为不同类型的闭包\n\n```rust\nlet example_closure = |x| x;\nlet s = example_closure(String::from(\"hello\"));\n\n// 已经推导为 |String| -\u003e String，会报错\nlet n = example_closure(5);\n```\n\n## 变量捕获\n\n闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分\n\n和变量的使用方式一样，变量捕获的方式有三种：\n\n- 不可变借用\n- 可变借用\n- 获取所有权（闭包会根据其语义进行 Move 或 Copy）\n\n闭包会根据内部对变量的使用情况，采取不同的方式捕获环境中的自由变量\n\n```rust\n// 不可变借用\nlet c = || println!(\"hello: {}\", name);\n\n// Move\nlet c = || {\n  let name = name;\n  println!(\"hello: {}\", name)\n};\n```\n\n## move\n\n在闭包的参数列表前使用 `move` 关键字会强制闭包获取其使用变量的所有权\n\n`move` 通常用于使闭包的生命周期大于所捕获的变量的原生命周期，一般用于将闭包返回或移至其他线程\n\n```rust\nfn main() {\n    let x = vec![1, 2, 3];\n\n    let equal_to_x = move |z| z == x;\n\n    println!(\"can't use x here: {:?}\", x);\n\n    let y = vec![1, 2, 3];\n\n    assert!(equal_to_x(y));\n}\n```\n\n如果闭包捕获的变量为引用，使用 `move` 之后闭包会根据所引用的对象的语义获取所有权（Copy 或 Move）\n\n## 本质\n\n\u003e A closure expression produces a closure value with a unique, anonymous type that cannot be written out. A closure type is approximately equivalent to a struct which contains the captured variables.\n\nRust 中的闭包是一种匿名类型，类似于一个结构体，其中存储了该结构体所捕获的变量。\n\n并且一旦声明，就会产生一个新的类型。\n\n闭包的大小跟参数、局部变量都无关，只跟捕获的变量有关。\n\n参数和局部变量是在调用时才在栈上产生的内存分配，和闭包类型本身是无关的，所以跟闭包的大小也无关。\n\n所以闭包是一个 DST\n\n```rust\n// 有参、无捕获\nlet c1 = |i: i32| println!(\"hello: {}\", i);\n\nlet name1 = String::from(\"tyr\");\n// 捕获一个引用，closure 长度为 8\nlet c2 = || println!(\"hello: {}\", name1);\n\nlet name2 = name.clone();\n// 捕获了一个 String，closure 长度 24\nlet c3 = move || {\n  let x = 1;\n  let name3 = String::from(\"lindsey\");\n  println!(\"hello: {}, {:?}, {:?}\", x, name2, name3);\n};\n\nprintln!(\n  \"c1: {}, c2: {}, c3: {}, main: {}\",\n  size_of_val(\u0026c1),\n  size_of_val(\u0026c2),\n  size_of_val(\u0026c3),\n  size_of_val(\u0026main),\n);\n// c1: 0, c2: 8, c3: 24, main: 0\n```\n\n通过 gdb 的输出，可以发现闭包产生的匿名数据类型，格式和 struct 是一样的。\n\n而且闭包是存储在栈上，并且除了捕获的数据外，闭包本身不包含任何额外函数指针指向闭包的代码。\n\nRust 为每个闭包生成一个新的类型，使得调用闭包时可以直接和代码对应，省去了使用函数指针再转一道手的额外消耗。\n\n## 闭包类型\n\nRust 中闭包有三种类型约束：\n\n```rust\npub trait FnOnce\u003cArgs\u003e {\n    type Output;\n    extern \"rust-call\" fn call_once(self, args: Args) -\u003e Self::Output;\n}\n\npub trait FnMut\u003cArgs\u003e: FnOnce\u003cArgs\u003e {\n    extern \"rust-call\" fn call_mut(\u0026mut self, args: Args) -\u003e Self::Output;\n}\n\npub trait Fn\u003cArgs\u003e: FnMut\u003cArgs\u003e {\n    extern \"rust-call\" fn call(\u0026self, args: Args) -\u003e Self::Output;\n}\n```\n\n闭包实现了哪一个 `trait`，只与该闭包**如何使用**捕获环境中的变量有关：\n\n1. 闭包**移出**了所捕获变量的**所有权**，则只会实现 `FnOnce`\n2. 闭包通过**可变借用**使用捕获的变量，则会实现 `FnMut`\n3. 闭包通过**不可变借用**使用捕获的变量/没有捕获变量，则会实现 `Fn`\n\n闭包实现了哪一个 `trait` 只与闭包如何使用所捕获的变量有关，与如何捕获变量无关。\n\n关键字 `move` 影响的是闭包如何捕获变量，因此对闭包实现 `FnOnce`、`FnMut` 和 `Fn` 没有任何影响。\n\n只有移出所有权不太好理解：\n\n```rust\nlet s = String::from(\"fadsfda\");\nlet c = || {\n  let s = s;\n  println!(\"{}\", s);\n};\nc();\nc();\n```\n\n由于 `let s = s` 移出了所有权，所以该闭包只实现了 `FnOnce` \n\n```shell\n |\n |         let s = s;\n |                 ^\nnote: this value implements `FnOnce`, which causes it to be moved when called\n```\n\n只要是将所捕获的变量转移了所有权的使用方法，都会使闭包（仅实现 `FnOnce`）只能调用一次\n\n如果一个闭包被当做 `FnOnce ` 调用，那么它就无法再次被调用\n\n原因就是 `FnOnce` 的调用使用 `call_once` 方法，该方法的第一个参数为 `self` 获取了所有权 \n\n## Copy trait\n\n闭包可以看做一个匿名结构体，其本身是否会实现 Copy trait 取决于捕获的变量\n\n- 捕获的变量为不可变引用\u0026T或具有Copy语义时，闭包会实现 Copy trait\n- 捕获的变量为可变引用\u0026mut T或具有Move语义时，则闭包不会实现 Copy trait\n\n闭包是否实现Copy trait，只与如何捕获变量以及捕获的变量是否实现 Copy trait 有关···\n\n```rust\nlet s = \"sss\";\n\nlet c = move || {\n  println!(\"{}\", s);\n};\n\ncall_copy(c);\n\nfn call_copy\u003cF: Fn() + Copy\u003e(c: F) {\n    c();\n}\n```\n\n- `move` 不会影响闭包对 `Fn`，`FnMut`，`FnOnce` 的实现\n- `move` 会捕获变量所有权，会影响闭包自动实现 Copy trait\n\n## 函数\n\n`fn` 是函数指针类型，也实现了闭包的所有 trait，所以只要接口一致 `fn` 也可以传递\n\n声明参数的时候，可以统一使用泛型`Fnxx`，无论传闭包还是传函数指针都是可以调用\n\n```rust\nfn call_once\u003cF: FnOnce(String)\u003e(arg: String, c: F) {\n  c(arg);\n}\n\nfn not_closure(arg: String) {\n  println!(\"{}\", arg);\n}\n\ncall_once(\"hello\".into(), not_closure);\n\ncall_once(\"hello\".into(), |arg| println!(\"{}\", arg));\n```\n\n","meta":{"size":6196,"birthTime":1663496641426.066,"updateTime":1663496641426.338}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["rust学习笔记","闭包"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>包管理器 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#语义版本" data-target-id="h2-语义版本-0">语义版本</a></li><li><a href="#目录结构" data-target-id="h2-目录结构-1">目录结构</a></li><li><a href="#lock 文件" data-target-id="h2-lock 文件-2">lock 文件</a></li><li><a href="#缓存" data-target-id="h2-缓存-3">缓存</a></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">包管理器</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h2>语义版本</h2>
<p>版本规范：主版本号.次版本号.补丁版本号</p>
<ul>
<li>主版本号：仅当程序发生了重大变化时才会增长，如新增了重要功能、新增了大量的API、技术架构发生了重大变化</li>
<li>次版本号：仅当程序发生了一些小变化时才会增长，如新增了一些小功能、新增了一些辅助型的API</li>
<li>补丁版本号：仅当解决了一些 bug 或 进行了一些局部优化时更新，如修复了某个函数的 bug、提升了某个函数的运行效率</li>
</ul>
<p>当我们在编写一个库的时候，需要考虑别人在安装我们编写的库的依赖时，是安装一个规定的版本，还是可以安装更高版本</p>
<p>所以一般在 <code>package.json</code> 中给依赖时，往往不直接给一个固定的版本，而是给一个依赖版本可以高多少的规则</p>
<p>这种规则的描述，称为<strong>语义版本</strong>，语义版本的书写规则非常丰富，一些常见的书写方式：</p>
<table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">描述</th><th style="text-align:center">示例</th><th style="text-align:center">示例描述</th></tr></thead><tbody><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于某个版本</td><td style="text-align:center">&gt;1.2.1</td><td style="text-align:center">大于1.2.1版本</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">大于等于某个版本</td><td style="text-align:center">&gt;=1.2.1</td><td style="text-align:center">大于等于1.2.1版本</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于某个版本</td><td style="text-align:center">&lt;1.2.1</td><td style="text-align:center">小于1.2.1版本</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于某个版本</td><td style="text-align:center">&lt;=1.2.1</td><td style="text-align:center">小于等于1.2.1版本</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">介于两个版本之间</td><td style="text-align:center">1.2.1 - 1.4.5</td><td style="text-align:center">介于1.2.1和1.4.5之间</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">不固定的版本号</td><td style="text-align:center">1.3.x</td><td style="text-align:center">只要保证主版本号是1，次版本号是3即可</td></tr><tr><td style="text-align:center">~</td><td style="text-align:center">补丁版本号可增</td><td style="text-align:center">~1.3.4</td><td style="text-align:center">保证主版本号是1，次版本号是3，补丁版本号大于等于4</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">此版本和补丁版本可增</td><td style="text-align:center">^1.3.4</td><td style="text-align:center">保证主版本号是1，次版本号可以大于等于3，补丁版本号可以大于等于4</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">最新版本</td><td style="text-align:center">*</td><td style="text-align:center">始终安装最新版本</td></tr></tbody></table>
<h2>目录结构</h2>
<p>在 <code>npm1</code>、<code>npm2</code> 的时代 node_modules 中依赖树呈现出的是嵌套结构</p>
<pre><code>node_modules
└─ foo
   ├─ index.js
   ├─ package.json
   └─ node_modules
      └─ bar
         ├─ index.js
         └─ package.json
</code></pre>
<p>这种嵌套结构存在的问题：</p>
<ol>
<li>依赖层级太深，会导致文件路径过长，在 window 系统下存在问题</li>
<li>依赖无法被共用，安装大量重复的包（相同版本），导致文件体积超级大</li>
</ol>
<!-- -->&lt;img src=&quot;https://res.cloudinary.com/practicaldev/image/fetch/s--BIL81hqp--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/i/8bqhs2j0frz5upzfyj90.jpg&quot; style=&quot;zoom:67%;&quot; /&gt;<!-- -->
<p>从 npm3 开始，包括 yarn，都通过<strong>扁平化</strong>依赖的方式来解决问题</p>
<pre><code>node_modules
├─ foo
|  ├─ index.js
|  └─ package.json
└─ bar
   ├─ index.js
   └─ package.json
</code></pre>
<p>所有的依赖都被拍平到 <code>node_modules</code> 目录下，不再有很深层次的嵌套关系，解决了大量包重复安装的问题，而且依赖层级也不会太深。</p>
<p>根据 require 的工作机制，也能正确的找到确切的依赖，但是依旧存在一些问题：</p>
<ol>
<li>扁平化算法本身的<strong>复杂性</strong>很高，耗时较长</li>
<li>依赖结构的<strong>不确定性</strong></li>
<li>可以<strong>非法访问</strong>没有声明过依赖的包</li>
</ol>
<p>所谓的依赖结构的不确定性，指的是项目依赖的多个包依赖不同版本的相同的包，扁平化处理后的结果应该是怎么样的</p>
<p><img src="https://oss.xiefeng.tech/images/20211129163057.png" alt=""/></p>
<p>两种情况是都有可能会出现的（以 buffer 和 buffer2 为例），取决于这些依赖在 <code>package.json</code> 依赖声明中相对的位置，谁在前谁的依赖就先被扁平化</p>
<h2>lock 文件</h2>
<p>npm 5.x 版本新增了 package-lock.json 文件，类似于 yarn.lock</p>
<p>Lock 文件诞生的原因：</p>
<ol>
<li>扁平化方式安装导致的依赖结构的不确定问题</li>
<li>由于语义版本，不能保证每次 install 之后的版本都相同</li>
</ol>
<p>lock 文件是保证在不同的主机上 install 之后都产生确定的 <code>node_modules</code> 结构</p>
<p>package-lock.json 文件：</p>
<ul>
<li>packages：所有的 node_modules 中的包和自己本身</li>
<li>dependencies：和 node_modules 中的包结构，key 为包名称，值为包的一些描述信息<!-- -->
<ul>
<li>每一项都表示当前目录下可以直接 require 的模块</li>
<li>version：这个包当前安装在 node_modules 中的版本</li>
<li>resolved：包具体的安装来源</li>
<li>integrity：包 hash 值，基于 Subresource Integrity 来验证已安装的软件包是否被改动过、是否已失效</li>
<li>requires：该包的依赖，与该包的 package.json 中 dependencies 的依赖项相同</li>
<li>dependencies：存储安装在子依赖 node_modules 中的依赖包，和外层的 dependencies 结构相同</li>
</ul>
</li>
</ul>
<h2>缓存</h2>
<p>在执行 npm install 或 npm update 命令下载依赖后，除了将依赖包安装在 node_modules 目录下外，还会在本地的缓存目录缓存一份</p>
<p><code>npm config get cache</code> 可以查询到缓存的目录，一般返回结果都为 <code>~/.npm</code>，缓存存储在 <code>~/.npm/_cacache</code> 目录下</p>
<p>该目录下存在两个目录：<code>content-v2</code> 和 <code>index-v5</code></p>
<p><code>content-v2</code> 用于存储 tar 包的缓存，<code>index-v5</code> 用于存储 tar 包的 hash</p>
<p>npm 在执行安装时，可以根据 package-lock.json 中存储的 integrity、version、name 生成一个唯一的 key 对应到 index-v5 目录下的缓存记录，从而找到 tar 包的 hash，然后根据 hash 再去找缓存的 tar包直接使用。</p><div><a href="/notes/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"包管理器","article":{"title":"包管理器","content":"## 语义版本\n\n版本规范：主版本号.次版本号.补丁版本号\n\n- 主版本号：仅当程序发生了重大变化时才会增长，如新增了重要功能、新增了大量的API、技术架构发生了重大变化\n- 次版本号：仅当程序发生了一些小变化时才会增长，如新增了一些小功能、新增了一些辅助型的API\n- 补丁版本号：仅当解决了一些 bug 或 进行了一些局部优化时更新，如修复了某个函数的 bug、提升了某个函数的运行效率\n\n当我们在编写一个库的时候，需要考虑别人在安装我们编写的库的依赖时，是安装一个规定的版本，还是可以安装更高版本\n\n所以一般在 `package.json` 中给依赖时，往往不直接给一个固定的版本，而是给一个依赖版本可以高多少的规则\n\n这种规则的描述，称为**语义版本**，语义版本的书写规则非常丰富，一些常见的书写方式：\n\n| 符号 |         描述         |     示例      |                           示例描述                           |\n| :--: | :------------------: | :-----------: | :----------------------------------------------------------: |\n|  \u003e   |     大于某个版本     |    \u003e1.2.1     |                        大于1.2.1版本                         |\n|  \u003e=  |   大于等于某个版本   |    \u003e=1.2.1    |                      大于等于1.2.1版本                       |\n|  \u003c   |     小于某个版本     |    \u003c1.2.1     |                        小于1.2.1版本                         |\n|  \u003c=  |   小于等于某个版本   |    \u003c=1.2.1    |                      小于等于1.2.1版本                       |\n|  -   |   介于两个版本之间   | 1.2.1 - 1.4.5 |                     介于1.2.1和1.4.5之间                     |\n|  x   |    不固定的版本号    |     1.3.x     |             只要保证主版本号是1，次版本号是3即可             |\n|  ~   |    补丁版本号可增    |    ~1.3.4     |      保证主版本号是1，次版本号是3，补丁版本号大于等于4       |\n|  ^   | 此版本和补丁版本可增 |    ^1.3.4     | 保证主版本号是1，次版本号可以大于等于3，补丁版本号可以大于等于4 |\n|  *   |       最新版本       |       *       |                       始终安装最新版本                       |\n\n## 目录结构\n\n在 `npm1`、`npm2` 的时代 node_modules 中依赖树呈现出的是嵌套结构\n\n```\nnode_modules\n└─ foo\n   ├─ index.js\n   ├─ package.json\n   └─ node_modules\n      └─ bar\n         ├─ index.js\n         └─ package.json\n```\n\n这种嵌套结构存在的问题：\n\n1. 依赖层级太深，会导致文件路径过长，在 window 系统下存在问题\n2. 依赖无法被共用，安装大量重复的包（相同版本），导致文件体积超级大\n\n\u003cimg src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--BIL81hqp--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/i/8bqhs2j0frz5upzfyj90.jpg\" style=\"zoom:67%;\" /\u003e\n\n从 npm3 开始，包括 yarn，都通过**扁平化**依赖的方式来解决问题\n\n```\nnode_modules\n├─ foo\n|  ├─ index.js\n|  └─ package.json\n└─ bar\n   ├─ index.js\n   └─ package.json\n```\n\n所有的依赖都被拍平到 `node_modules` 目录下，不再有很深层次的嵌套关系，解决了大量包重复安装的问题，而且依赖层级也不会太深。\n\n根据 require 的工作机制，也能正确的找到确切的依赖，但是依旧存在一些问题：\n\n1. 扁平化算法本身的**复杂性**很高，耗时较长\n2. 依赖结构的**不确定性**\n3. 可以**非法访问**没有声明过依赖的包\n\n所谓的依赖结构的不确定性，指的是项目依赖的多个包依赖不同版本的相同的包，扁平化处理后的结果应该是怎么样的\n\n![](https://oss.xiefeng.tech/images/20211129163057.png)\n\n两种情况是都有可能会出现的（以 buffer 和 buffer2 为例），取决于这些依赖在 `package.json` 依赖声明中相对的位置，谁在前谁的依赖就先被扁平化\n\n## lock 文件\n\nnpm 5.x 版本新增了 package-lock.json 文件，类似于 yarn.lock\n\nLock 文件诞生的原因：\n\n1. 扁平化方式安装导致的依赖结构的不确定问题\n2. 由于语义版本，不能保证每次 install 之后的版本都相同\n\nlock 文件是保证在不同的主机上 install 之后都产生确定的 `node_modules` 结构\n\npackage-lock.json 文件：\n\n- packages：所有的 node_modules 中的包和自己本身\n- dependencies：和 node_modules 中的包结构，key 为包名称，值为包的一些描述信息\n  - 每一项都表示当前目录下可以直接 require 的模块\n  - version：这个包当前安装在 node_modules 中的版本\n  - resolved：包具体的安装来源\n  - integrity：包 hash 值，基于 Subresource Integrity 来验证已安装的软件包是否被改动过、是否已失效\n  - requires：该包的依赖，与该包的 package.json 中 dependencies 的依赖项相同\n  - dependencies：存储安装在子依赖 node_modules 中的依赖包，和外层的 dependencies 结构相同\n\n## 缓存\n\n在执行 npm install 或 npm update 命令下载依赖后，除了将依赖包安装在 node_modules 目录下外，还会在本地的缓存目录缓存一份\n\n`npm config get cache` 可以查询到缓存的目录，一般返回结果都为 `~/.npm`，缓存存储在 `~/.npm/_cacache` 目录下\n\n该目录下存在两个目录：`content-v2` 和 `index-v5`\n\n`content-v2` 用于存储 tar 包的缓存，`index-v5` 用于存储 tar 包的 hash\n\nnpm 在执行安装时，可以根据 package-lock.json 中存储的 integrity、version、name 生成一个唯一的 key 对应到 index-v5 目录下的缓存记录，从而找到 tar 包的 hash，然后根据 hash 再去找缓存的 tar包直接使用。\n\n\n\n","meta":{"size":5906,"birthTime":1663496641428.8345,"updateTime":1663496641429.0317}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["包管理器","包管理器"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
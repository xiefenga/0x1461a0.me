<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>var和let | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">var和let</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><ul>
<li>var 声明的变量，无论是在哪里声明的，最后都会被当成子啊当前作用域顶部声明的变量。</li>
<li>let 声明的变量，在没有运行到声明的语句之前不允许被访问 -&gt; 所谓的 TDZ，即使使用 typeof 也会报错</li>
<li>var 可以重复声明一个变量，let 和 const 无法重复声明</li>
<li>var 声明的变量只存在全局和函数作用域，let 声明的变量存在块级作用域</li>
<li>循环中的 let 声明是标准中单独定义的，和 host 特性无关。早期的 let 实现不包含该特性，后开才加入的。<!-- -->
<ul>
<li>每次循环 let 都会创一个新变量</li>
<li>设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域</li>
</ul>
</li>
</ul><div><a href="/notes">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"var和let","article":{"title":"var和let","content":"- var 声明的变量，无论是在哪里声明的，最后都会被当成子啊当前作用域顶部声明的变量。\r\n- let 声明的变量，在没有运行到声明的语句之前不允许被访问 -\u003e 所谓的 TDZ，即使使用 typeof 也会报错\r\n- var 可以重复声明一个变量，let 和 const 无法重复声明\r\n- var 声明的变量只存在全局和函数作用域，let 声明的变量存在块级作用域\r\n- 循环中的 let 声明是标准中单独定义的，和 host 特性无关。早期的 let 实现不包含该特性，后开才加入的。\r\n\t- 每次循环 let 都会创一个新变量\r\n\t- 设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域\r\n\r\n","meta":{"size":727,"birthTime":1663496641427.1897,"updateTime":1663496641427.2957}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["var和let"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
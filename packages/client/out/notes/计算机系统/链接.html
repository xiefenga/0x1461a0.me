<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>链接 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#C 语言转换过程" data-target-id="h2-C 语言转换过程-0">C 语言转换过程</a><ul><li><a href="#预处理" data-target-id="h3-预处理-0">预处理</a></li><li><a href="#编译" data-target-id="h3-编译-1">编译</a></li><li><a href="#汇编" data-target-id="h3-汇编-2">汇编</a></li><li><a href="#链接" data-target-id="h3-链接-3">链接</a></li></ul></li><li><a href="#链接" data-target-id="h2-链接-1">链接</a></li><li><a href="#目标文件" data-target-id="h2-目标文件-2">目标文件</a></li><li><a href="#ELF 目标文件" data-target-id="h2-ELF 目标文件-3">ELF 目标文件</a><ul><li><a href="#ELF头" data-target-id="h3-ELF头-4">ELF头</a></li><li><a href="#链接视图" data-target-id="h3-链接视图-5">链接视图</a></li></ul></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">链接</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h2>C 语言转换过程</h2>
<p>用 GCC 编译器套件进行转换的过程：</p>
<ol>
<li>
<p>预处理：在高级语言源程序中插入所有用 <code>#include</code> 命令指定的文件和用 <code>#define</code> 声明指定的宏</p>
</li>
<li>
<p>编译：将预处理后的源程序文件编译生成相应的汇编语言程序</p>
</li>
<li>
<p>汇编：由汇编程序将汇编语言源程序文件转换为<strong>可重定位的机器语言目标代码文件</strong></p>
</li>
<li>
<p>链接：由<strong>链接器</strong>将多个可重定位的机器语言目标文件以及库例程（如 <code>printf</code> 库函数）链接起来，生成最终的<strong>可执行目标文件</strong></p>
</li>
</ol>
<p><img src="https://oss.xiefeng.tech/images/20211026231522.png" alt=""/></p>
<h3>预处理</h3>
<p>处理源文件中以“#”开头的预编译指令</p>
<ul>
<li>删除 <code>#define</code> 并展开所定义的宏</li>
<li>处理所有条件预编译指令，如 <code>#if</code>、<code>#ifdef</code>、<code>#endif</code> 等</li>
<li>插入头文件到 <code>#include</code> 处，并递归的处理</li>
<li>......</li>
</ul>
<p>使用 cpp 程序可以得到源文件预处理之后的结果，gcc 实际上是具体程序（如ccp、cc1、as等）的包装命令</p>
<pre><code class="language-shell">$ cpp hello.c &gt; hello.i
$ gcc –E hello.c –o hello.i
</code></pre>
<p>经过预编译处理后，得到的预处理文件还是一个可读的文本文件 ，但不包含任何的宏定义</p>
<h3>编译</h3>
<p>编译过程就是将预处理后得到的预处理文件进行词法分析、语法分析、语义分析，优化后生成汇编代码文件</p>
<p>使用 gcc 可以得到经过编译之后的文件</p>
<pre><code class="language-shell">$ gcc –S hello.i –o hello.s
# 也可以直接通过源文件得到编译之后的文件
$ gcc –S hello.c –o hello.s
</code></pre>
<p>经过编译后，得到的汇编代码文件依旧是可读的文本文件，但是 CPU 无法理解和执行它</p>
<h3>汇编</h3>
<p>汇编程序用来将汇编语言源程序转换为机器指令序列</p>
<p>汇编结果是一个<strong>可重定位目标文件</strong>，其中包含的是不可读的二进制代码，必须用相应的工具软件来查看其内容</p>
<p>可以通过 as 程序进行汇编操作</p>
<pre><code class="language-shell">$ gcc –c hello.c –o hello.o
$ gcc –c hello.s –o hello.o
$ as hello.s -o hello.o
</code></pre>
<h3>链接</h3>
<p>预处理、编译和汇编三个阶段针对一个模块进行处理，得到对应的一个可重定位目标文件</p>
<p>链接过程将多个可重定位目标文件合并以生成一个<strong>可执行目标文件</strong></p>
<p><code>–static</code> 表示执行静态链接操作</p>
<pre><code class="language-shell">$ gcc –static –o myproc main.o test.o
$ ld –static –o myproc main.o test.o
</code></pre>
<h2>链接</h2>
<p>最早程序员用机器语言编写程序，并记录在纸带或卡片上，当增加或删除某一条指令时则，则需要修改其中的 jump 指令的目标地址，以及需要重新打孔，这是非常麻烦的</p>
<p>原始的链接概念早在高级编程语言出现之前就已存在，在使用汇编进行编程时往往会使用符号表示跳转和变量的位置，这样即使需要修改程序这些也不会受影响，只需要最终将符号替换为该符号定义的地址即可，这个替换过程就称为<strong>链接</strong></p>
<p>链接可以带来一些好处</p>
<ul>
<li>一个程序可以分成很多源程序文件，实现模块化<!-- -->
<ul>
<li>可以构建公共的函数库</li>
</ul>
</li>
<li>可以将源文件分开编译，最后将它们链接即可<!-- -->
<ul>
<li>只需重新编译被修改的源程序文件，然后重新链接</li>
</ul>
</li>
<li>源文件中无需包含共享库函数的源码，只要直接调用即可</li>
</ul>
<h2>目标文件</h2>
<p>所谓的目标文件就是</p>
<p>最早的目标文件格式是自有格式，非标准的，标准的几种目标文件格式</p>
<ul>
<li>DOS操作系统(最简单) :COM格式，文件中仅包含代码和数据，且被加载到固定位置</li>
</ul>
<h2>ELF 目标文件</h2>
<p>ELF 称为可执行可链接（Executable and Linkable Format），ELF 文件具有两种视图，也就是说有两种不同的文件都采用该种格式</p>
<p>ELF 具有两种视图：</p>
<ul>
<li>链接视图：可重定位目标文件</li>
<li>执行视图：可执行目标文件</li>
</ul>
<h3>ELF头</h3>
<p>ELF头位于文件的开始位置，它的主要目的是定位文件的其他部分</p>
<p>ELF32 header的类型定义为 <a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h#L205"><code>elf32_hdr</code></a>，ELF64 header 的类型定义为 <a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h#L220"><code>elf64_hdr</code></a></p>
<p>通过 <code>readelf</code> 程序可以查看 EFL 文件的各部分信息</p>
<pre><code class="language-shell">$ readelf -h hello.o
</code></pre>
<p><img src="https://oss.xiefeng.tech/images/20211106183508.png" alt=""/></p>
<h3>链接视图</h3>
<p>链接视图所对应的文件为<strong>可重定位目标文件</strong>，其中包含的内容为：</p>
<ul>
<li>ELF 头：位于文件的开始位置，主要目的是定位文件的其他部分</li>
<li>节（section）：程序编译后的代码和数据等信息都存储在各种节中<!-- -->
<ul>
<li>.text 节中存储的是编译后的代码部分（一条一条的指令）</li>
<li>.rodata 节中存储的是只读数据，如字符串字面量、switch 跳转表等</li>
<li>.data 节中存储的是已初始化的全局变量</li>
<li>.bss 节中存储的是未初始化全局变量<!-- -->
<ul>
<li>在磁盘空间层面不存在该部分，该部分存在于逻辑上</li>
<li>主要目的是优化空间效率，将初始化和未初始化的变量分开</li>
</ul>
</li>
<li>.symtab 节：存放函数和全局变量（符号表）信息</li>
<li>.rel.text 节：.text 节的重定位信息，用于重新修改代码段的指令中的地址信息</li>
<li>.rel.data 节： .data节的重定位信息，用于对被模块使用或定义的全局变量进行重定位的信息</li>
<li>.debug 节：调试用符号表 (gcc -g)</li>
<li>strtab 节：包含 symtab 和 debug 节中符号及节名</li>
</ul>
</li>
<li>节头表：存储了每个节的节名、偏移和大小</li>
</ul><div><a href="/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"链接","article":{"title":"链接","content":"## C 语言转换过程\n\n用 GCC 编译器套件进行转换的过程：\n\n1. 预处理：在高级语言源程序中插入所有用 `#include` 命令指定的文件和用 `#define` 声明指定的宏\n\n2. 编译：将预处理后的源程序文件编译生成相应的汇编语言程序\n\n3. 汇编：由汇编程序将汇编语言源程序文件转换为**可重定位的机器语言目标代码文件**\n\n4. 链接：由**链接器**将多个可重定位的机器语言目标文件以及库例程（如 `printf` 库函数）链接起来，生成最终的**可执行目标文件**\n\n\n![](https://oss.xiefeng.tech/images/20211026231522.png)\n\n### 预处理\n\n处理源文件中以“#”开头的预编译指令\n\n- 删除 `#define` 并展开所定义的宏\n- 处理所有条件预编译指令，如 `#if`、`#ifdef`、`#endif` 等\n- 插入头文件到 `#include` 处，并递归的处理\n- ......\n\n使用 cpp 程序可以得到源文件预处理之后的结果，gcc 实际上是具体程序（如ccp、cc1、as等）的包装命令\n\n```shell\n$ cpp hello.c \u003e hello.i\n$ gcc –E hello.c –o hello.i\n```\n\n经过预编译处理后，得到的预处理文件还是一个可读的文本文件 ，但不包含任何的宏定义\n\n### 编译\n\n编译过程就是将预处理后得到的预处理文件进行词法分析、语法分析、语义分析，优化后生成汇编代码文件\n\n使用 gcc 可以得到经过编译之后的文件\n\n```shell\n$ gcc –S hello.i –o hello.s\n# 也可以直接通过源文件得到编译之后的文件\n$ gcc –S hello.c –o hello.s\n```\n\n经过编译后，得到的汇编代码文件依旧是可读的文本文件，但是 CPU 无法理解和执行它\n\n### 汇编\n\n汇编程序用来将汇编语言源程序转换为机器指令序列\n\n汇编结果是一个**可重定位目标文件**，其中包含的是不可读的二进制代码，必须用相应的工具软件来查看其内容\n\n可以通过 as 程序进行汇编操作\n\n```shell\n$ gcc –c hello.c –o hello.o\n$ gcc –c hello.s –o hello.o\n$ as hello.s -o hello.o\n```\n\n### 链接\n\n预处理、编译和汇编三个阶段针对一个模块进行处理，得到对应的一个可重定位目标文件\n\n链接过程将多个可重定位目标文件合并以生成一个**可执行目标文件**\n\n`–static` 表示执行静态链接操作\n\n```shell\n$ gcc –static –o myproc main.o test.o\n$ ld –static –o myproc main.o test.o\n```\n\n## 链接\n\n最早程序员用机器语言编写程序，并记录在纸带或卡片上，当增加或删除某一条指令时则，则需要修改其中的 jump 指令的目标地址，以及需要重新打孔，这是非常麻烦的\n\n原始的链接概念早在高级编程语言出现之前就已存在，在使用汇编进行编程时往往会使用符号表示跳转和变量的位置，这样即使需要修改程序这些也不会受影响，只需要最终将符号替换为该符号定义的地址即可，这个替换过程就称为**链接**\n\n链接可以带来一些好处\n\n- 一个程序可以分成很多源程序文件，实现模块化\n  - 可以构建公共的函数库\n- 可以将源文件分开编译，最后将它们链接即可\n  - 只需重新编译被修改的源程序文件，然后重新链接\n- 源文件中无需包含共享库函数的源码，只要直接调用即可\n\n## 目标文件\n\n所谓的目标文件就是\n\n最早的目标文件格式是自有格式，非标准的，标准的几种目标文件格式\n\n- DOS操作系统(最简单) :COM格式，文件中仅包含代码和数据，且被加载到固定位置\n\n\n\n## ELF 目标文件\n\nELF 称为可执行可链接（Executable and Linkable Format），ELF 文件具有两种视图，也就是说有两种不同的文件都采用该种格式\n\nELF 具有两种视图：\n\n- 链接视图：可重定位目标文件\n- 执行视图：可执行目标文件\n\n### ELF头\n\nELF头位于文件的开始位置，它的主要目的是定位文件的其他部分\n\nELF32 header的类型定义为 [`elf32_hdr`](https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h#L205)，ELF64 header 的类型定义为 [`elf64_hdr`](https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h#L220)\n\n通过 `readelf` 程序可以查看 EFL 文件的各部分信息\n\n```shell\n$ readelf -h hello.o\n```\n\n![](https://oss.xiefeng.tech/images/20211106183508.png)\n\n### 链接视图\n\n链接视图所对应的文件为**可重定位目标文件**，其中包含的内容为：\n\n- ELF 头：位于文件的开始位置，主要目的是定位文件的其他部分\n- 节（section）：程序编译后的代码和数据等信息都存储在各种节中\n  - .text 节中存储的是编译后的代码部分（一条一条的指令）\n  - .rodata 节中存储的是只读数据，如字符串字面量、switch 跳转表等\n  - .data 节中存储的是已初始化的全局变量\n  - .bss 节中存储的是未初始化全局变量\n    - 在磁盘空间层面不存在该部分，该部分存在于逻辑上\n    - 主要目的是优化空间效率，将初始化和未初始化的变量分开\n  - .symtab 节：存放函数和全局变量（符号表）信息\n  - .rel.text 节：.text 节的重定位信息，用于重新修改代码段的指令中的地址信息\n  - .rel.data 节： .data节的重定位信息，用于对被模块使用或定义的全局变量进行重定位的信息\n  - .debug 节：调试用符号表 (gcc -g)\n  - strtab 节：包含 symtab 和 debug 节中符号及节名\n- 节头表：存储了每个节的节名、偏移和大小\n\n\n\n\n\n\n\n\n\n\n\n","meta":{"size":5556,"birthTime":1663496641438.482,"updateTime":1663496641438.6865}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["计算机系统","链接"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
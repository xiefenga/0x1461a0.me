<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>指令 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#CPU工作原理" data-target-id="h2-CPU工作原理-0">CPU工作原理</a></li><li><a href="#指令集体系结构" data-target-id="h2-指令集体系结构-1">指令集体系结构</a></li><li><a href="#C 语言转换过程" data-target-id="h2-C 语言转换过程-2">C 语言转换过程</a></li><li><a href="#x86 架构" data-target-id="h2-x86 架构-3">x86 架构</a></li><li><a href="#过程调用" data-target-id="h2-过程调用-4">过程调用</a><ul><li><a href="#栈和栈帧" data-target-id="h3-栈和栈帧-0">栈和栈帧</a></li><li><a href="#机器级表示" data-target-id="h3-机器级表示-1">机器级表示</a></li></ul></li><li><a href="#数据对齐" data-target-id="h2-数据对齐-5">数据对齐</a></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">指令</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h2>CPU工作原理</h2>
<p>冯诺依曼式计算机采用<strong>存储程序</strong>的工作方式，数据和指令事先存放在存储器中，形式上没有差别</p>
<p>每条指令和每个数据都有各自的地址，其中指令按序存放，PC 中存放着程序下一条需要执行指令的地址，指令由 OP、ADDR 字段组成</p>
<p>CPU 能自动地取出一条一条指令执行无需人为干预，指令和数据被从存储器取到 CPU，存放在寄存器中，其中指令在 IR 中，数据在通用寄存器中</p>
<p>CPU 执行指令的一般步骤：</p>
<ol>
<li>从 PC 指向的地址中取出指令</li>
<li>修改 PC 的值，指向下一条指令</li>
<li>对指令进行译码</li>
<li>执行该条指令</li>
</ol>
<h2>指令集体系结构</h2>
<p>指令集体系结构（ISA）是一种规约，它规定了如何使用硬件</p>
<ul>
<li>所有<strong>可执行指令的集合</strong></li>
<li>指令格式、操作种类以及每种操作对应的操作数的相应规定</li>
<li>指令可以接受的操作数的类型</li>
<li>操作数所能存放的寄存器组的结构，包括每个寄存器的名称、编号、 长度和用途</li>
<li>操作数所能存放的存储空间的大小和编址方式</li>
<li>操作数在存储空间存放时按照大端还是小端方式存放</li>
<li>指令获取操作数的方式，即寻址方式</li>
<li>指令执行过程的控制方式，包括程序计数器、条件码定义等</li>
</ul>
<p>ISA 在计算机系统中是必不可少的一个<strong>抽象层</strong>，缺少 ISA 软件无法使用计算机硬件，一台计算机也不能称为“通用计算机“</p>
<p>ISA 和计算机组成（微体系结构）的关系：ISA 是计算机组成的抽象，同一种 ISA 可以有不同的计算机组成</p>
<p>相当于 ISA 规定了接口，计算机组成是具体的实现方式，实现方式是不唯一的，例如：乘法指令可用 ALU 或乘法器实现</p>
<h2>C 语言转换过程</h2>
<p>用 GCC 编译器套件进行转换的过程：</p>
<ol>
<li>
<p>预处理：在高级语言源程序中插入所有用 <code>#include</code> 命令指定的文件和用 <code>#define</code> 声明指定的宏</p>
</li>
<li>
<p>编译：将预处理后的源程序文件编译生成相应的汇编语言程序</p>
</li>
<li>
<p>汇编：由汇编程序将汇编语言源程序文件转换为<strong>可重定位的机器语言目标代码文件</strong></p>
</li>
<li>
<p>链接：由<strong>链接器</strong>将多个可重定位的机器语言目标文件以及库例程（如 <code>printf</code> 库函数）链接起来，生成最终的<strong>可执行目标文件</strong></p>
</li>
</ol>
<p><img src="https://oss.xiefeng.tech/images/20211026231522.png" alt=""/></p>
<h2>x86 架构</h2>
<p>x86 是 Intel 开发的一类处理器体系结构的泛称，包括 Intel 8086、80286、i386 和 i486 等，因此其架构被称为 “x86”</p>
<p>Intel 把 32 位 x86 架构的名称 x86-32 改称为 IA-32，IA 是 Intel Architecture 的缩写</p>
<p>兼容 IA-32 指令集的 64 位版本：</p>
<ul>
<li>
<p>命名为 “x86-64” ，有时也简称为 x64</p>
</li>
<li>
<p>AMD 首先提出，并称其为 AMD64</p>
</li>
<li>
<p>Intel 称其为 Intl64</p>
</li>
</ul>
<p>IA-32 架构由16位架构发展而来，虽然字长为32 位或更大 ，但一个字固定为 16 位，长度后缀为 w，32 位为双字，长度后缀为 l</p>
<h2>过程调用</h2>
<p>过程调用在使用机器级指令的一般执行步骤（P为调用者，Q为被调用者）</p>
<ol>
<li>P 保存被调用函数所需的参数，并且 Q 能够访问到这些参数</li>
<li>P 保存调用完成后的返回地址，然后控制转移到 Q</li>
<li>Q 保存 P的现场（将自己需要用到的寄存器入栈）</li>
<li>执行 Q 的过程体（函数体），为自己的局部变量分配空间</li>
<li>Q 恢复 P 的现场，释放过程占用的内存空间</li>
<li>Q 取出返回地址，并将控制转移到 P</li>
</ol>
<p>核心是需要<strong>保护现场</strong>和<strong>恢复现场</strong>，本质的原因是所有过程<strong>共享一套通用寄存器</strong></p>
<p>参数的传递可以通过寄存器，也可以通过栈，主要还是看寄存器和参数的数量</p>
<h3>栈和栈帧</h3>
<p>CPU 往往会提供栈操作的指令，主要是通过栈顶指针寄存器指示当前栈顶的位置，通过修改栈顶指针寄存器的值来实现入栈和出栈的操作</p>
<p>一个过程的调用会在栈中压入一个栈帧，栈帧本质上就是栈中的一块内存空间，其中存储了该过程调用中所有的局部变量和可能需要传递的参数，以及对父过程现场的保护（寄存器）</p>
<p>在可执行文件中存在一部分的空间分配给栈（往往栈顶在低地址部分，栈底在高地址部分），用于实现一个一个的过程调用</p>
<p><img src="https://oss.xiefeng.tech/images/20211028220624.png" alt=""/></p>
<p>所谓的栈还是存在于逻辑上，在内存的层面上不存在栈这种结构，只是通过栈的方式去操作内存去达到这种数据结构的特点</p>
<p>栈帧在不同的角度是不同的，通过 <code>push</code> 指令去入栈，那么栈帧意味着就是一个存储单元（字节）或者一个字等大小</p>
<p>而在过程调用的角度，一个栈帧就是一个过程调用所占用的内存大小，在 IA-32 往往通过 EBP 和 ESP 寄存器来表示栈顶的栈帧</p>
<p>在 x86-64 由于地址是 64 bit 的，所以使用 rbp 和 rsp 寄存器来表示当前过程调用的栈帧</p>
<h3>机器级表示</h3>
<pre><code class="language-c">int add(int x, int y) {
  return  x + y;
}

int caller() {
  int t1 = 125, t2 = 80;
  int sum = add(t1, t2);
  return sum;
}
</code></pre>
<p>可以将源码编译之后再反汇编，查看相关的过程调用指令</p>
<pre><code class="language-shell">gcc -o process_call process_call.c &amp;&amp; objdump -d process_call &gt; process_call.s
</code></pre>
<p>在 x86_64-redhat-linux 环境下进行编译，使用 objdump 可以得到该程序 <code>caller</code> 函数所对应的汇编指令</p>
<p><img src="https://oss.xiefeng.tech/images/20211104191221.png" alt=""/></p>
<h2>数据对齐</h2>
<p>在读写数据时主存按一个<strong>传送单位</strong>（字长）进行传输，这意味着如果传送单位为 64 位，则第 0<del>7 字节同时读写，第 8</del>15 字节同时读写</p>
<p>而内存按字节编址，所以如果要读取 <code>0x7 ~ 0x8</code> 这两个内存单元，则需要进行两次访存</p>
<p>指令系统支持对字节、半字、字及双字的运算，所以为了提高效率，编译器会让各种不同长度的数据存放时<strong>按边界对齐</strong></p>
<p>以 32 位系统为例，不同系统采用的内存对齐策略有些许差别</p>
<ul>
<li>
<p>Windows 采用策略</p>
<ul>
<li>char 型无需对齐</li>
<li>int 型地址是 4 的倍数、short 型地址是2 的倍数</li>
<li>float 型的是4 的倍数、double 和 long long 型的是8的倍数</li>
</ul>
</li>
<li>
<p>Linux采用更宽松策略</p>
<ul>
<li>short 型是2的倍数</li>
<li>其他类型如 int、 float、double 和指针等都是 4 的倍数</li>
</ul>
</li>
</ul>
<p>对于结构来说，<strong>结构变量首地址</strong>按 4 字节边界对齐，结构数组变量的最末可能需要插空，以使每个数组元素都按 4 字节边界对齐</p>
<p>对于成员相同的两个结构，两者所占用的空间并不相同：</p>
<pre><code class="language-c">struct c1 {
  int i;
  char c;
  int j;
};

struct c2 {
  int i;
  int j;
  char c;
};
</code></pre>
<p><img src="https://oss.xiefeng.tech/images/20211104193712.png" alt=""/></p><div><a href="/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"指令","article":{"title":"指令","content":"## CPU工作原理\n\n冯诺依曼式计算机采用**存储程序**的工作方式，数据和指令事先存放在存储器中，形式上没有差别\n\n每条指令和每个数据都有各自的地址，其中指令按序存放，PC 中存放着程序下一条需要执行指令的地址，指令由 OP、ADDR 字段组成\n\nCPU 能自动地取出一条一条指令执行无需人为干预，指令和数据被从存储器取到 CPU，存放在寄存器中，其中指令在 IR 中，数据在通用寄存器中\n\nCPU 执行指令的一般步骤：\n\n1. 从 PC 指向的地址中取出指令\n2. 修改 PC 的值，指向下一条指令\n3. 对指令进行译码\n4. 执行该条指令\n\n## 指令集体系结构\n\n指令集体系结构（ISA）是一种规约，它规定了如何使用硬件\n\n- 所有**可执行指令的集合**\n- 指令格式、操作种类以及每种操作对应的操作数的相应规定\n- 指令可以接受的操作数的类型\n- 操作数所能存放的寄存器组的结构，包括每个寄存器的名称、编号、 长度和用途\n- 操作数所能存放的存储空间的大小和编址方式\n- 操作数在存储空间存放时按照大端还是小端方式存放\n- 指令获取操作数的方式，即寻址方式\n- 指令执行过程的控制方式，包括程序计数器、条件码定义等\n\nISA 在计算机系统中是必不可少的一个**抽象层**，缺少 ISA 软件无法使用计算机硬件，一台计算机也不能称为“通用计算机“\n\nISA 和计算机组成（微体系结构）的关系：ISA 是计算机组成的抽象，同一种 ISA 可以有不同的计算机组成\n\n相当于 ISA 规定了接口，计算机组成是具体的实现方式，实现方式是不唯一的，例如：乘法指令可用 ALU 或乘法器实现\n\n## C 语言转换过程\n\n用 GCC 编译器套件进行转换的过程：\n\n1. 预处理：在高级语言源程序中插入所有用 `#include` 命令指定的文件和用 `#define` 声明指定的宏\n\n2. 编译：将预处理后的源程序文件编译生成相应的汇编语言程序\n\n3. 汇编：由汇编程序将汇编语言源程序文件转换为**可重定位的机器语言目标代码文件**\n\n4. 链接：由**链接器**将多个可重定位的机器语言目标文件以及库例程（如 `printf` 库函数）链接起来，生成最终的**可执行目标文件**\n\n\n![](https://oss.xiefeng.tech/images/20211026231522.png)\n\n## x86 架构\n\nx86 是 Intel 开发的一类处理器体系结构的泛称，包括 Intel 8086、80286、i386 和 i486 等，因此其架构被称为 “x86”\n\nIntel 把 32 位 x86 架构的名称 x86-32 改称为 IA-32，IA 是 Intel Architecture 的缩写\n\n兼容 IA-32 指令集的 64 位版本：\n\n- 命名为 “x86-64” ，有时也简称为 x64\n\n- AMD 首先提出，并称其为 AMD64\n- Intel 称其为 Intl64\n\nIA-32 架构由16位架构发展而来，虽然字长为32 位或更大 ，但一个字固定为 16 位，长度后缀为 w，32 位为双字，长度后缀为 l\n\n## 过程调用\n\n过程调用在使用机器级指令的一般执行步骤（P为调用者，Q为被调用者）\n\n1. P 保存被调用函数所需的参数，并且 Q 能够访问到这些参数\n2. P 保存调用完成后的返回地址，然后控制转移到 Q\n3. Q 保存 P的现场（将自己需要用到的寄存器入栈）\n4. 执行 Q 的过程体（函数体），为自己的局部变量分配空间\n5. Q 恢复 P 的现场，释放过程占用的内存空间\n6. Q 取出返回地址，并将控制转移到 P\n\n核心是需要**保护现场**和**恢复现场**，本质的原因是所有过程**共享一套通用寄存器**\n\n参数的传递可以通过寄存器，也可以通过栈，主要还是看寄存器和参数的数量\n\n### 栈和栈帧\n\nCPU 往往会提供栈操作的指令，主要是通过栈顶指针寄存器指示当前栈顶的位置，通过修改栈顶指针寄存器的值来实现入栈和出栈的操作\n\n一个过程的调用会在栈中压入一个栈帧，栈帧本质上就是栈中的一块内存空间，其中存储了该过程调用中所有的局部变量和可能需要传递的参数，以及对父过程现场的保护（寄存器）\n\n在可执行文件中存在一部分的空间分配给栈（往往栈顶在低地址部分，栈底在高地址部分），用于实现一个一个的过程调用\n\n![](https://oss.xiefeng.tech/images/20211028220624.png)\n\n所谓的栈还是存在于逻辑上，在内存的层面上不存在栈这种结构，只是通过栈的方式去操作内存去达到这种数据结构的特点\n\n栈帧在不同的角度是不同的，通过 `push` 指令去入栈，那么栈帧意味着就是一个存储单元（字节）或者一个字等大小\n\n而在过程调用的角度，一个栈帧就是一个过程调用所占用的内存大小，在 IA-32 往往通过 EBP 和 ESP 寄存器来表示栈顶的栈帧\n\n在 x86-64 由于地址是 64 bit 的，所以使用 rbp 和 rsp 寄存器来表示当前过程调用的栈帧\n\n### 机器级表示\n\n```c\nint add(int x, int y) {\n  return  x + y;\n}\n\nint caller() {\n  int t1 = 125, t2 = 80;\n  int sum = add(t1, t2);\n  return sum;\n}\n```\n\n可以将源码编译之后再反汇编，查看相关的过程调用指令\n\n```shell\ngcc -o process_call process_call.c \u0026\u0026 objdump -d process_call \u003e process_call.s\n```\n\n在 x86_64-redhat-linux 环境下进行编译，使用 objdump 可以得到该程序 `caller` 函数所对应的汇编指令\n\n![](https://oss.xiefeng.tech/images/20211104191221.png)\n\n## 数据对齐\n\n在读写数据时主存按一个**传送单位**（字长）进行传输，这意味着如果传送单位为 64 位，则第 0~7 字节同时读写，第 8~15 字节同时读写\n\n而内存按字节编址，所以如果要读取 `0x7 ~ 0x8` 这两个内存单元，则需要进行两次访存\n\n指令系统支持对字节、半字、字及双字的运算，所以为了提高效率，编译器会让各种不同长度的数据存放时**按边界对齐**\n\n以 32 位系统为例，不同系统采用的内存对齐策略有些许差别\n\n- Windows 采用策略\n\n  - char 型无需对齐\n  - int 型地址是 4 的倍数、short 型地址是2 的倍数\n  - float 型的是4 的倍数、double 和 long long 型的是8的倍数\n- Linux采用更宽松策略\n  - short 型是2的倍数\n  - 其他类型如 int、 float、double 和指针等都是 4 的倍数\n\n对于结构来说，**结构变量首地址**按 4 字节边界对齐，结构数组变量的最末可能需要插空，以使每个数组元素都按 4 字节边界对齐\n\n对于成员相同的两个结构，两者所占用的空间并不相同：\n\n```c\nstruct c1 {\n  int i;\n  char c;\n  int j;\n};\n\nstruct c2 {\n  int i;\n  int j;\n  char c;\n};\n```\n\n![](https://oss.xiefeng.tech/images/20211104193712.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","meta":{"size":6798,"birthTime":1663496641437.3179,"updateTime":1663496641437.5046}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["计算机系统","指令"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
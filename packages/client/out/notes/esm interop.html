<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>esm interop | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">esm interop</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><p>ES module本质上只有命名导出，默认导出只是名为default的命名导出的语法糖。所以一个模块可以同时具有默认导出和（普通的）命名导出</p>
<p>传统CommonJS中，如果<code>module.exports</code>是一个class或函数，就类似于默认导出，如果是一个用作namespace的plain object，就类似于命名导出。但<code>module.exports</code>本质上只是导出了一个值而已，所以这两种用法是互斥的。</p>
<p>理论上来说，ES module导入CommonJS模块，似乎问题不大。无论是命名导入还是默认导入，都是拿<code>module.exports</code></p>
<p>一个常见情况是，一个模块本身使用了ES module写，但是发布成CommonJS</p>
<p>如题主提到的React便是如此。这就让我们被迫要考虑如何把ES module映射到CommonJS上的问题。</p>
<p>道理上，ES module转成CommonJS，其default导出只能映射到<code>module.exports.default</code>上，而不能映射到CommonJS传统的<code>module.exports</code>上，因为ES module可以同时有命名导出，你无法让<code>module.exports</code>既是一个导出值，又是一个namespace object。（什么？你说在默认导出的函数上加个其他属性又不会死？嗯，那你考虑下默认导出为primitive值甚至为<code>null</code>的情况吧……）</p>
<p>转译出来的CommonJS模块中默认导出值是在<code>module.exports.default</code>上，而传统CommonJS模块中的默认导出值是在<code>module.exports</code>上。那么Babel/TypeScript等在<code>import x from &#x27;commonjs-module&#x27;</code>时咋知道到底应该是哪一个？如果不知道的话，结果就是前面说的Node.js试验性ESM类似的状况。</p>
<p>为此，Babel/TS等工具会对转译出来的CommonJS做记号，给<code>module.exports</code>上加一个属性<code>__esModule: true</code>。这样就可以区别了！</p>
<p>这个方式有个小毛病，在一般的CommonJS模块中导入转译的CommonJS模块就有点尴尬，因为没有编译器的帮忙，你得自己写：<code>const x = require(&#x27;m&#x27;).default</code></p>
<p><a href="https://www.zhihu.com/question/288322186">https://www.zhihu.com/question/288322186</a></p>
<p><a href="https://juejin.cn/post/7033392392866955278#heading-1">https://juejin.cn/post/7033392392866955278#heading-1</a></p><div><a href="/notes">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"esm interop","article":{"title":"esm interop","content":"ES module本质上只有命名导出，默认导出只是名为default的命名导出的语法糖。所以一个模块可以同时具有默认导出和（普通的）命名导出\n\n\n\n传统CommonJS中，如果`module.exports`是一个class或函数，就类似于默认导出，如果是一个用作namespace的plain object，就类似于命名导出。但`module.exports`本质上只是导出了一个值而已，所以这两种用法是互斥的。\n\n\n\n理论上来说，ES module导入CommonJS模块，似乎问题不大。无论是命名导入还是默认导入，都是拿`module.exports`\n\n\n\n一个常见情况是，一个模块本身使用了ES module写，但是发布成CommonJS\n\n如题主提到的React便是如此。这就让我们被迫要考虑如何把ES module映射到CommonJS上的问题。\n\n\n\n道理上，ES module转成CommonJS，其default导出只能映射到`module.exports.default`上，而不能映射到CommonJS传统的`module.exports`上，因为ES module可以同时有命名导出，你无法让`module.exports`既是一个导出值，又是一个namespace object。（什么？你说在默认导出的函数上加个其他属性又不会死？嗯，那你考虑下默认导出为primitive值甚至为`null`的情况吧……）\n\n\n\n转译出来的CommonJS模块中默认导出值是在`module.exports.default`上，而传统CommonJS模块中的默认导出值是在`module.exports`上。那么Babel/TypeScript等在`import x from 'commonjs-module'`时咋知道到底应该是哪一个？如果不知道的话，结果就是前面说的Node.js试验性ESM类似的状况。\n\n\n\n为此，Babel/TS等工具会对转译出来的CommonJS做记号，给`module.exports`上加一个属性`__esModule: true`。这样就可以区别了！\n\n\n\n这个方式有个小毛病，在一般的CommonJS模块中导入转译的CommonJS模块就有点尴尬，因为没有编译器的帮忙，你得自己写：`const x = require('m').default`\n\n\n\n\n\nhttps://www.zhihu.com/question/288322186\n\n\n\nhttps://juejin.cn/post/7033392392866955278#heading-1","meta":{"size":2049,"birthTime":1663496641420.1526,"updateTime":1663496641420.353}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["esm interop"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
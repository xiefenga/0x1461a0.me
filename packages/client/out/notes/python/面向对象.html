<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>面向对象 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#实例方法" data-target-id="h1-实例方法-0">实例方法</a></li><li><a href="#类方法、静态方法" data-target-id="h1-类方法、静态方法-1">类方法、静态方法</a><ul><li><a href="#类方法" data-target-id="h2-类方法-0">类方法</a></li><li><a href="#静态方法" data-target-id="h2-静态方法-1">静态方法</a></li></ul></li><li><a href="#装饰器" data-target-id="h1-装饰器-2">装饰器</a></li><li><a href="#AAAA" data-target-id="h1-AAAA-3">AAAA</a></li><li><a href="#存取器" data-target-id="h1-存取器-4">存取器</a></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">面向对象</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><pre><code class="language-python">class User : 
    def __init(self, name, age):
        self.name = name
        self.age = age
    def print(self):
        print(self.name, self.age)
    
</code></pre>
<h1>实例方法</h1>
<p>实例方法（包括构造函数）会自动绑定第一个参数 <code>self</code>：</p>
<ol>
<li>在构造函数中指向正在初始化的对象</li>
<li>在实例方法中指向正在调用的方法的对象</li>
</ol>
<p>即使将该实例方法赋值给一个变量，直接调用也无需手动绑定 <code>self</code></p>
<pre><code class="language-python">class Test: 
    def test(self):
        print(self)
test = Test().test
test()
Test().test()
</code></pre>
<p>通过类调用实例方法，不会执行自动绑定 self，需要手动传入</p>
<pre><code class="language-python">Test.test(&#x27;test&#x27;)
</code></pre>
<h1>类方法、静态方法</h1>
<h2>类方法</h2>
<p><code>@classmethod</code> 修饰的函数就是类方法，会自动绑定第一个参数 <code>cls</code> 为类本身</p>
<pre><code class="language-python">class Test:
    @classmethod
    def classTestMethod(cls):
        print(cls)
m = Test.classTestMethod
m()
Test.classTestMethod()
</code></pre>
<p>和实例方法类似，在通过类调用 / 赋值再调用会自动绑定 <code>cls</code> ，通过实例调用，也不需要传入第一参数，也会自动绑定为当前类</p>
<h2>静态方法</h2>
<p><code>@staticmethod</code> 修饰的函数是静态方法，不会自动绑定第一个参数</p>
<p>既可以通过类，也可以通过实例调用</p>
<pre><code class="language-python">class Test:
    @staticmethod
    def staticTestMethod(value):
        print(value)
Test.staticTestMethod(&#x27;Test&#x27;)
Test().staticTestMethod(&#x27;test&#x27;)
</code></pre>
<h1>装饰器</h1>
<p>通过 @ + 函数可用于修饰其他函数：</p>
<ol>
<li>将被修饰的函数作为参数传递给@后面的函数</li>
<li>将被修饰的函数替换为@后面的函数的返回值</li>
</ol>
<pre><code class="language-python">def funA(fn):
    print(&#x27;执行funA&#x27;)
    fn()
    return &#x27;AAAA&#x27;
@funA
def funB():
    print(&#x27;执行funB&#x27;)
#执行funA
#执行funB
print(funB) # AAAA
</code></pre>
<h1>存取器</h1>
<p>通过 <code>property</code> 函数： <code>property(getter=None, setter=None, delete=None, doc=None)</code></p>
<pre><code class="language-python"></code></pre>
<p>通过 <code>@property</code> 装饰器</p>
<pre><code class="language-python"></code></pre><div><a href="/notes/python">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"面向对象","article":{"title":"面向对象","content":"```python\r\nclass User : \r\n    def __init(self, name, age):\r\n        self.name = name\r\n        self.age = age\r\n    def print(self):\r\n        print(self.name, self.age)\r\n    \r\n```\r\n\r\n# 实例方法\r\n\r\n实例方法（包括构造函数）会自动绑定第一个参数 `self`：\r\n\r\n1. 在构造函数中指向正在初始化的对象\r\n2. 在实例方法中指向正在调用的方法的对象\r\n\r\n即使将该实例方法赋值给一个变量，直接调用也无需手动绑定 `self`\r\n\r\n```python\r\nclass Test: \r\n    def test(self):\r\n        print(self)\r\ntest = Test().test\r\ntest()\r\nTest().test()\r\n```\r\n\r\n通过类调用实例方法，不会执行自动绑定 self，需要手动传入\r\n\r\n```python\r\nTest.test('test')\r\n```\r\n\r\n# 类方法、静态方法\r\n\r\n## 类方法\r\n\r\n`@classmethod` 修饰的函数就是类方法，会自动绑定第一个参数 `cls` 为类本身\r\n\r\n```python\r\nclass Test:\r\n    @classmethod\r\n    def classTestMethod(cls):\r\n        print(cls)\r\nm = Test.classTestMethod\r\nm()\r\nTest.classTestMethod()\r\n```\r\n\r\n和实例方法类似，在通过类调用 / 赋值再调用会自动绑定 `cls` ，通过实例调用，也不需要传入第一参数，也会自动绑定为当前类\r\n\r\n## 静态方法\r\n\r\n`@staticmethod` 修饰的函数是静态方法，不会自动绑定第一个参数\r\n\r\n既可以通过类，也可以通过实例调用\r\n\r\n```python\r\nclass Test:\r\n    @staticmethod\r\n    def staticTestMethod(value):\r\n        print(value)\r\nTest.staticTestMethod('Test')\r\nTest().staticTestMethod('test')\r\n```\r\n\r\n# 装饰器\r\n\r\n通过 @ + 函数可用于修饰其他函数：\r\n\r\n1. 将被修饰的函数作为参数传递给@后面的函数\r\n2. 将被修饰的函数替换为@后面的函数的返回值\r\n\r\n```python\r\ndef funA(fn):\r\n    print('执行funA')\r\n    fn()\r\n    return 'AAAA'\r\n@funA\r\ndef funB():\r\n    print('执行funB')\r\n#执行funA\r\n#执行funB\r\nprint(funB) # AAAA\r\n```\r\n\r\n# 存取器\r\n\r\n通过 `property` 函数： `property(getter=None, setter=None, delete=None, doc=None)`\r\n\r\n```python\r\n\r\n```\r\n\r\n通过 `@property` 装饰器\r\n\r\n```python\r\n\r\n```\r\n\r\n","meta":{"size":2075,"birthTime":1663496641422.1567,"updateTime":1663496641422.2761}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["python","面向对象"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
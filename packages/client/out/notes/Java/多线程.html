<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>多线程 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#开启线程" data-target-id="h1-开启线程-0">开启线程</a></li><li><a href="#内存布局" data-target-id="h1-内存布局-1">内存布局</a></li><li><a href="#线程状态" data-target-id="h1-线程状态-2">线程状态</a></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">多线程</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h1>开启线程</h1>
<p>每一个 Java 程序启动后，会默认开启一个主线程，也就是 main 方法所在的线程。</p>
<p>每一个 线程都是 java.lang.Thread 对象，可以通过 Thread. currentThread 方法获取当前的线程对象。</p>
<ol>
<li>
<p>传入 Runnable 接口实例</p>
<pre><code class="language-java">Thread thread = new Thread(() -&gt; System.out.println(Thread.currentThread()));
thread.start();
</code></pre>
</li>
<li>
<p>继承 Thread，重写 run 方法</p>
<pre><code class="language-java">public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println(Thread.currentThread());
    }
}

public static void main(String[] args) {
    Thread thread = new MyThread();
    thread.start();
}
</code></pre>
</li>
</ol>
<p>调用 <code>thread.start</code> 方法会启动线程，<code>start</code> 方法会自动调用 <code>thread</code> 的 <code>run</code> 方法。Thread 实现了 Runnable 接口。</p>
<h1>内存布局</h1>
<ul>
<li>PC 寄存器（Program Counter Register）：每一个线程都有自己的 PC 寄存器</li>
<li>Java 虚拟机栈（Java Virtual Machine Stack）：每一个线程都有自己的 Java 虚拟机栈</li>
<li>堆（Heap）：多个线程共享堆</li>
<li>方法区（Method Area）：多个线程共享方法区</li>
<li>本地方法栈（Native Method Stack）：每一个线程都有自己的本地方法栈</li>
</ul>
<h1>线程状态</h1>
<p>可以通过实例方法 <code>getState</code> 获得线程的状态。</p>
<p>线程一共有 6 种状态：</p>
<ul>
<li><code>NEW</code>：尚未启动，新建状态</li>
<li><code>RUNNABLE</code>：正在 jvm 中运行，或者正在等待操作系统的资源（比如处理器）</li>
<li><code>BLOCKED</code>：正在等待监视器锁（内部锁），阻塞状态</li>
<li><code>WAITING</code>：正在等待另一个线程，等待状态</li>
<li></li>
</ul><div><a href="/notes/Java">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"多线程","article":{"title":"多线程","content":"# 开启线程\r\n\r\n每一个 Java 程序启动后，会默认开启一个主线程，也就是 main 方法所在的线程。\r\n\r\n每一个 线程都是 java.lang.Thread 对象，可以通过 Thread. currentThread 方法获取当前的线程对象。\r\n\r\n1. 传入 Runnable 接口实例\r\n\r\n\t```java\r\n\tThread thread = new Thread(() -\u003e System.out.println(Thread.currentThread()));\r\n\tthread.start();\r\n\t```\r\n\r\n2. 继承 Thread，重写 run 方法\r\n\r\n\t```java\r\n\tpublic class MyThread extends Thread {\r\n\t    @Override\r\n\t    public void run() {\r\n\t        System.out.println(Thread.currentThread());\r\n\t    }\r\n\t}\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t    Thread thread = new MyThread();\r\n\t    thread.start();\r\n\t}\r\n\t```\r\n\r\n调用 `thread.start` 方法会启动线程，`start` 方法会自动调用 `thread` 的 `run` 方法。Thread 实现了 Runnable 接口。\r\n\r\n# 内存布局\r\n\r\n- PC 寄存器（Program Counter Register）：每一个线程都有自己的 PC 寄存器\r\n- Java 虚拟机栈（Java Virtual Machine Stack）：每一个线程都有自己的 Java 虚拟机栈\r\n- 堆（Heap）：多个线程共享堆\r\n- 方法区（Method Area）：多个线程共享方法区\r\n- 本地方法栈（Native Method Stack）：每一个线程都有自己的本地方法栈\r\n\r\n# 线程状态\r\n\r\n可以通过实例方法 `getState` 获得线程的状态。\r\n\r\n线程一共有 6 种状态：\r\n\r\n- `NEW`：尚未启动，新建状态\r\n- `RUNNABLE`：正在 jvm 中运行，或者正在等待操作系统的资源（比如处理器）\r\n- `BLOCKED`：正在等待监视器锁（内部锁），阻塞状态\r\n- `WAITING`：正在等待另一个线程，等待状态\r\n- ","meta":{"size":1656,"birthTime":1663496641380.8762,"updateTime":1663496641381.069}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["Java","多线程"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
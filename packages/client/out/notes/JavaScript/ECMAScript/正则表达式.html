<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>正则表达式 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#创建RegExp" data-target-id="h1-创建RegExp-0">创建RegExp</a></li><li><a href="#RegExp的实例成员" data-target-id="h1-RegExp的实例成员-1">RegExp的实例成员</a></li><li><a href="#String和正则相关的方法" data-target-id="h1-String和正则相关的方法-2">String和正则相关的方法</a></li><li><a href="#正则表达式的字符" data-target-id="h1-正则表达式的字符-3">正则表达式的字符</a></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">正则表达式</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h1>创建RegExp</h1>
<ol>
<li>
<p>字面量</p>
<blockquote>
<p><code>/pattern/flags</code></p>
</blockquote>
<ul>
<li><code>pattern</code> 正则表达式的文本</li>
<li><code>flags</code>用于指定匹配方式，可以省略该参数<!-- -->
<ul>
<li><code>g</code> 全局匹配（查找所有匹配而非在找到第一个匹配后停止）</li>
<li><code>i</code> 忽略大小写匹配</li>
<li><code>m</code> 多行匹配</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">var reg = /abc/i;
</code></pre>
</li>
<li>
<p>构造函数</p>
<blockquote>
<p><code>new RegExp(pattern, flags)</code>	构造函数的参数需要使用引号</p>
</blockquote>
<p><code>pattern</code>可以为另一个正则表达式对象</p>
<pre><code class="language-javascript">var reg = new RegExp(&#x27;abc&#x27;, &#x27;i&#x27;);
</code></pre>
<pre><code class="language-javascript">var reg = RegExp(&#x27;abc&#x27;, &#x27;i&#x27;);
</code></pre>
<p>两种用法的区别：当<code>pattern</code>为另一个正则表达式对象时，<code>new</code>的会返回一个新的但是和<code>pattern</code>一样的对象，直接调用会直接返回<code>pattern</code>；</p>
</li>
</ol>
<h1>RegExp的实例成员</h1>
<ul>
<li>
<p><code>source</code>    该正则表达式的内容</p>
</li>
<li>
<p><code>lastIndex</code>    标示开始下一次匹配的字符位置</p>
</li>
<li>
<p><code>test(str)</code></p>
<p>检索字符串是否满足规则</p>
<ul>
<li>
<p>返回 <code>true</code> 或 <code>false</code></p>
</li>
<li>
<p>如果是全局匹配，多次匹配会根据 <code>lastIndex</code> 的值来匹配</p>
</li>
</ul>
</li>
<li>
<p><code>exec(str)</code></p>
<p>用于检索字符串中的正则表达式的匹配</p>
<ul>
<li>
<p>该函数的返回值为一个<strong>数组</strong>，如果未找到匹配，则返回值为 <code>null</code></p>
</li>
<li>
<p><code>0</code> 是匹配成功的字符串 ， <code>1~n</code> 分别为捕获到的分组，</p>
</li>
<li>
<p><code>index</code> 是匹配到的字符串起始的索引，<code>input</code> 是原始字符串；</p>
</li>
<li>
<p>如果设置了<code>g</code>便可以多次调用该方法，会根据 <code>lastIndex</code> 来进行</p>
</li>
</ul>
</li>
</ul>
<h1>String和正则相关的方法</h1>
<ul>
<li>
<p><code>match(regexp)</code></p>
<p>如果传入一个非正则表达式对象，则会隐式地使用 <code>new RegExp(obj)</code> 将其转换为一个 <code>RegExp</code></p>
<p>返回值为数组，是否使用全局匹配返回的数组是不同的</p>
</li>
<li>
<p><code>search(regexp)</code></p>
<p>如果传入一个非正则表达式对象 <code>obj</code>，则会使用 <code>new RegExp(obj)</code> 隐式地将其转换为正则表达式对象</p>
<p>如果匹配成功，则 <code>search()</code> 返回正则表达式在字符串中首次匹配项的索引;否则，返回 <strong>-1</strong></p>
</li>
<li>
<p><code>replace()</code></p>
<p>返回被替换后的新字符串</p>
<blockquote>
<p><code>str.replace(regexp|substr, newSubStr|function)</code></p>
</blockquote>
<ul>
<li>替换字符串可以插入一些特殊带 <code>$</code> 的变量名；</li>
<li>可以指定一个函数作为第二个参数，当匹配执行后就会调用函数，返回值作为替换字符串；如果第一个参数是<code>reg</code> 并且其为<code>g</code>，那么每次匹配都会调用该函数的参数分别为匹配到的字符串、捕获到的分组</li>
</ul>
</li>
</ul>
<h1>正则表达式的字符</h1>
<ul>
<li>
<p><strong>字符集合</strong></p>
<blockquote>
<p>用于查找某个范围内的字符</p>
</blockquote>
<ul>
<li>
<p><code>[abc]</code></p>
<p>一个字符集合，也叫字符组，匹配集合中的任意一个字符，可以使用<code>-</code>指定一个范围</p>
</li>
<li>
<p><code>[^abc]</code></p>
<p>一个反义或补充字符集，也叫反义字符组。也就是说，它匹配任意不在括号内的字符</p>
</li>
</ul>
</li>
<li>
<p><strong>分组</strong></p>
<ul>
<li>
<p><code>(x)</code></p>
<p>匹配 <code>x</code> 并且捕获匹配项，被匹配的子字符串可以在结果数组的元素 <code>[1], ..., [n]</code> 中找到</p>
</li>
<li>
<p><code>\n</code></p>
<p><code> n</code> 是一个正整数。一个反向引用（back reference），指向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串</p>
</li>
<li>
<p><code>(?:x)</code></p>
<p>非捕获组，匹配 <code>x</code> 不会捕获匹配项</p>
</li>
</ul>
</li>
<li>
<p><strong>元字符</strong></p>
<blockquote>
<p>是拥有特殊含义的字符</p>
</blockquote>
<ul>
<li>
<p><code>.</code></p>
<ul>
<li>匹配任意单个字符，但是行结束符除外：<code>\n</code> <code>\r</code> <code>\u2028</code> 或 <code>\u2029</code></li>
</ul>
</li>
<li>
<p><code>\w</code>、<code>\W</code></p>
<p>匹配任意的字母数字和下划线，等价于 <code>[A-Za-z0-9_]</code>；匹配任意不是字母数字下划线的字符</p>
</li>
<li>
<p><code>\d</code>、<code>\D</code></p>
<p>匹配任意阿拉伯数字，等价于<code>[0-9]</code>；匹配任意一个不是阿拉伯数字的字符</p>
</li>
<li>
<p><code>\s</code>、<code>\S</code></p>
<ul>
<li>匹配一个空白符(包括空格、制表符、换页符、换行符等)；匹配一个非空白符</li>
</ul>
</li>
<li>
<p><code>\b</code>、<code>\B</code></p>
<p>匹配单词边界；匹配非单词边界</p>
</li>
<li>
<p><code>\uxxxx</code></p>
<p>查找以十六进制数 <code>xxxx</code> 规定的 Unicode 字符。</p>
</li>
</ul>
</li>
<li>
<p><strong>边界</strong></p>
<ul>
<li>
<p><code>^x</code></p>
<p>匹配以<code>x</code>开头的字符串，如果设置了<code>m</code>，该字符也会匹配一个断行符后的开始处</p>
</li>
<li>
<p><code>x$</code></p>
<p>匹配<code>x</code>结尾的字符串，如果设置了<code>m</code>，该字符也会匹配一个断行符的前的结尾处</p>
</li>
</ul>
</li>
<li>
<p><strong>量词</strong></p>
<ul>
<li>
<p><code>x*</code> 、 <code>x+ </code>、 <code>x?</code></p>
<p>匹配 <code>x</code> 0 次或多次 、 匹配 <code>x</code> 至少 1 次 、 匹配 <code>x</code> 0 次或 1 次（贪婪原则）</p>
</li>
<li>
<p><code>x*?</code> 、<code>x+?</code></p>
<p>匹配最小可能匹配</p>
</li>
<li>
<p><code>x{n}</code> 、  <code>x{n, }</code> 、 <code>x{n, m}</code></p>
<p>匹配 <code>x</code> <code>n</code>次 、 匹配 <code>x</code>  至少 <code>n</code> 次 、 匹配 <code>x</code> 至少 <code>n</code> 次 至多 <code>m</code> 次</p>
</li>
<li>
<p><code>x|y</code></p>
<p>匹配 <code>x</code> 或 <code>y</code></p>
</li>
</ul>
</li>
<li>
<p><strong>断言</strong></p>
<ul>
<li>
<p><code>x(?=y)</code> 、 <code>x(?!y)</code></p>
<p>仅匹配被 <code>y</code> 跟随的 <code>x</code> 、 仅匹配不被 <code>y</code> 跟随的 <code>x</code></p>
</li>
<li>
<p><code>(?&lt;=y)x </code>、 <code>(?&lt;!y)x</code></p>
<p><code>x</code> 只有在 <code>y</code> 后面才匹配 、 <code>x</code> 只有不在 <code>y</code> 后面才匹配</p>
</li>
</ul>
</li>
</ul><div><a href="/notes/JavaScript/ECMAScript">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"正则表达式","article":{"title":"正则表达式","content":"# 创建RegExp\r\n\r\n1. 字面量\r\n\r\n   \u003e `/pattern/flags`\r\n\r\n   - `pattern` 正则表达式的文本\r\n   - `flags`用于指定匹配方式，可以省略该参数\r\n     - `g` 全局匹配（查找所有匹配而非在找到第一个匹配后停止）\r\n     - `i` 忽略大小写匹配\r\n     - `m` 多行匹配\r\n\r\n   ```javascript\r\n   var reg = /abc/i;\r\n   ```\r\n\r\n2. 构造函数\r\n\r\n   \u003e `new RegExp(pattern, flags)`\t构造函数的参数需要使用引号\r\n\r\n   `pattern`可以为另一个正则表达式对象\r\n\r\n   ```javascript\r\n   var reg = new RegExp('abc', 'i');\r\n   ```\r\n\r\n   ```javascript\r\n   var reg = RegExp('abc', 'i');\r\n   ```\r\n\r\n   两种用法的区别：当`pattern`为另一个正则表达式对象时，`new`的会返回一个新的但是和`pattern`一样的对象，直接调用会直接返回`pattern`；\r\n\r\n# RegExp的实例成员\r\n\r\n- `source`    该正则表达式的内容\r\n- `lastIndex`    标示开始下一次匹配的字符位置\r\n\r\n- `test(str)`\r\n\r\n  检索字符串是否满足规则\r\n\r\n  - 返回 `true` 或 `false`\r\n\r\n  - 如果是全局匹配，多次匹配会根据 `lastIndex` 的值来匹配\r\n\r\n- `exec(str)`\r\n\r\n  用于检索字符串中的正则表达式的匹配\r\n\r\n  - 该函数的返回值为一个**数组**，如果未找到匹配，则返回值为 `null`\r\n\r\n  - `0` 是匹配成功的字符串 ， `1~n` 分别为捕获到的分组，\r\n  - `index` 是匹配到的字符串起始的索引，`input` 是原始字符串；\r\n  - 如果设置了`g`便可以多次调用该方法，会根据 `lastIndex` 来进行\r\n\r\n\r\n# String和正则相关的方法\r\n\r\n- `match(regexp)`\r\n\r\n  如果传入一个非正则表达式对象，则会隐式地使用 `new RegExp(obj)` 将其转换为一个 `RegExp` \r\n\r\n  返回值为数组，是否使用全局匹配返回的数组是不同的\r\n\r\n- `search(regexp)`\r\n\r\n  如果传入一个非正则表达式对象 `obj`，则会使用 `new RegExp(obj)` 隐式地将其转换为正则表达式对象\r\n\r\n  如果匹配成功，则 `search()` 返回正则表达式在字符串中首次匹配项的索引;否则，返回 **-1**\r\n\r\n- `replace()`\r\n\r\n  返回被替换后的新字符串\r\n\r\n  \u003e `str.replace(regexp|substr, newSubStr|function)`\r\n  \r\n  - 替换字符串可以插入一些特殊带 `$` 的变量名；\r\n  - 可以指定一个函数作为第二个参数，当匹配执行后就会调用函数，返回值作为替换字符串；如果第一个参数是`reg` 并且其为`g`，那么每次匹配都会调用该函数的参数分别为匹配到的字符串、捕获到的分组\r\n\r\n# 正则表达式的字符\r\n\r\n- **字符集合**\r\n\r\n  \u003e 用于查找某个范围内的字符\r\n\r\n  - `[abc]`\r\n\r\n    一个字符集合，也叫字符组，匹配集合中的任意一个字符，可以使用`-`指定一个范围\r\n\r\n  - `[^abc]`\r\n  \r\n    一个反义或补充字符集，也叫反义字符组。也就是说，它匹配任意不在括号内的字符\r\n  \r\n- **分组**\r\n\r\n  - `(x)`\r\n\r\n    匹配 `x` 并且捕获匹配项，被匹配的子字符串可以在结果数组的元素 `[1], ..., [n]` 中找到\r\n\r\n  - `\\n`\r\n\r\n    ` n` 是一个正整数。一个反向引用（back reference），指向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串\r\n    \r\n  - `(?:x)`\r\n\r\n    非捕获组，匹配 `x` 不会捕获匹配项\r\n\r\n- **元字符**\r\n\r\n  \u003e 是拥有特殊含义的字符\r\n\r\n  - `.`\r\n\r\n    - 匹配任意单个字符，但是行结束符除外：`\\n` `\\r` `\\u2028` 或 `\\u2029`\r\n\r\n  - `\\w`、`\\W`\r\n\r\n    匹配任意的字母数字和下划线，等价于 `[A-Za-z0-9_]`；匹配任意不是字母数字下划线的字符\r\n\r\n  - `\\d`、`\\D`\r\n\r\n    匹配任意阿拉伯数字，等价于`[0-9]`；匹配任意一个不是阿拉伯数字的字符\r\n\r\n  - `\\s`、`\\S`\r\n\r\n    - 匹配一个空白符(包括空格、制表符、换页符、换行符等)；匹配一个非空白符\r\n\r\n  - `\\b`、`\\B`\r\n\r\n    匹配单词边界；匹配非单词边界 \r\n\r\n  - `\\uxxxx`\r\n\r\n    查找以十六进制数 `xxxx` 规定的 Unicode 字符。\r\n\r\n- **边界**\r\n\r\n  - `^x`\r\n\r\n    匹配以`x`开头的字符串，如果设置了`m`，该字符也会匹配一个断行符后的开始处\r\n\r\n  - `x$`\r\n\r\n    匹配`x`结尾的字符串，如果设置了`m`，该字符也会匹配一个断行符的前的结尾处\r\n\r\n- **量词**\r\n\r\n  - `x*` 、 `x+ `、 `x?`\r\n\r\n    匹配 `x` 0 次或多次 、 匹配 `x` 至少 1 次 、 匹配 `x` 0 次或 1 次（贪婪原则）\r\n\r\n  - `x*?` 、`x+?`\r\n\r\n    匹配最小可能匹配\r\n\r\n  - `x{n}` 、  `x{n, }` 、 `x{n, m}`\r\n\r\n    匹配 `x` `n`次 、 匹配 `x`  至少 `n` 次 、 匹配 `x` 至少 `n` 次 至多 `m` 次\r\n\r\n  - `x|y`\r\n\r\n    匹配 `x` 或 `y`\r\n\r\n- **断言** \r\n\r\n  - `x(?=y)` 、 `x(?!y)`\r\n\r\n    仅匹配被 `y` 跟随的 `x` 、 仅匹配不被 `y` 跟随的 `x`\r\n\r\n  - `(?\u003c=y)x `、 `(?\u003c!y)x`\r\n\r\n    `x` 只有在 `y` 后面才匹配 、 `x` 只有不在 `y` 后面才匹配\r\n\r\n\r\n","meta":{"size":4923,"birthTime":1663496641393.9146,"updateTime":1663496641394.0315}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["JavaScript","ECMAScript","正则表达式"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
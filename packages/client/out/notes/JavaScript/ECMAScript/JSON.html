<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>JSON | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#stringify" data-target-id="h1-stringify-0">stringify</a><ul><li><a href="#过滤" data-target-id="h2-过滤-0">过滤</a></li><li><a href="#缩进" data-target-id="h2-缩进-1">缩进</a></li><li><a href="#toJSON" data-target-id="h2-toJSON-2">toJSON</a></li></ul></li><li><a href="#parse" data-target-id="h1-parse-1">parse</a></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">JSON</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h1>stringify</h1>
<p>在序列化 JavaScript 对象时，函数和原型成员都会被省略，值为 <code>undefined</code> 的任何属性也会被跳过，只会保留符合JSON格式的数据</p>
<p>该方法可以传递任何 JavaScript 值，对于符合 JSON 格式的值，也会返回字符串表示，其余返回 <code>undefined</code></p>
<pre><code class="language-javascript">JSON.stringify(1234)	// &#x27;1234&#x27;
JSON.stringify(&#x27;1234&#x27;)	// &#x27;&quot;1234&quot;&#x27;
JSON.stringify([1, 2, 3])	// &#x27;[1,2,3,4]&#x27;
</code></pre>
<p><strong>序列化选项</strong></p>
<p><code>JSON.stringify()</code> 方法除了要序列化的对象，还可以接收两个参数，这两个参数可以用于指定其他序列化 JavaScript 对象的方式。</p>
<p>第一个参数是过滤器，可以是数组或函数；第二个参数是用于缩进结果 JSON 字符串的选项。</p>
<h2>过滤</h2>
<ul>
<li>
<p>如果第二个参数是一个数组，那么 <code>JSON.stringify()</code> 返回的结果只会包含该数组中列出的对象属性</p>
<pre><code class="language-javascript">const book = {
  title: &quot;Professional JavaScript&quot;,
  authors: [
    &quot;Nicholas C. Zakas&quot;,
    &quot;Matt Frisbie&quot;
  ],
  edition: 4,
  year: 2017
}
JSON.stringify(book, [&quot;title&quot;, &quot;edition&quot;]) // {&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;edition&quot;:4}
</code></pre>
</li>
<li>
<p>如果第二个参数是一个函数，则函数的返回值就是该属性对应的值，返回 <code>undefined</code> 会导致该属性被忽略</p>
<pre><code class="language-javascript">JSON.stringify(book, (key, value) =&gt; {
  switch(key) {
    case &quot;authors&quot;:
      return value.join(&quot;,&quot;)
    case &quot;year&quot;:
      return 5000
    case &quot;edition&quot;:
      return undefined
    default:
      return value
  }
})
// {&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:&quot;Nicholas C. Zakas,MattFrisbie&quot;,&quot;year&quot;:5000} 
</code></pre>
</li>
</ul>
<h2>缩进</h2>
<p><code>JSON.stringify()</code> 第三个参数控制缩进</p>
<ul>
<li>
<p>在这个参数是数值时，会自动插入换行符并缩进相应的数值，最大缩进值为 10，大于 10 的值会自动设置为 10</p>
<pre><code class="language-javascript">JSON.stringify(book, null, 4)
/*
{
    &quot;title&quot;: &quot;Professional JavaScript&quot;,
    &quot;authors&quot;: [
        &quot;Nicholas C. Zakas&quot;,
        &quot;Matt Frisbie&quot;
    ],
    &quot;edition&quot;: 4,
    &quot;year&quot;: 2017
}
*/
</code></pre>
</li>
<li>
<p>如果缩进参数是一个字符串，就会使用这个字符串来缩进，如果字符串长度超过 10，则会在第 10 个字符处截断</p>
<pre><code class="language-javascript">JSON.stringify(book, null, &quot;--&quot; )
/*
{
--&quot;title&quot;: &quot;Professional JavaScript&quot;,
--&quot;authors&quot;: [
----&quot;Nicholas C. Zakas&quot;,
----&quot;Matt Frisbie&quot;
--],
--&quot;edition&quot;: 4,
--&quot;year&quot;: 2017
}
*/
</code></pre>
</li>
</ul>
<h2>toJSON</h2>
<p>有时候，对象需要在 <code>JSON.stringify()</code> 之上自定义 JSON 序列化</p>
<p>可以在要序列化的对象中添加 <code>toJSON()</code> 方法，序列化时会基于这个方法返回适当的 JSON 表示</p>
<p>原生 <code>Date</code> 对象就 有一个 <code>toJSON()</code> 方法，能够自动将 JavaScript 的 <code>Date</code> 对象转换为 ISO 8601 日期字符串</p>
<p>对于嵌套对象返回 <code>undefined</code> 会导致，该属性被略过，对于其他值返回什么值就是什么</p>
<p>在使用了该方法时，序列化的步骤：</p>
<ol>
<li>如果可以获取实际的值，则调用 <code>toJSON()</code> 方法获取实际的值，否则使用默认的值进行序列化</li>
<li>如果提供了第二个参数，则应用过滤</li>
<li>顾虑函数返回的每个值都会相应地进行序列化，所以字符串会被序列化为带双引号的字符串，<code>&#x27;1&#x27;</code> 会被序列化为 <code>&#x27;&quot;1&quot;&#x27;</code></li>
<li>如果提供了第三个参数，则相应地进行缩进</li>
</ol>
<h1>parse</h1>
<p>如果给 <code>JSON.parse()</code> 传入的 JSON 字符串无效，则会导致抛出错误</p>
<p><code>JSON.parse()</code> 方法也可以接收一个额外的函数，该函数会针对每个键值对都调用一次</p>
<p>该函数也接收两个参数：属性名和属性值，返回值即为该属性最终的属性值，返回 <code>undefined</code>，则结果中就会删除相应的项</p>
<p>使用该函数可以将日期字符串转换为 <code>Date</code> 对象：</p>
<pre><code class="language-javascript">const book = {
  title: &quot;Professional JavaScript&quot;,
  authors: [
    &quot;Nicholas C. Zakas&quot;,
    &quot;Matt Frisbie&quot;
  ],
  edition: 4,
  year: 2017,
  releaseDate: new Date(2017, 11, 1)
}
const jsonText = JSON.stringify(book)
const bookCopy = JSON.parse(
  jsonText, 
  (key, value) =&gt; key == &quot;releaseDate&quot; ? new Date(value) : value
)
</code></pre><div><a href="/notes/JavaScript/ECMAScript">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"JSON","article":{"title":"JSON","content":"# stringify\r\n\r\n在序列化 JavaScript 对象时，函数和原型成员都会被省略，值为 `undefined` 的任何属性也会被跳过，只会保留符合JSON格式的数据\r\n\r\n该方法可以传递任何 JavaScript 值，对于符合 JSON 格式的值，也会返回字符串表示，其余返回 `undefined`\r\n\r\n```javascript\r\nJSON.stringify(1234)\t// '1234'\r\nJSON.stringify('1234')\t// '\"1234\"'\r\nJSON.stringify([1, 2, 3])\t// '[1,2,3,4]'\r\n```\r\n\r\n**序列化选项**\r\n\r\n`JSON.stringify()` 方法除了要序列化的对象，还可以接收两个参数，这两个参数可以用于指定其他序列化 JavaScript 对象的方式。\r\n\r\n第一个参数是过滤器，可以是数组或函数；第二个参数是用于缩进结果 JSON 字符串的选项。\r\n\r\n## 过滤\r\n\r\n- 如果第二个参数是一个数组，那么 `JSON.stringify()` 返回的结果只会包含该数组中列出的对象属性\r\n\r\n  ```javascript\r\n  const book = {\r\n    title: \"Professional JavaScript\",\r\n    authors: [\r\n      \"Nicholas C. Zakas\",\r\n      \"Matt Frisbie\"\r\n    ],\r\n    edition: 4,\r\n    year: 2017\r\n  }\r\n  JSON.stringify(book, [\"title\", \"edition\"]) // {\"title\":\"Professional JavaScript\",\"edition\":4}\r\n  ```\r\n\r\n- 如果第二个参数是一个函数，则函数的返回值就是该属性对应的值，返回 `undefined` 会导致该属性被忽略\r\n\r\n  ```javascript\r\n  JSON.stringify(book, (key, value) =\u003e {\r\n    switch(key) {\r\n      case \"authors\":\r\n        return value.join(\",\")\r\n      case \"year\":\r\n        return 5000\r\n      case \"edition\":\r\n        return undefined\r\n      default:\r\n        return value\r\n    }\r\n  })\r\n  // {\"title\":\"Professional JavaScript\",\"authors\":\"Nicholas C. Zakas,MattFrisbie\",\"year\":5000} \r\n  ```\r\n\r\n## 缩进\r\n\r\n`JSON.stringify()` 第三个参数控制缩进\r\n\r\n- 在这个参数是数值时，会自动插入换行符并缩进相应的数值，最大缩进值为 10，大于 10 的值会自动设置为 10\r\n\r\n  ```javascript\r\n  JSON.stringify(book, null, 4)\r\n  /*\r\n  {\r\n      \"title\": \"Professional JavaScript\",\r\n      \"authors\": [\r\n          \"Nicholas C. Zakas\",\r\n          \"Matt Frisbie\"\r\n      ],\r\n      \"edition\": 4,\r\n      \"year\": 2017\r\n  }\r\n  */\r\n  ```\r\n\r\n- 如果缩进参数是一个字符串，就会使用这个字符串来缩进，如果字符串长度超过 10，则会在第 10 个字符处截断\r\n\r\n  ```javascript\r\n  JSON.stringify(book, null, \"--\" )\r\n  /*\r\n  {\r\n  --\"title\": \"Professional JavaScript\",\r\n  --\"authors\": [\r\n  ----\"Nicholas C. Zakas\",\r\n  ----\"Matt Frisbie\"\r\n  --],\r\n  --\"edition\": 4,\r\n  --\"year\": 2017\r\n  }\r\n  */\r\n  ```\r\n\r\n##  toJSON\r\n\r\n有时候，对象需要在 `JSON.stringify()` 之上自定义 JSON 序列化\r\n\r\n可以在要序列化的对象中添加 `toJSON()` 方法，序列化时会基于这个方法返回适当的 JSON 表示\r\n\r\n原生 `Date` 对象就 有一个 `toJSON()` 方法，能够自动将 JavaScript 的 `Date` 对象转换为 ISO 8601 日期字符串\r\n\r\n对于嵌套对象返回 `undefined` 会导致，该属性被略过，对于其他值返回什么值就是什么\r\n\r\n在使用了该方法时，序列化的步骤：\r\n\r\n1.  如果可以获取实际的值，则调用 `toJSON()` 方法获取实际的值，否则使用默认的值进行序列化\r\n2.  如果提供了第二个参数，则应用过滤\r\n3. 顾虑函数返回的每个值都会相应地进行序列化，所以字符串会被序列化为带双引号的字符串，`'1'` 会被序列化为 `'\"1\"'`\r\n4. 如果提供了第三个参数，则相应地进行缩进\r\n\r\n# parse\r\n\r\n如果给 `JSON.parse()` 传入的 JSON 字符串无效，则会导致抛出错误\r\n\r\n`JSON.parse()` 方法也可以接收一个额外的函数，该函数会针对每个键值对都调用一次\r\n\r\n该函数也接收两个参数：属性名和属性值，返回值即为该属性最终的属性值，返回 `undefined`，则结果中就会删除相应的项\r\n\r\n使用该函数可以将日期字符串转换为 `Date` 对象：\r\n\r\n```javascript\r\nconst book = {\r\n  title: \"Professional JavaScript\",\r\n  authors: [\r\n    \"Nicholas C. Zakas\",\r\n    \"Matt Frisbie\"\r\n  ],\r\n  edition: 4,\r\n  year: 2017,\r\n  releaseDate: new Date(2017, 11, 1)\r\n}\r\nconst jsonText = JSON.stringify(book)\r\nconst bookCopy = JSON.parse(\r\n  jsonText, \r\n  (key, value) =\u003e key == \"releaseDate\" ? new Date(value) : value\r\n)\r\n```\r\n\r\n","meta":{"size":4309,"birthTime":1663496641382.6409,"updateTime":1663496641382.7905}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["JavaScript","ECMAScript","JSON"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
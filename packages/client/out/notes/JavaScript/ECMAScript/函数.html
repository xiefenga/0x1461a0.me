<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>函数 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#函数内部" data-target-id="h1-函数内部-0">函数内部</a></li><li><a href="#立即执行函数" data-target-id="h1-立即执行函数-1">立即执行函数</a></li><li><a href="#参数默认值" data-target-id="h1-参数默认值-2">参数默认值</a><ul><li><a href="#arguments" data-target-id="h2-arguments-0">arguments</a></li><li><a href="#暂时型死区" data-target-id="h2-暂时型死区-1">暂时型死区</a></li></ul></li><li><a href="#剩余参数" data-target-id="h1-剩余参数-3">剩余参数</a></li><li><a href="#箭头函数" data-target-id="h1-箭头函数-4">箭头函数</a></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">函数</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h1>函数内部</h1>
<ul>
<li><code>arguments</code>
<ul>
<li><code>arguments</code> 有一个名叫 <code>callee</code> 的属性，该属性指向拥有这个 <code>arguments</code> 对象的函数</li>
<li>当函数在严格模式下运行时，访问 <code>arguments.callee</code> 会导致错误。</li>
</ul>
</li>
<li><code>caller</code>
<ul>
<li>这个属性中保存着<strong>调用当前函数的函数</strong>的引用</li>
<li>如果是在全局作用域中调用当前函数，它的值为 <code>null</code></li>
</ul>
</li>
<li><code>new.target</code>
<ul>
<li>ES6 新增用于检测函数是否通过 new 关键字调用</li>
<li>正常调用函数 <code>new.target</code> 为 <code>undefined</code></li>
<li>使用 new 关键字调用函数，<code>new.target</code> 指向该构造函数</li>
</ul>
</li>
</ul>
<h1>立即执行函数</h1>
<p>一个函数变成表达式，该函数的名字就会变成函数内部的一个局部变量，并指代函数对象本身，并且函数表达式不会成为 <code>window</code> 的属性</p>
<p>一般的写法：</p>
<ul>
<li><code>(function() {...}())</code></li>
<li><code>(function() {...})()</code></li>
</ul>
<p>实际上，只要是函数表达式，就可以被执行符号 <code>()</code> 执行，<code>()</code> 也能将函数变为表达式所以才有了上面的写法</p>
<pre><code class="language-javascript">+ function() {
  console.log(&quot;+&quot;);
}();

var test = function() {
  console.log(&quot;test&quot;);
}();

! function() {
  console.log(&quot;!&quot;);
}();
</code></pre>
<h1>参数默认值</h1>
<p>只要没有给有默认值的参数传递参数或传 <code>undefined</code> ，函数即会使用默认值</p>
<pre><code class="language-js">function(a = 1, b) {
  ......
}
</code></pre>
<h2>arguments</h2>
<p>非严格模式下，形参和 <code>arguments</code> 是相关联的，在严格模式下， <code>arguments</code> 和形参是脱离的，使用了参数默认值就是使用了严格模式</p>
<pre><code class="language-js">function test(a, b) {
  &quot;use strict&quot;;
  console.log(a, arguments[0]);
  a = 10;
  console.log(a, arguments[0]);
}

test(1, 10); // 1 1   10 1
</code></pre>
<h2>暂时型死区</h2>
<p>形参和 <code>let</code> 声明一样，具有作用域，并且根据参数的声明顺序，存在暂时性死区</p>
<pre><code class="language-js">function test(a = b, b) {
  .....
}
test(1, 2); // 没问题
test(undefined, 2); //ReferenceError: Cannot access &#x27;b&#x27; before initialization
</code></pre>
<h1>剩余参数</h1>
<p>ES6的剩余参数专门用于收集末尾的所有参数，将其放置到一个形参数组中</p>
<pre><code class="language-js">function(a, b, ...args) {
  ...
}
</code></pre>
<h1>箭头函数</h1>
<ol>
<li>箭头函数中不存在 <code>this</code>、<code>arguments</code>、<code>new.target</code>，如果使用了这些，则用的是该函数外层对应的值</li>
<li>箭头函数没有原型（即没有 <code>prototype</code> 属性）</li>
<li>箭头函数不能作用构造函数使用</li>
<li>call、apply、bind 等方法无法改变箭头函数中 this 的指向</li>
<li>箭头函数不能用作Generator函数，不能使用yeild关键字</li>
</ol><div><a href="/notes/JavaScript/ECMAScript">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"函数","article":{"title":"函数","content":"# 函数内部\n\n- `arguments`\n\t- `arguments` 有一个名叫 `callee` 的属性，该属性指向拥有这个 `arguments` 对象的函数\n\t- 当函数在严格模式下运行时，访问 `arguments.callee` 会导致错误。\n- `caller`\n\t- 这个属性中保存着**调用当前函数的函数**的引用\n\t- 如果是在全局作用域中调用当前函数，它的值为 `null`\n- `new.target`\n  - ES6 新增用于检测函数是否通过 new 关键字调用\n  - 正常调用函数 `new.target` 为 `undefined`\n  - 使用 new 关键字调用函数，`new.target` 指向该构造函数\n\n# 立即执行函数\n\n一个函数变成表达式，该函数的名字就会变成函数内部的一个局部变量，并指代函数对象本身，并且函数表达式不会成为 `window` 的属性\n\n一般的写法：\n\n- `(function() {...}())`\n- `(function() {...})()`\n\n实际上，只要是函数表达式，就可以被执行符号 `()` 执行，`()` 也能将函数变为表达式所以才有了上面的写法\n\n```javascript\n+ function() {\n  console.log(\"+\");\n}();\n\nvar test = function() {\n  console.log(\"test\");\n}();\n\n! function() {\n  console.log(\"!\");\n}();\n```\n\n# 参数默认值\n\n只要没有给有默认值的参数传递参数或传 `undefined` ，函数即会使用默认值\n\n``` js\nfunction(a = 1, b) {\n  ......\n}\n```\n\n## arguments\n\n非严格模式下，形参和 `arguments` 是相关联的，在严格模式下， `arguments` 和形参是脱离的，使用了参数默认值就是使用了严格模式\n\n``` js\nfunction test(a, b) {\n  \"use strict\";\n  console.log(a, arguments[0]);\n  a = 10;\n  console.log(a, arguments[0]);\n}\n\ntest(1, 10); // 1 1   10 1\n```\n\n## 暂时型死区\n\n形参和 `let` 声明一样，具有作用域，并且根据参数的声明顺序，存在暂时性死区\n\n``` js\nfunction test(a = b, b) {\n  .....\n}\ntest(1, 2); // 没问题\ntest(undefined, 2); //ReferenceError: Cannot access 'b' before initialization\n```\n\n# 剩余参数\n\nES6的剩余参数专门用于收集末尾的所有参数，将其放置到一个形参数组中\n\n``` js\nfunction(a, b, ...args) {\n  ...\n}\n```\n\n# 箭头函数\n\n1. 箭头函数中不存在 `this`、`arguments`、`new.target`，如果使用了这些，则用的是该函数外层对应的值\n2. 箭头函数没有原型（即没有 `prototype` 属性）\n3. 箭头函数不能作用构造函数使用\n4. call、apply、bind 等方法无法改变箭头函数中 this 的指向\n5. 箭头函数不能用作Generator函数，不能使用yeild关键字","meta":{"size":2497,"birthTime":1663496641393.3093,"updateTime":1663496641393.572}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["JavaScript","ECMAScript","函数"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
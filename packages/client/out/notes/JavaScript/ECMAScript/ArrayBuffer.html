<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>ArrayBuffer | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#ArrayBuffer" data-target-id="h1-ArrayBuffer-0">ArrayBuffer</a></li><li><a href="#DataView" data-target-id="h1-DataView-1">DataView</a></li><li><a href="#TypedArray" data-target-id="h1-TypedArray-2">TypedArray</a></li><li><a href="#Atomics" data-target-id="h1-Atomics-3">Atomics</a><ul><li><a href="#原子性" data-target-id="h2-原子性-0">原子性</a></li><li><a href="#指令排序" data-target-id="h2-指令排序-1">指令排序</a></li><li><a href="#读写API" data-target-id="h2-读写API-2">读写API</a></li><li><a href="#锁" data-target-id="h2-锁-3">锁</a></li></ul></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">ArrayBuffer</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h1>ArrayBuffer</h1>
<p><code>ArrayBuffer</code> 用于在内存中分配特定数量的字节空间，就像 C 语言的 malloc 函数</p>
<p>通过 <code>ArrayBuffer</code> 申请的内存一经创建就不能再调整大小，要读写 ArrayBuffer 则需要通过<strong>视图</strong>。</p>
<pre><code class="language-javascript">const buf = new ArrayBuffer(16); 
console.log(buf.byteLength); // 16
</code></pre>
<p>ArrayBuffer 某种程度上类似于 C 语言的 malloc 函数，但也存在区别：</p>
<ul>
<li><code>malloc</code> 在分配失败时会返回一个 <code>null</code> 指针；<code>ArrayBuffer</code> 在分配失败时会抛出错误</li>
<li><code>malloc</code> 可以利用虚拟内存，因此最大可分配尺寸只受可寻址系统内存限制；<code>ArrayBuffer</code> 分配的内存不能超过 <code>Number.MAX_SAFE_INTEGER</code></li>
<li><code>malloc</code> 调用成功不会初始化实际的地址；<code>ArrayBuffer</code> 则默认会将所有二进制位初始化为 0</li>
<li>通过 <code>malloc</code> 分配的堆内存需要手动通过 <code>free</code>；而通过声明 <code>ArrayBuffer</code> 分配的堆内存可以被当成垃圾回收，不用手动释放</li>
</ul>
<h1>DataView</h1>
<p>DataView 是一种可以读写 ArrayBuffer 的视图，其 API 支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些</p>
<p>创建 DataView 视图需要通过已有的 ArrayBuffer 实例，可以使用全部或部分 ArrayBuffer</p>
<pre><code class="language-javascript">const buf = new ArrayBuffer(16);

// DataView 默认使用整个 ArrayBuffer
const fullDataView = new DataView(buf);

// 构造函数接收一个可选的字节偏移量和字节长度
const firstHalfDataView = new DataView(buf, 0, 8);

// DataView 会使用剩余的缓冲
const secondHalfDataView = new DataView(buf, 8);
</code></pre>
<p>DataView 的读写需要的条件：</p>
<ul>
<li>要读写的字节偏移量</li>
<li>读写的类型，例如：Int8、Unit8、Int16、Uint16、Int32、Uint32、Float32、Float64</li>
<li>内存中值的字节序（大小端），默认为大端</li>
</ul>
<p>DataView 为上表中的每种类型都暴露了 get 和 set 方法，这些方法使用 byteOffset 定位要读取或写入值的位置</p>
<pre><code class="language-javascript">const buf = new ArrayBuffer(2)
const view = new DataView(buf)
view.setUint8(0, 255)
view.setUint8(1, 0xFF)
view.getInt16(0) // -1
</code></pre>
<p><img src="https://oss.xiefeng.tech/images/20211003113520.png" alt=""/></p>
<p>JavaScript 运行时所在系统的原生字节序决定了如何读取或写入字节，但 DataView 并不遵守这个约定。</p>
<p>DataView 是一个中立接口，它会遵循你指定的字节序。DataView 所有 API 方法都以大端字节序作为默认值，但接收一个可选的布尔值参数，设置为 true 即可启用小端字节序。</p>
<h1>TypedArray</h1>
<p>定型数组是另一种形式的 ArrayBuffer 视图。</p>
<p>创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组。</p>
<pre><code class="language-javascript">const buf = new ArrayBuffer(12);
// 创建一个引用该缓冲的 Int32Array
const ints = new Int32Array(buf);

console.log(ints.length); // 3

// 创建一个长度为 6 的 Int32Array
const ints2 = new Int32Array(6);

// 创建一个包含[2, 4, 6, 8]的 Int32Array
const ints3 = new Int32Array([2, 4, 6, 8]);

// 通过复制 ints3 的值创建一个 Int16Array
const ints4 = new Int16Array(ints3); 

// 基于普通数组来创建一个 Int16Array
const ints5 = Int16Array.from([3, 5, 7, 9]);

// 基于传入的参数创建一个 Float32Array
const floats = Float32Array.of(3.14, 2.718, 1.618);
</code></pre>
<h1>Atomics</h1>
<p><code>SharedArrayBuffer</code> 是 <code>ArrayBuffer</code> 的一个变体，主要区别是 <code>SharedArrayBuffer</code> 可以被任意多个执行上下文同时使用</p>
<p>多个上下文同时对缓冲区执行操作，可能出现资源争用问题，Atomics API 通过强制同一时刻只能对缓冲区执行一个操作，可以让多个上下文安全地读写一个缓冲区，保证 JavaScript 操作是线程安全的</p>
<h2>原子性</h2>
<p>现代编程语言中，一条普通的命令被编译器处理以后，会变成多条机器指令。</p>
<p>在多线程环境并且共享内存时，就会出问题。因为在这一组指令的运行期间，可能会被中断然后运行其他线程的指令操作共享内存，从而导致运行结果出错。</p>
<p>原子性就是让一个操作所对应的多条机器指令，一定是作为一个整体运行不会被中断。</p>
<p><code>Atomics</code> 对象就是为了实现原子操作而产生的，提高多线程共享内存时的操作安全。</p>
<h2>指令排序</h2>
<p>JavaScript 编译器和 CPU 架构本身都有权限重排指令以提升程序执行效率。但多线程下的指令重排可能导致资源争用，而且极难排错。</p>
<p>Atomics API 通过两种主要方式解决了这个问题：</p>
<ul>
<li>所有原子指令相互之间的顺序永远不会重排</li>
<li>使用原子读或原子写保证所有指令都不会相对原子读/写重新排序</li>
</ul>
<p>这意味着位于原子读/写之前的所有指令会在原子读/写发生前完成，而位于原子读/写之后的所有指令会在原子读/写完成后才会开始。</p>
<pre><code class="language-javascript">const sharedArrayBuffer = new SharedArrayBuffer(4);
const view = new Uint32Array(sharedArrayBuffer);
// 执行非原子写
view[0] = 1;
// 非原子写可以保证在这个读操作之前完成，因此这里一定会读到 1
console.log(Atomics.load(view, 0)); // 1
// 执行原子写
Atomics.store(view, 0, 2);
// 非原子读可以保证在原子写完成后发生，因此这里一定会读到 2
console.log(view[0]); // 2
</code></pre>
<h2>读写API</h2>
<ul>
<li>
<p><code>load(typedArray, index)</code>：从共享内存读出数据</p>
</li>
<li>
<p><code>store(typedArray, index, value)</code>：向共享内存写入数据</p>
</li>
<li>
<p><code>exchange(typedArray, index, value)</code>：替换掉数组上的值，然后返回数组的旧值</p>
</li>
<li>
<p><code>compareExchange(typedArray, index, expected, replacement)</code>：在数组的值与期望值相等的时候，将给定的替换值替换掉数组上的值，然后返回旧值</p>
</li>
<li>
<p><code>add(typedArray, index, value)</code>：对共享内存索引处执行原子 <code>+</code> 操作</p>
</li>
<li>
<p><code>sub(typedArray, index, value)</code>：对共享内存索引处执行原子 <code>-</code> 操作</p>
</li>
<li>
<p><code>or(typedArray, index, value)</code>：对共享内存索引处执行原子或操作</p>
</li>
<li>
<p><code>and(typedArray, index, value)</code>：对共享内存索引处执行原子与操作</p>
</li>
<li>
<p><code>xor(typedArray, index, value)</code>：对共享内存索引处执行原子异或操作</p>
</li>
</ul>
<h2>锁</h2>
<p>如果没有某种锁机制，多线程程序就无法支持复杂需求。为此，Atomics API 提供了模仿 Linux Futex （快速用户空间互斥量）的方法。</p>
<p>所有原子 Futex 操作只能用于 Int32Array 视图。</p>
<p><code>Atomics</code> 对象提供了 <code>wait()</code> 和 <code>notify()</code> 两个方法用于等待通知。这两个方法相当于锁内存，即在一个线程进行操作时，让其他线程休眠（建立锁），等到操作结束，再唤醒那些休眠的线程（解除锁）。</p>
<pre><code class="language-javascript">// worker.js
self.addEventListener(&#x27;message&#x27;, e =&gt; {
  const sharedArray = new Int32Array(e.data);
  Atomics.wait(sharedArray, 0, 50);
  console.log(Atomics.load(sharedArray, 0));
});
</code></pre>
<p><code>wait()</code> 方法告诉 Worker 线程，只要满足给定条件（<code>sharedArray</code>的 <code>0</code> 号位置等于 <code>50</code>）Worker 线程进入休眠。</p>
<pre><code class="language-javascript">// main.js
Atomics.store(sharedArray, 0, 100);
Atomics.notify(sharedArray, 0, 1);
</code></pre>
<p><code>notify()</code> 方法，唤醒在 <code>sharedArray</code> 的 <code>0</code> 号位置休眠队列里的一个线程。</p>
<p><code>Atomics.wait()</code> 和 <code>Atomic.notify()</code> 这两个原子操作和操作系统提供的一对原语 P、V 操作非常类似。</p>
<pre><code class="language-javascript">Atomics.wait(sharedArray, index, value[, timeout])
</code></pre>
<ul>
<li><code>value</code>：该位置的预期值，一旦实际值等于预期值，线程就进入休眠</li>
<li><code>timeout</code>：表示过了这个时间以后自动唤醒，单位毫秒。默认值是 <code>Infinity</code>，只有通过 <code>notify</code> 才能唤醒</li>
<li>返回值是一个字符串：和预期值不等，返回 <code>not-equal</code>；<code>notify</code> 唤醒，返回 <code>ok</code>；超时唤醒，返回 <code>timed-out</code></li>
</ul>
<pre><code class="language-javascript">Atomics.notify(sharedArray, index, count)
</code></pre>
<ul>
<li><code>count</code>：需要唤醒的 Worker 线程的数量，默认为 <code>Infinity</code>，全部唤醒。</li>
</ul>
<p><a href="https://github.com/lars-t-hansen/js-lock-and-condition">js-lock-and-condition</a> 库基于 <code>wait</code> 和 <code>notify</code> 这两个方法实现锁内存实现。</p>
<p><strong>锁的判断</strong></p>
<p><code>Atomics.isLockFree(size)</code>：该字节长度为可处理的 <code>TypedArray</code> 标准字节长度之一则返回 <code>true</code></p>
<p>只有传递的数值为标准的字节长度才可以，<code>TypedArray</code> 的标准字节长度参见 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT">BYTES_PER_ELEMENT</a></p>
<p>该方法我们基本上应该不会用到。这个方法在 高性能算法中可以用来确定是否有必要获取锁。</p>
<p>规范中的介绍如下：</p>
<blockquote>
<p>Atomics.isLockFree 是一个优化原语。基本上，如果一个原子原语（compareExchange、 load、store、add、sub、and、or、xor 或 exchange）在 n 字节大小的数据上的原子步骤 在不调用代理在组成数据的n字节之外获得锁的情况下可以执行，则Atomics.isLockFree(n) 会返回 true。高性能算法会使用 Atomics.isLockFree 确定是否在关键部分使用锁或原子操作。如果原子原语需要加锁，则算法提供自己的锁会更高效。 Atomics.isLockFree(4)始终返回 true，因为在所有已知的相关硬件上都是支持的。 能够如此假设通常可以简化程序。</p>
</blockquote><div><a href="/notes/JavaScript/ECMAScript">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"ArrayBuffer","article":{"title":"ArrayBuffer","content":"# ArrayBuffer\r\n\r\n`ArrayBuffer` 用于在内存中分配特定数量的字节空间，就像 C 语言的 malloc 函数\r\n\r\n通过 `ArrayBuffer` 申请的内存一经创建就不能再调整大小，要读写 ArrayBuffer 则需要通过**视图**。\r\n\r\n```javascript\r\nconst buf = new ArrayBuffer(16); \r\nconsole.log(buf.byteLength); // 16\r\n```\r\n\r\nArrayBuffer 某种程度上类似于 C 语言的 malloc 函数，但也存在区别：\r\n\r\n- `malloc` 在分配失败时会返回一个 `null` 指针；`ArrayBuffer` 在分配失败时会抛出错误\r\n- `malloc` 可以利用虚拟内存，因此最大可分配尺寸只受可寻址系统内存限制；`ArrayBuffer` 分配的内存不能超过 `Number.MAX_SAFE_INTEGER`\r\n- `malloc` 调用成功不会初始化实际的地址；`ArrayBuffer` 则默认会将所有二进制位初始化为 0\r\n- 通过 `malloc` 分配的堆内存需要手动通过 `free`；而通过声明 `ArrayBuffer` 分配的堆内存可以被当成垃圾回收，不用手动释放\r\n\r\n# DataView\r\n\r\nDataView 是一种可以读写 ArrayBuffer 的视图，其 API 支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些\r\n\r\n创建 DataView 视图需要通过已有的 ArrayBuffer 实例，可以使用全部或部分 ArrayBuffer\r\n\r\n```javascript\r\nconst buf = new ArrayBuffer(16);\r\n\r\n// DataView 默认使用整个 ArrayBuffer\r\nconst fullDataView = new DataView(buf);\r\n\r\n// 构造函数接收一个可选的字节偏移量和字节长度\r\nconst firstHalfDataView = new DataView(buf, 0, 8);\r\n\r\n// DataView 会使用剩余的缓冲\r\nconst secondHalfDataView = new DataView(buf, 8);\r\n```\r\n\r\nDataView 的读写需要的条件：\r\n\r\n- 要读写的字节偏移量\r\n- 读写的类型，例如：Int8、Unit8、Int16、Uint16、Int32、Uint32、Float32、Float64\r\n- 内存中值的字节序（大小端），默认为大端\r\n\r\nDataView 为上表中的每种类型都暴露了 get 和 set 方法，这些方法使用 byteOffset 定位要读取或写入值的位置\r\n\r\n```javascript\r\nconst buf = new ArrayBuffer(2)\r\nconst view = new DataView(buf)\r\nview.setUint8(0, 255)\r\nview.setUint8(1, 0xFF)\r\nview.getInt16(0) // -1\r\n```\r\n\r\n![](https://oss.xiefeng.tech/images/20211003113520.png)\r\n\r\nJavaScript 运行时所在系统的原生字节序决定了如何读取或写入字节，但 DataView 并不遵守这个约定。\r\n\r\nDataView 是一个中立接口，它会遵循你指定的字节序。DataView 所有 API 方法都以大端字节序作为默认值，但接收一个可选的布尔值参数，设置为 true 即可启用小端字节序。\r\n\r\n# TypedArray\r\n\r\n定型数组是另一种形式的 ArrayBuffer 视图。\r\n\r\n创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组。\r\n\r\n```javascript\r\nconst buf = new ArrayBuffer(12);\r\n// 创建一个引用该缓冲的 Int32Array\r\nconst ints = new Int32Array(buf);\r\n\r\nconsole.log(ints.length); // 3\r\n\r\n// 创建一个长度为 6 的 Int32Array\r\nconst ints2 = new Int32Array(6);\r\n\r\n// 创建一个包含[2, 4, 6, 8]的 Int32Array\r\nconst ints3 = new Int32Array([2, 4, 6, 8]);\r\n\r\n// 通过复制 ints3 的值创建一个 Int16Array\r\nconst ints4 = new Int16Array(ints3); \r\n\r\n// 基于普通数组来创建一个 Int16Array\r\nconst ints5 = Int16Array.from([3, 5, 7, 9]);\r\n\r\n// 基于传入的参数创建一个 Float32Array\r\nconst floats = Float32Array.of(3.14, 2.718, 1.618);\r\n```\r\n\r\n# Atomics\r\n\r\n`SharedArrayBuffer` 是 `ArrayBuffer` 的一个变体，主要区别是 `SharedArrayBuffer` 可以被任意多个执行上下文同时使用\r\n\r\n多个上下文同时对缓冲区执行操作，可能出现资源争用问题，Atomics API 通过强制同一时刻只能对缓冲区执行一个操作，可以让多个上下文安全地读写一个缓冲区，保证 JavaScript 操作是线程安全的\r\n\r\n## 原子性\r\n\r\n现代编程语言中，一条普通的命令被编译器处理以后，会变成多条机器指令。\r\n\r\n在多线程环境并且共享内存时，就会出问题。因为在这一组指令的运行期间，可能会被中断然后运行其他线程的指令操作共享内存，从而导致运行结果出错。\r\n\r\n原子性就是让一个操作所对应的多条机器指令，一定是作为一个整体运行不会被中断。\r\n\r\n`Atomics` 对象就是为了实现原子操作而产生的，提高多线程共享内存时的操作安全。\r\n\r\n## 指令排序\r\n\r\nJavaScript 编译器和 CPU 架构本身都有权限重排指令以提升程序执行效率。但多线程下的指令重排可能导致资源争用，而且极难排错。\r\n\r\nAtomics API 通过两种主要方式解决了这个问题：\r\n\r\n- 所有原子指令相互之间的顺序永远不会重排\r\n- 使用原子读或原子写保证所有指令都不会相对原子读/写重新排序\r\n\r\n这意味着位于原子读/写之前的所有指令会在原子读/写发生前完成，而位于原子读/写之后的所有指令会在原子读/写完成后才会开始。\r\n\r\n```javascript\r\nconst sharedArrayBuffer = new SharedArrayBuffer(4);\r\nconst view = new Uint32Array(sharedArrayBuffer);\r\n// 执行非原子写\r\nview[0] = 1;\r\n// 非原子写可以保证在这个读操作之前完成，因此这里一定会读到 1\r\nconsole.log(Atomics.load(view, 0)); // 1\r\n// 执行原子写\r\nAtomics.store(view, 0, 2);\r\n// 非原子读可以保证在原子写完成后发生，因此这里一定会读到 2\r\nconsole.log(view[0]); // 2\r\n```\r\n\r\n## 读写API\r\n\r\n- `load(typedArray, index)`：从共享内存读出数据\r\n- `store(typedArray, index, value)`：向共享内存写入数据\r\n\r\n- `exchange(typedArray, index, value)`：替换掉数组上的值，然后返回数组的旧值\r\n- `compareExchange(typedArray, index, expected, replacement)`：在数组的值与期望值相等的时候，将给定的替换值替换掉数组上的值，然后返回旧值\r\n- `add(typedArray, index, value)`：对共享内存索引处执行原子 `+` 操作\r\n- `sub(typedArray, index, value)`：对共享内存索引处执行原子 `-` 操作\r\n- `or(typedArray, index, value)`：对共享内存索引处执行原子或操作\r\n- `and(typedArray, index, value)`：对共享内存索引处执行原子与操作\r\n- `xor(typedArray, index, value)`：对共享内存索引处执行原子异或操作\r\n\r\n## 锁\r\n\r\n如果没有某种锁机制，多线程程序就无法支持复杂需求。为此，Atomics API 提供了模仿 Linux Futex （快速用户空间互斥量）的方法。\r\n\r\n所有原子 Futex 操作只能用于 Int32Array 视图。\r\n\r\n`Atomics` 对象提供了 `wait()` 和 `notify()` 两个方法用于等待通知。这两个方法相当于锁内存，即在一个线程进行操作时，让其他线程休眠（建立锁），等到操作结束，再唤醒那些休眠的线程（解除锁）。\r\n\r\n```javascript\r\n// worker.js\r\nself.addEventListener('message', e =\u003e {\r\n  const sharedArray = new Int32Array(e.data);\r\n  Atomics.wait(sharedArray, 0, 50);\r\n  console.log(Atomics.load(sharedArray, 0));\r\n});\r\n```\r\n\r\n`wait()` 方法告诉 Worker 线程，只要满足给定条件（`sharedArray`的 `0` 号位置等于 `50`）Worker 线程进入休眠。\r\n\r\n```javascript\r\n// main.js\r\nAtomics.store(sharedArray, 0, 100);\r\nAtomics.notify(sharedArray, 0, 1);\r\n```\r\n\r\n`notify()` 方法，唤醒在 `sharedArray` 的 `0` 号位置休眠队列里的一个线程。\r\n\r\n`Atomics.wait()` 和 `Atomic.notify()` 这两个原子操作和操作系统提供的一对原语 P、V 操作非常类似。\r\n\r\n```javascript\r\nAtomics.wait(sharedArray, index, value[, timeout])\r\n```\r\n\r\n- `value`：该位置的预期值，一旦实际值等于预期值，线程就进入休眠\r\n- `timeout`：表示过了这个时间以后自动唤醒，单位毫秒。默认值是 `Infinity`，只有通过 `notify` 才能唤醒\r\n- 返回值是一个字符串：和预期值不等，返回 `not-equal`；`notify` 唤醒，返回 `ok`；超时唤醒，返回 `timed-out`\r\n\r\n```javascript\r\nAtomics.notify(sharedArray, index, count)\r\n```\r\n\r\n- `count`：需要唤醒的 Worker 线程的数量，默认为 `Infinity`，全部唤醒。\r\n\r\n[js-lock-and-condition](https://github.com/lars-t-hansen/js-lock-and-condition) 库基于 `wait` 和 `notify` 这两个方法实现锁内存实现。\r\n\r\n**锁的判断**\r\n\r\n`Atomics.isLockFree(size)`：该字节长度为可处理的 `TypedArray` 标准字节长度之一则返回 `true`\r\n\r\n只有传递的数值为标准的字节长度才可以，`TypedArray` 的标准字节长度参见 [BYTES_PER_ELEMENT](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)\r\n\r\n该方法我们基本上应该不会用到。这个方法在 高性能算法中可以用来确定是否有必要获取锁。\r\n\r\n规范中的介绍如下：\r\n\r\n\u003e Atomics.isLockFree 是一个优化原语。基本上，如果一个原子原语（compareExchange、 load、store、add、sub、and、or、xor 或 exchange）在 n 字节大小的数据上的原子步骤 在不调用代理在组成数据的n字节之外获得锁的情况下可以执行，则Atomics.isLockFree(n) 会返回 true。高性能算法会使用 Atomics.isLockFree 确定是否在关键部分使用锁或原子操作。如果原子原语需要加锁，则算法提供自己的锁会更高效。 Atomics.isLockFree(4)始终返回 true，因为在所有已知的相关硬件上都是支持的。 能够如此假设通常可以简化程序。\r\n","meta":{"size":9454,"birthTime":1663496641382.3381,"updateTime":1663496641382.5608}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["JavaScript","ECMAScript","ArrayBuffer"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
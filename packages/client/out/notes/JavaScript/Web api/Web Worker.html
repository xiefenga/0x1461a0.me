<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>Web Worker | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#工作者线程" data-target-id="h1-工作者线程-0">工作者线程</a></li><li><a href="#专用工作者线程" data-target-id="h1-专用工作者线程-1">专用工作者线程</a><ul><li><a href="#创建" data-target-id="h2-创建-0">创建</a></li><li><a href="#实例" data-target-id="h2-实例-1">实例</a><ul><li><a href="#事件" data-target-id="h3-事件-0">事件</a></li><li><a href="#方法" data-target-id="h3-方法-1">方法</a></li></ul></li><li><a href="#全局对象" data-target-id="h2-全局对象-2">全局对象</a></li><li><a href="#通信" data-target-id="h2-通信-3">通信</a><ul><li><a href="#postMessage" data-target-id="h3-postMessage-2">postMessage</a></li><li><a href="#MessageChannel" data-target-id="h3-MessageChannel-3">MessageChannel</a></li><li><a href="#BroadcastChannel" data-target-id="h3-BroadcastChannel-4">BroadcastChannel</a></li></ul></li><li><a href="#数据传输" data-target-id="h2-数据传输-4">数据传输</a><ul><li><a href="#结构化克隆算法" data-target-id="h3-结构化克隆算法-5">结构化克隆算法</a></li><li><a href="#可转移对象" data-target-id="h3-可转移对象-6">可转移对象</a></li><li><a href="#SharedArrayBuffer" data-target-id="h3-SharedArrayBuffer-7">SharedArrayBuffer</a></li></ul></li></ul></li><li><a href="#共享工作者线程" data-target-id="h1-共享工作者线程-2">共享工作者线程</a><ul><li><a href="#连接" data-target-id="h2-连接-5">连接</a></li></ul></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">Web Worker</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h1>工作者线程</h1>
<p>Web Worker 赋予了浏览器中的 JavaScript 多线程并发执行任务的能力。</p>
<p>传统的多线程模型（例如：POSIX 线程或者 Java 线程）不适合 JavaScript，因为像 DOM 这样的 API 会出现问题。</p>
<p>而这也正是工作者线程的价值所在：允许把主线程的工作转嫁给独立的实体，而不会改变现有的单线程模型。</p>
<p>Web 工作者线程规范中定义了三种主要的工作者线程：</p>
<ul>
<li>
<p><strong>专用工作者线程</strong>：通常简称为Web Worker，脚本可以单独创建一个 JavaScript 线程执行委托的任务</p>
</li>
<li>
<p><strong>共享工作者线程</strong>：与专用工作者线程非常相似，主要区别是共享工作者线程可以被多个不同的上下文使用</p>
</li>
<li>
<p><strong>服务工作者线</strong>：与专用工作者线程和共享工作者线程截然不同，它的主要用途是拦截、重定向和修改页面发出的请求</p>
</li>
</ul>
<h1>专用工作者线程</h1>
<p>专用工作者线程可以称为后台脚本，JavaScript 线程的各个方面，包括生命周期管理、代码路径和输入/输出，都由初始化线程时提供的脚本来控制。</p>
<h2>创建</h2>
<p>通过 <code>Worker</code> 构造函数创建专用 Worker 线程，构造函数返回一个 Worker 实例，通过该实例可以和 Worker 通信。</p>
<p>有两种创建 Worker 的方式，一种是通过同源的 URL，一种是通过行内生成Object URL 的方式。</p>
<pre><code class="language-javascript">const worker = new Worker(&#x27;./worker.js&#x27;, { type: &quot;module&quot; });

console.log(worker); // Worker { }


// 通过行内的方式创建 Worker
const workerScript = `
	self.onmessage = ({data}) =&gt; console.log(data);
`;
const workerScriptBlob = new Blob([workerScript]);

const workerScriptBlobUrl = URL.createObjectURL(workerScriptBlob);
const worker = new Worker(workerScriptBlobUrl);
</code></pre>
<p>第二个参数可以传递配置：</p>
<ul>
<li><code>name</code>：可以在工作者线程中通过 <code>self.name</code> 读取到的字符串标识符</li>
<li><code>type</code>：脚本的运行方式<!-- -->
<ul>
<li><code>classic</code>：脚本作为常规脚本来执行</li>
<li><code>module</code>：脚本作为模块执行</li>
</ul>
</li>
<li><code>credentials</code>：在 <code>type</code> 为 <code>&quot;module&quot;</code> 时，指定如何获取与传输凭证数据相关的工作者线程模块脚本<!-- -->
<ul>
<li>这些选项与 <code>fetch</code> 的凭证选项相同</li>
<li><code>omit</code>、<code>same-orign</code>、<code>include</code></li>
</ul>
</li>
</ul>
<h2>实例</h2>
<p>构造函数返回的 Worker 对象是与刚创建的专用工作者线程通信的连接点。它可用于在工作者线程和父上下文间传输信息，以及捕获专用工作者线程发出的事件。</p>
<h3>事件</h3>
<ul>
<li><code>onerror</code>：该事件会在工作者线程中抛出错误时发生</li>
<li><code>onmessage</code>：该事件会在工作者线程向父上下文发送消息时发生</li>
<li><code>onmessageerror</code>：该事件会在工作者线程收到无法反序列化的消息时发生</li>
</ul>
<p>由于 Worker 继承自 EventTarget，事件也可以通过 <code>worker.addEventListener</code> 来注册。</p>
<p>如果工作者线程脚本抛出了错误，该工作者线程沙盒可以阻止它打断父线程的执行。即在父线程中无法捕获，只能通过事件。</p>
<pre><code class="language-javascript">// worker.js
throw Error(&#x27;foo&#x27;);

// main.js
try {
    const worker = new Worker(&#x27;./worker.js&#x27;);
    console.log(&#x27;no error&#x27;);
} catch(e) {
    console.log(&#x27;caught error&#x27;);
}
// no error

const worker = new Worker(&#x27;./worker.js&#x27;);
worker.onerror = console.log; 
// ErrorEvent {message: &quot;Uncaught Error: foo&quot;}
</code></pre>
<h3>方法</h3>
<ul>
<li><code>postMessage</code>：用于通过异步消息事件向工作者线程发送信息</li>
<li><code>terminate</code>：用于立即终止工作者线程。没有为工作者线程提供清理的机会，脚本会突然停止</li>
</ul>
<h2>全局对象</h2>
<p>专用工作者线程的全局作用域是 <code>DedicatedWorkerGlobalScope</code> 的实例。因为这继承自 <code>WorkerGlobalScope</code>，所以包含它的所有属性和方法。工作者线程可以通过 <code>self</code> 关键字访问该全局作用域。</p>
<p><code>DedicatedWorkerGlobalScope</code> 增加的属性和方法：</p>
<ul>
<li><code>name</code>：Worker 构造函数的一个可选的字符串标识符</li>
<li><code>postMessage</code>：与 <code>worker.postMessage</code> 对应的方法，用于从工作者线程内部向父上下文发送消息</li>
<li><code>close</code>：与 <code>worker.terminate</code> 对应的方法，用于立即终止工作者线程</li>
<li><code>importScripts</code>：可以加载任意源的脚本，只能在 <code>classic</code> 脚本中使用，可以接收任意数量的脚本</li>
</ul>
<h2>通信</h2>
<p>与工作者线程的通信都是通过异步消息完成的。</p>
<h3>postMessage</h3>
<p>可以使用 <code>postMessage</code> 在主线程和工作者线程之间传递消息，传递的数据保存在事件对象 <code>e</code> 的 <code>data</code> 属性中。</p>
<pre><code class="language-javascript">// worker.js
function factorial(n) {
    let result = 1;
    while (n) { result *= n--; }
    return result;
}

self.onmessage = (e) =&gt; self.postMessage(`${e.data}! = ${factorial(e.data)}`);

// main.js
const worker = new Worker(&#x27;./worker.js&#x27;);

worker.onmessage = e =&gt; console.log(e.data);

worker.postMessage(5);
</code></pre>
<h3>MessageChannel</h3>
<p><code>MessageChannel</code> 接口允许我们创建一个新的消息通道，并通过它的两个端口（<code>MessagePort</code> 实例）发送数据。</p>
<p><code>MessagePort</code> 实例具有 <code>onmessage</code> 等事件和 <code>postMessage</code> 方法。</p>
<pre><code class="language-javascript">const channel = new MessageChannel();

console.log(channel);
</code></pre>
<p><img src="http://oss.xiefeng.tech/img/20210328140040.png" alt=""/></p>
<p>首先父线程需要将端口传递给子线程，然后再开始使用端口通信。</p>
<p><code>MessagePort</code> 是可转移对象，可以使用 <code>postMessage</code> 的第二个参数进行传递端口，<code>MessagePort</code> 会自动保存在 <code>e.ports</code> 数组中。</p>
<pre><code class="language-javascript">// worker.js
let messagePort = null;
// 通过在全局的事件接收端口
self.onmessage = e =&gt; {
    messagePort = e.ports[0];
    self.onmessage = null;
    // 通过 channel 进行数据的发送、接收
    messagePort.onmessage = e =&gt; messagePort.postMessage(`data: ${e.data}`);
}; 

// main.js
const channel = new MessageChannel();
const worker = new Worker(&#x27;./worker.js&#x27;);

worker.postMessage(null, [channel.port1]);  // 把端口发送到工作者线程
// 通过 channel 发送、接收数据
channel.port2.onmessage = ({data}) =&gt; console.log(data);
channel.port2.postMessage(5);
</code></pre>
<p>使用 MessageChannel 实例与父进程通信感觉没有必要。MessageChannel 真正有用的地方是让两个子线程之间直接通信。</p>
<p>父线程创建一个 channel，并将端口传递给子线程，让子线程之间通过端口进行通信。</p>
<pre><code class="language-javascript">// main.js
const channel = new MessageChannel();

const workerA = new Worker(&#x27;./worker.js&#x27;);

const workerB = new Worker(&#x27;./worker.js&#x27;);

workerA.postMessage(&#x27;workerA&#x27;, [channel.port1]);

workerB.postMessage(&#x27;workerB&#x27;, [channel.port2]);

// worker.js
let messagePort = null;

function sendData(target, data) {
    target.postMessage(data);
}

self.onmessage = ({data, ports}) =&gt; {
    if (ports.length) {
        messagePort = ports[0];
        messagePort.onmessage = ({data}) =&gt; sendData(self, data);
    } else {
        sendData(messagePort, data);
    }
}; 
</code></pre>
<h3>BroadcastChannel</h3>
<p><code>BroadcastChannel</code> 接口代理了一个命名频道，它允许同源的不同浏览器窗口、Tab页、frame或者 iframe 下的不同文档之间相互通信。</p>
<p>通过触发一个 <code>message</code> 事件，消息可以广播到所有监听了该频道的 <code>BroadcastChannel</code> 对象。</p>
<p>这种通道类型的设置比较简单， 不需要像 <code>MessageChannel</code> 那样转移乱糟糟的端口。</p>
<pre><code class="language-javascript">// main.js
const channel = new BroadcastChannel(&#x27;worker_channel&#x27;);

const worker = new Worker(&#x27;./worker.js&#x27;);

channel.onmessage = ({data}) =&gt; {
    console.log(`heard ${data} on page`);
}

setTimeout(() =&gt; channel.postMessage(&#x27;foo&#x27;), 1000);

// worker.js
const channel = new BroadcastChannel(&#x27;worker_channel&#x27;);

channel.onmessage = ({data}) =&gt; {
    console.log(`heard ${data} in worker`);
    channel.postMessage(&#x27;bar&#x27;);
} 
</code></pre>
<p><code>BroadcastChannel</code> 这种信道没有端口所有权的概念，所以如果没有实体监听这个信道，广播的消息就不会有人处理。</p>
<p>在这种情况下，如果没有 <code>setTimeout</code>，则由于初始化工作者线程的延迟，就会导致消息已经发送了，但工作者线程上的消息处理程序还没有就位。</p>
<h2>数据传输</h2>
<p>工作者线程是独立的上下文，因此在上下文之间传输数据就会产生消耗。</p>
<p>在支持传统多线程模型的语言中，可以使用锁、互斥量，以及 volatile 变量。</p>
<p>JavaScript 中有三种在上下文间转移信息的方式：</p>
<ul>
<li>结构化克隆算法</li>
<li>可转移对象</li>
<li>共享数组缓冲区</li>
</ul>
<h3>结构化克隆算法</h3>
<p>结构化克隆算法可用于在两个独立上下文间共享数据。该算法由浏览器在后台实现，不能直接调用。</p>
<p>在通过 <code>postMessage</code> 传递对象时，浏览器会遍历该对象，并在目标上下文中生成它的一个副本。</p>
<h3>可转移对象</h3>
<p>使用可转移对象可以把所有权从一个上下文转移到另一个上下文。在不太可能在上下文间复制大量数据的情况下，这个功能特别有用。</p>
<p>只有几种对象是可转移对象：</p>
<ul>
<li><code>ArrayBuffer</code></li>
<li><code>MessagePort</code></li>
<li><code>ImageBitmap</code></li>
<li><code>OffscreenCanvas</code></li>
</ul>
<p><code>postMessage</code> 方法的第二个可选参数是数组，它指定应该将哪些对象转移到目标上下文。</p>
<h3>SharedArrayBuffer</h3>
<p>在把 <code>SharedArrayBuffer</code> 传给 <code>postMessage</code> 时，浏览器只会传递原始缓冲区的引用。</p>
<p>两个不同的上下文会分别维护对同一个内存块的引用。每个上下文都可以随意修改这个缓冲区， 防止出现错误可以使用 <code>Atomics</code> API。</p>
<h1>共享工作者线程</h1>
<p>共享工作者线程或共享线程与专用工作者线程类似，但可以被多个可信任的执行上下文访问。</p>
<p>例如：同源的两个标签页可以访问同一个共享工作者线程。</p>
<p>共享工作者线程通过 <code>SharedWorker</code> 构造函数创建，和 <code>Worker</code> 参数相同。</p>
<p>Worker 构造函数始终会创建新线程，而 SharedWorker 则只会在相同的标识不存在的情况下才创建新线程。</p>
<p>标识取决于脚本 URL、名称和文档源。</p>
<p>如果的确存在与标识匹配的共享工作者线程，则只会与已有共享者线程建立新的连接。</p>
<pre><code class="language-javascript">new SharedWorker(&#x27;./sharedWorker.js&#x27;);
new SharedWorker(&#x27;./sharedWorker.js&#x27;);
new SharedWorker(&#x27;./sharedWorker.js&#x27;);
</code></pre>
<h2>连接</h2>
<p>SharedWorker 只有 <code>error</code> 事件和一个 <code>port</code> 属性，是一个 <code>MessagePort</code> 实例，专门用于通信。</p>
<p>在共享线程内部，全局作用域是 <code>SharedWorkerGlobalScope</code> 的实例，它没有 <code>postMessage</code> 等属性和事件，只有一个 <code>connect</code> 事件。</p>
<p>每次调用 SharedWorker 构造函数，无论是否创建了工作者线程，都会在共享线程内部触发 <code>connect</code> 事件。</p>
<p>发生 <code>connect</code> 事件时，SharedWorker 构造函数会隐式创建 MessageChannel 实例，并把 <code>MessagePort</code> 实例的所有权唯一地转移给该 SharedWorker 的实例。这个 <code>MessagePort</code> 实例会保存在 <code>connect</code> 事件对象的 <code>ports</code> 数组中。</p>
<p>所以 SharedWorker 想要通信需要通过该事件通过端口来通信。</p>
<pre><code class="language-javascript">// main.js
const worker = new SharedWorker(&#x27;./worker.js&#x27;)

worker.port.onmessage = e =&gt; console.log(e)

worker.port.postMessage(&#x27;aa&#x27;);

// worker.js
self.onconnect = ({ ports }) =&gt; {
    ports[0].onmessage = e =&gt; {
        ports[0].postMessage(e.data)
    }
};
</code></pre>
<blockquote>
<p>根据浏览器实现，在 SharedWorker 中把日志打印到控制台不一定能在浏览器默 认的控制台中看到。</p>
</blockquote>
<p>在Chrome 中，SharedWorker 上下文中的打印统统看不到，只有 Firefox 能够隐晦的看到。</p><div><a href="/notes/JavaScript/Web%20api">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"Web Worker","article":{"title":"Web Worker","content":"# 工作者线程\n\nWeb Worker 赋予了浏览器中的 JavaScript 多线程并发执行任务的能力。\n\n传统的多线程模型（例如：POSIX 线程或者 Java 线程）不适合 JavaScript，因为像 DOM 这样的 API 会出现问题。\n\n而这也正是工作者线程的价值所在：允许把主线程的工作转嫁给独立的实体，而不会改变现有的单线程模型。\n\nWeb 工作者线程规范中定义了三种主要的工作者线程：\n\n- **专用工作者线程**：通常简称为Web Worker，脚本可以单独创建一个 JavaScript 线程执行委托的任务\n\n- **共享工作者线程**：与专用工作者线程非常相似，主要区别是共享工作者线程可以被多个不同的上下文使用\n\n- **服务工作者线**：与专用工作者线程和共享工作者线程截然不同，它的主要用途是拦截、重定向和修改页面发出的请求\n\n# 专用工作者线程\n\n专用工作者线程可以称为后台脚本，JavaScript 线程的各个方面，包括生命周期管理、代码路径和输入/输出，都由初始化线程时提供的脚本来控制。\n\n## 创建\n\n通过 `Worker` 构造函数创建专用 Worker 线程，构造函数返回一个 Worker 实例，通过该实例可以和 Worker 通信。\n\n有两种创建 Worker 的方式，一种是通过同源的 URL，一种是通过行内生成Object URL 的方式。\n\n```javascript\nconst worker = new Worker('./worker.js', { type: \"module\" });\n\nconsole.log(worker); // Worker { }\n\n\n// 通过行内的方式创建 Worker\nconst workerScript = `\n\tself.onmessage = ({data}) =\u003e console.log(data);\n`;\nconst workerScriptBlob = new Blob([workerScript]);\n\nconst workerScriptBlobUrl = URL.createObjectURL(workerScriptBlob);\nconst worker = new Worker(workerScriptBlobUrl);\n```\n\n第二个参数可以传递配置：\n\n- `name`：可以在工作者线程中通过 `self.name` 读取到的字符串标识符\n- `type`：脚本的运行方式\n\t- `classic`：脚本作为常规脚本来执行\n\t- `module`：脚本作为模块执行\n- `credentials`：在 `type` 为 `\"module\"` 时，指定如何获取与传输凭证数据相关的工作者线程模块脚本\n\t- 这些选项与 `fetch` 的凭证选项相同\n\t- `omit`、`same-orign`、`include`\n\n## 实例\n\n构造函数返回的 Worker 对象是与刚创建的专用工作者线程通信的连接点。它可用于在工作者线程和父上下文间传输信息，以及捕获专用工作者线程发出的事件。\n\n### 事件\n\n- `onerror`：该事件会在工作者线程中抛出错误时发生\n- `onmessage`：该事件会在工作者线程向父上下文发送消息时发生\n- `onmessageerror`：该事件会在工作者线程收到无法反序列化的消息时发生\n\n由于 Worker 继承自 EventTarget，事件也可以通过 `worker.addEventListener` 来注册。\n\n如果工作者线程脚本抛出了错误，该工作者线程沙盒可以阻止它打断父线程的执行。即在父线程中无法捕获，只能通过事件。\n\n```javascript\n// worker.js\nthrow Error('foo');\n\n// main.js\ntry {\n    const worker = new Worker('./worker.js');\n    console.log('no error');\n} catch(e) {\n    console.log('caught error');\n}\n// no error\n\nconst worker = new Worker('./worker.js');\nworker.onerror = console.log; \n// ErrorEvent {message: \"Uncaught Error: foo\"}\n```\n\n### 方法\n\n- `postMessage`：用于通过异步消息事件向工作者线程发送信息\n- `terminate`：用于立即终止工作者线程。没有为工作者线程提供清理的机会，脚本会突然停止\n\n## 全局对象\n\n专用工作者线程的全局作用域是 `DedicatedWorkerGlobalScope` 的实例。因为这继承自 `WorkerGlobalScope`，所以包含它的所有属性和方法。工作者线程可以通过 `self` 关键字访问该全局作用域。\n\n`DedicatedWorkerGlobalScope` 增加的属性和方法：\n\n- `name`：Worker 构造函数的一个可选的字符串标识符\n- `postMessage`：与 `worker.postMessage` 对应的方法，用于从工作者线程内部向父上下文发送消息 \n- `close`：与 `worker.terminate` 对应的方法，用于立即终止工作者线程\n- `importScripts`：可以加载任意源的脚本，只能在 `classic` 脚本中使用，可以接收任意数量的脚本\n\n## 通信\n\n与工作者线程的通信都是通过异步消息完成的。\n\n### postMessage\n\n可以使用 `postMessage` 在主线程和工作者线程之间传递消息，传递的数据保存在事件对象 `e` 的 `data` 属性中。\n\n```javascript\n// worker.js\nfunction factorial(n) {\n    let result = 1;\n    while (n) { result *= n--; }\n    return result;\n}\n\nself.onmessage = (e) =\u003e self.postMessage(`${e.data}! = ${factorial(e.data)}`);\n\n// main.js\nconst worker = new Worker('./worker.js');\n\nworker.onmessage = e =\u003e console.log(e.data);\n\nworker.postMessage(5);\n```\n\n### MessageChannel\n\n`MessageChannel` 接口允许我们创建一个新的消息通道，并通过它的两个端口（`MessagePort` 实例）发送数据。\n\n`MessagePort` 实例具有 `onmessage` 等事件和 `postMessage` 方法。\n\n```javascript\nconst channel = new MessageChannel();\n\nconsole.log(channel);\n```\n\n![](http://oss.xiefeng.tech/img/20210328140040.png)\n\n首先父线程需要将端口传递给子线程，然后再开始使用端口通信。\n\n`MessagePort` 是可转移对象，可以使用 `postMessage` 的第二个参数进行传递端口，`MessagePort` 会自动保存在 `e.ports` 数组中。\n\n```javascript\n// worker.js\nlet messagePort = null;\n// 通过在全局的事件接收端口\nself.onmessage = e =\u003e {\n    messagePort = e.ports[0];\n    self.onmessage = null;\n    // 通过 channel 进行数据的发送、接收\n    messagePort.onmessage = e =\u003e messagePort.postMessage(`data: ${e.data}`);\n}; \n\n// main.js\nconst channel = new MessageChannel();\nconst worker = new Worker('./worker.js');\n\nworker.postMessage(null, [channel.port1]);  // 把端口发送到工作者线程\n// 通过 channel 发送、接收数据\nchannel.port2.onmessage = ({data}) =\u003e console.log(data);\nchannel.port2.postMessage(5);\n```\n\n使用 MessageChannel 实例与父进程通信感觉没有必要。MessageChannel 真正有用的地方是让两个子线程之间直接通信。\n\n父线程创建一个 channel，并将端口传递给子线程，让子线程之间通过端口进行通信。\n\n```javascript\n// main.js\nconst channel = new MessageChannel();\n\nconst workerA = new Worker('./worker.js');\n\nconst workerB = new Worker('./worker.js');\n\nworkerA.postMessage('workerA', [channel.port1]);\n\nworkerB.postMessage('workerB', [channel.port2]);\n\n// worker.js\nlet messagePort = null;\n\nfunction sendData(target, data) {\n    target.postMessage(data);\n}\n\nself.onmessage = ({data, ports}) =\u003e {\n    if (ports.length) {\n        messagePort = ports[0];\n        messagePort.onmessage = ({data}) =\u003e sendData(self, data);\n    } else {\n        sendData(messagePort, data);\n    }\n}; \n```\n\n### BroadcastChannel\n\n`BroadcastChannel` 接口代理了一个命名频道，它允许同源的不同浏览器窗口、Tab页、frame或者 iframe 下的不同文档之间相互通信。\n\n通过触发一个 `message` 事件，消息可以广播到所有监听了该频道的 `BroadcastChannel` 对象。\n\n这种通道类型的设置比较简单， 不需要像 `MessageChannel` 那样转移乱糟糟的端口。\n\n```javascript\n// main.js\nconst channel = new BroadcastChannel('worker_channel');\n\nconst worker = new Worker('./worker.js');\n\nchannel.onmessage = ({data}) =\u003e {\n    console.log(`heard ${data} on page`);\n}\n\nsetTimeout(() =\u003e channel.postMessage('foo'), 1000);\n\n// worker.js\nconst channel = new BroadcastChannel('worker_channel');\n\nchannel.onmessage = ({data}) =\u003e {\n    console.log(`heard ${data} in worker`);\n    channel.postMessage('bar');\n} \n```\n\n`BroadcastChannel` 这种信道没有端口所有权的概念，所以如果没有实体监听这个信道，广播的消息就不会有人处理。\n\n在这种情况下，如果没有 `setTimeout`，则由于初始化工作者线程的延迟，就会导致消息已经发送了，但工作者线程上的消息处理程序还没有就位。\n\n## 数据传输\n\n工作者线程是独立的上下文，因此在上下文之间传输数据就会产生消耗。\n\n在支持传统多线程模型的语言中，可以使用锁、互斥量，以及 volatile 变量。\n\nJavaScript 中有三种在上下文间转移信息的方式：\n\n- 结构化克隆算法\n- 可转移对象\n- 共享数组缓冲区\n\n### 结构化克隆算法\n\n结构化克隆算法可用于在两个独立上下文间共享数据。该算法由浏览器在后台实现，不能直接调用。\n\n在通过 `postMessage` 传递对象时，浏览器会遍历该对象，并在目标上下文中生成它的一个副本。\n\n###  可转移对象\n\n使用可转移对象可以把所有权从一个上下文转移到另一个上下文。在不太可能在上下文间复制大量数据的情况下，这个功能特别有用。\n\n只有几种对象是可转移对象：\n\n- `ArrayBuffer`\n- `MessagePort` \n- `ImageBitmap` \n- `OffscreenCanvas`\n\n`postMessage` 方法的第二个可选参数是数组，它指定应该将哪些对象转移到目标上下文。\n\n### SharedArrayBuffer\n\n在把 `SharedArrayBuffer` 传给 `postMessage` 时，浏览器只会传递原始缓冲区的引用。\n\n两个不同的上下文会分别维护对同一个内存块的引用。每个上下文都可以随意修改这个缓冲区， 防止出现错误可以使用 `Atomics` API。\n\n# 共享工作者线程\n\n共享工作者线程或共享线程与专用工作者线程类似，但可以被多个可信任的执行上下文访问。\n\n例如：同源的两个标签页可以访问同一个共享工作者线程。\n\n共享工作者线程通过 `SharedWorker` 构造函数创建，和 `Worker` 参数相同。\n\nWorker 构造函数始终会创建新线程，而 SharedWorker 则只会在相同的标识不存在的情况下才创建新线程。\n\n标识取决于脚本 URL、名称和文档源。\n\n如果的确存在与标识匹配的共享工作者线程，则只会与已有共享者线程建立新的连接。\n\n```javascript\nnew SharedWorker('./sharedWorker.js');\nnew SharedWorker('./sharedWorker.js');\nnew SharedWorker('./sharedWorker.js');\n```\n\n## 连接\n\nSharedWorker 只有 `error` 事件和一个 `port` 属性，是一个 `MessagePort` 实例，专门用于通信。\n\n在共享线程内部，全局作用域是 `SharedWorkerGlobalScope` 的实例，它没有 `postMessage` 等属性和事件，只有一个 `connect` 事件。\n\n每次调用 SharedWorker 构造函数，无论是否创建了工作者线程，都会在共享线程内部触发 `connect` 事件。\n\n发生 `connect` 事件时，SharedWorker 构造函数会隐式创建 MessageChannel 实例，并把 `MessagePort` 实例的所有权唯一地转移给该 SharedWorker 的实例。这个 `MessagePort` 实例会保存在 `connect` 事件对象的 `ports` 数组中。\n\n所以 SharedWorker 想要通信需要通过该事件通过端口来通信。\n\n```javascript\n// main.js\nconst worker = new SharedWorker('./worker.js')\n\nworker.port.onmessage = e =\u003e console.log(e)\n\nworker.port.postMessage('aa');\n\n// worker.js\nself.onconnect = ({ ports }) =\u003e {\n    ports[0].onmessage = e =\u003e {\n        ports[0].postMessage(e.data)\n    }\n};\n```\n\n\u003e 根据浏览器实现，在 SharedWorker 中把日志打印到控制台不一定能在浏览器默 认的控制台中看到。\n\n在Chrome 中，SharedWorker 上下文中的打印统统看不到，只有 Firefox 能够隐晦的看到。\n\n\n\n\n\n","meta":{"size":11509,"birthTime":1663496641399.3843,"updateTime":1663496641399.5793}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["JavaScript","Web api","Web Worker"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
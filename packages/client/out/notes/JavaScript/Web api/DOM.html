<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>DOM | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#Node" data-target-id="h1-Node-0">Node</a><ul><li><a href="#节点类型" data-target-id="h2-节点类型-0">节点类型</a></li><li><a href="#节点信息" data-target-id="h2-节点信息-1">节点信息</a></li><li><a href="#节点关系" data-target-id="h2-节点关系-2">节点关系</a></li><li><a href="#节点操作" data-target-id="h2-节点操作-3">节点操作</a></li></ul></li><li><a href="#Document" data-target-id="h1-Document-1">Document</a><ul><li><a href="#快捷信息" data-target-id="h2-快捷信息-4">快捷信息</a></li><li><a href="#获取元素" data-target-id="h2-获取元素-5">获取元素</a></li><li><a href="#文档写入" data-target-id="h2-文档写入-6">文档写入</a></li><li><a href="#其他扩展" data-target-id="h2-其他扩展-7">其他扩展</a></li></ul></li><li><a href="#Element" data-target-id="h1-Element-2">Element</a><ul><li><a href="#HTML元素" data-target-id="h2-HTML元素-8">HTML元素</a></li><li><a href="#属性操作" data-target-id="h2-属性操作-9">属性操作</a></li><li><a href="#元素关系" data-target-id="h2-元素关系-10">元素关系</a></li><li><a href="#插入内容" data-target-id="h2-插入内容-11">插入内容</a></li><li><a href="#区域滚动" data-target-id="h2-区域滚动-12">区域滚动</a></li></ul></li><li><a href="#Attr" data-target-id="h1-Attr-3">Attr</a></li><li><a href="#Text" data-target-id="h1-Text-4">Text</a></li><li><a href="#样式操作" data-target-id="h1-样式操作-5">样式操作</a><ul><li><a href="#classList" data-target-id="h2-classList-13">classList</a></li><li><a href="#style" data-target-id="h2-style-14">style</a></li><li><a href="#计算样式" data-target-id="h2-计算样式-15">计算样式</a></li><li><a href="#样式表" data-target-id="h2-样式表-16">样式表</a><ul><li><a href="#CSS 规则" data-target-id="h3-CSS 规则-0">CSS 规则</a></li><li><a href="#修改规则" data-target-id="h3-修改规则-1">修改规则</a></li><li><a href="#创建规则" data-target-id="h3-创建规则-2">创建规则</a></li><li><a href="#删除规则" data-target-id="h3-删除规则-3">删除规则</a></li></ul></li></ul></li><li><a href="#元素尺寸" data-target-id="h1-元素尺寸-6">元素尺寸</a><ul><li><a href="#偏移尺寸" data-target-id="h2-偏移尺寸-17">偏移尺寸</a></li><li><a href="#客户端尺寸" data-target-id="h2-客户端尺寸-18">客户端尺寸</a></li><li><a href="#滚动尺寸" data-target-id="h2-滚动尺寸-19">滚动尺寸</a></li><li><a href="#确定元素尺寸" data-target-id="h2-确定元素尺寸-20">确定元素尺寸</a></li></ul></li><li><a href="#DOM遍历" data-target-id="h1-DOM遍历-7">DOM遍历</a><ul><li><a href="#NodeIterator" data-target-id="h2-NodeIterator-21">NodeIterator</a></li><li><a href="#TreeWalker" data-target-id="h2-TreeWalker-22">TreeWalker</a></li></ul></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">DOM</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h1>Node</h1>
<p>所有 DOM 节点类型都实现了 Node 接口，Node 接口在 JavaScript中被实现为 Node 类型，所有类型的节点都继承 Node 类型</p>
<h2>节点类型</h2>
<p>每个节点都有 <code>nodeType</code> 属性，表示该节点的类型，Node 类型上定义了 12 个数值常量：</p>
<ul>
<li><code>Node.ELEMENT_NODE</code>（1）</li>
<li><code>Node.ATTRIBUTE_NODE</code>（2）</li>
<li><code>Node.TEXT_NODE</code>（3）</li>
<li>......</li>
</ul>
<h2>节点信息</h2>
<ul>
<li>
<p><code>nodeName</code>： 节点的名称，对于元素 <code>nodeName</code> 始终等于元素的标签名</p>
</li>
<li>
<p><code>nodeValue</code>：节点的值，Text 节点或 Comment 节点为文本内容，元素则始终为 <code>null</code></p>
</li>
</ul>
<h2>节点关系</h2>
<ul>
<li><code>parentNode</code>：最顶端的为 <code>#document</code></li>
<li><code>childNodes</code>：NodeList 实例，DOM 结构的变化会自动地反映出来，而不是第一次访问内容的快照</li>
<li><code>firstChild</code>、<code>lastChild</code>、<code>nextSibling</code>、<code>previousSibling</code></li>
<li><code>hasChildNodes()</code>：返回 <code>true</code> 则说明节点有一个或多个子节点</li>
<li><code>ownerDocument</code>：指向自己所在的整个文档的文档节点</li>
</ul>
<h2>节点操作</h2>
<ul>
<li><code>appendChild</code>：如果传递的是已经存在的节点，则这个节点会从之前的位置被转移到新位置</li>
<li><code>insertBefore</code>：如果参照节点是 <code>null</code>，效果等于 <code>appendChild</code></li>
<li><code>replaceChild</code>：要替换的节点会被返回并从文档树中完全移除，要插入的节点会取而代之</li>
<li><code>removeChild</code>：被移除的节点会被返回</li>
<li><code>cloneNode</code>：传入 <code>true</code> 会进行深复制（包括其整个子 DOM树），只复制 HTML 属性不包括事件</li>
<li><code>normalize</code>：处理文档子树中的文本节点<!-- -->
<ul>
<li>由于解析器实现的差异或 DOM 操作等原因，可能会出现并不包含文本的文本节点</li>
<li>也可能出现文本节点之间互为同胞关系</li>
<li><code>normalize</code> 会检测这个节点的所有后代进行修复</li>
</ul>
</li>
</ul>
<p>并非所有节点类型都有子节点，如果在不支持子节点的节点上调用操作子节点的方法，则会导致抛出错误</p>
<h1>Document</h1>
<p><code>Document</code> 是 JavaScript 中表示文档节点的类型，表示 HTML 文档或其他 XML 文档</p>
<p><code>document</code> 是 <code>HTMLDocument</code> 实例，<code>HTMLDocument</code> 继承 <code>Document</code></p>
<p>Document 节点的特点：</p>
<ul>
<li><code>nodeName</code>：<code>&#x27;#document&#x27;</code></li>
<li><code>nodeValue</code>：<code>null</code></li>
<li><code>parentNode</code>：<code>null</code></li>
<li><code>ownerDocument</code>：<code>null</code></li>
</ul>
<p>Document 节点的子节点可以是 DocumentType、Element、ProcessingInstruction 或 Comment</p>
<h2>快捷信息</h2>
<p>document 提供了几个访问子节点的快捷方式：</p>
<ul>
<li><code>document.documentElement</code>、<code>document.head</code>、<code>document.body</code></li>
<li><code>document.doctype</code>： 取得对 <code>&lt;!doctype&gt;</code> 标签的引用，节点类型为 DocumentType</li>
</ul>
<p>document 对象上提供了一些浏览器所加载网页的信息：</p>
<ul>
<li>
<p><code>document.title</code>：页面标题</p>
</li>
<li>
<p><code>document.URL</code>：当前页面地址栏中的 URL，只读</p>
</li>
<li>
<p><code>document.domain</code>：当前页面的域名</p>
</li>
<li>
<p><code>document.referrer</code>：链接到当前页面的那个页面的 URL，只读</p>
</li>
</ul>
<p>通过修改 <code>document.domain</code> 的值可以实现跨域：</p>
<p>当页面中包含来自某个不同<strong>子域</strong>的窗格（<code>&lt;frame&gt;</code>）或内嵌窗格（<code>&lt;iframe&gt;</code>）时，因为跨源通信存在安全隐患，所以不同子域的页面间无法通过 JavaScript 通信。此时，在每个页面上把 <code>document.domain</code> 设置为相同的父域名可以实现通信。</p>
<p><code>document</code> 对象上暴露了几个特殊集合，这些集合都是 HTMLCollection 的实例：</p>
<ul>
<li><code>document.anchors</code>：文档中所有带 <code>name</code> 属性的 <code>a</code> 元素</li>
<li><code>document.forms</code>：文档中所有 <code>form</code> 元素</li>
<li><code>document.images</code>：文档中所有 <code>img</code> 元素</li>
<li><code>document.links</code>：文档中所有带 <code>href</code> 属性的 <code>a</code> 元素</li>
</ul>
<h2>获取元素</h2>
<p>document 对象上暴露了一些方法，获取某个或某组元素的引用</p>
<ul>
<li><code>getElementById</code></li>
<li><code>getElementsByTagName</code>：传入 <code>*</code> 可以取得文档中的所有元素</li>
<li><code>getElementsByClassName</code></li>
</ul>
<p>返回 HTMLCollection 对象，和 NodeList 一样查询的结果都是实时的，具有和中括号相同作用的 <code>item</code> 方法</p>
<p>HTMLCollection 对象有一个额外的方法 <code>namedItem</code>，可通过标签的 <code>name</code> 属性取得某一项的引用</p>
<p>HTMLCollection 对象中括号既可以接收数值和字符串索引，背后会分别调用 <code>item</code> 和 <code>namedItem</code> 方法</p>
<ul>
<li><code>querySelector</code></li>
<li><code>querySelectorAll</code></li>
</ul>
<p><code>querySelectorAll</code> 返回的是一个 <code>NodeList</code> 的静态实例，避免了使用 <code>NodeList</code> 可能造成的性能问题</p>
<p>在 Document 和 Element 类上均有定义：</p>
<p><code>getElementsByTagName</code>、<code>getElementsByClassName</code>、<code>querySelectorAll</code>、<code>querySelector</code></p>
<h2>文档写入</h2>
<p><code>document</code> 对象有一个古老的能力，即向网页输出流中写入内容。</p>
<p>这个能力对应 4 个方法：<code>write</code>、 <code>writeln</code>、<code>open</code> 和 <code>close</code>。</p>
<p>在页面加载完之后调用 <code>document.write</code>，则输出的内容会重写整个页面。</p>
<p><code>open</code> 和 <code>close</code> 方法分别用于打开和关闭网页输出流，在调用 <code>write</code> 和 <code>writeln</code> 时，这两个方法不是必需的</p>
<h2>其他扩展</h2>
<ul>
<li><code>document.characterSet</code>：文档实际使用的字符集，可读写</li>
<li><code>document.compatMode</code>：标准模式下是 <code>&quot;CSS1Compat&quot;</code>，而在混杂模式下是 <code>&quot;BackCompat&quot;</code></li>
<li><code>document.readyState</code>
<ul>
<li><code>loading</code>：表示文档正在加载</li>
<li><code>complete</code>：表示文档加载完成</li>
</ul>
</li>
<li><code>document.activeElement</code>：指向当前拥有焦点的 DOM 元素<!-- -->
<ul>
<li>页面完全加载之前值为 null</li>
<li>页面刚加载完之后为 document.body</li>
</ul>
</li>
<li><code>document.hasFocus()</code>：判断文档是否拥有焦点</li>
</ul>
<h1>Element</h1>
<p>Element 表示 XML 或 HTML 元素，对外暴露出访问元素标签名、子节点和属性的能力</p>
<p>Element 类型的节点的特点：</p>
<ul>
<li><code>nodeName</code> 值为元素的标签名</li>
<li><code>nodeValue</code> 值为 <code>null</code></li>
</ul>
<p>使用 <code>document.createElement</code> 可以创建新的元素，同时新元素的 <code>ownerDocument</code> 会被设置为 <code>document</code></p>
<h2>HTML元素</h2>
<p>所有 HTML 元素都通过 <code>HTMLElement</code> 类型表示，所有 HTML 元素都是 HTMLElement 或其子类型的实例。</p>
<p>例如：div 元素为 HTMLDivElement 类型的实例</p>
<p>所有 HTML 元素上都有的标准属性：id、title、lang、dir、className</p>
<h2>属性操作</h2>
<p>每个元素都有零个或多个属性，通常用于为元素或其内容附加更多信息</p>
<ul>
<li><code>getAttribute</code></li>
<li><code>setAttribute</code></li>
<li><code>removeAttribute</code></li>
</ul>
<p>分别用于操纵元素的属性，包括 HTML 属性和自定义的属性。</p>
<ul>
<li>
<p>通过 <code>.</code> 只能读写 HTML 属性，自定义的属性只能添加到相应的 js 对象身上而无法添加到 DOM 上</p>
</li>
<li>
<p>通过 <code>attr</code> 方法既可以操作 HTML 属性，也可以操作自定义属性</p>
</li>
</ul>
<p>HTML5 允许给元素指定非标准的属性，但要使用前缀 <code>data-</code>，通过 <code>dataset</code> 来操作 <code>data-</code> 开头的自定义属性</p>
<ul>
<li><code>dom.dataset.pro</code></li>
<li><code>delete dom.dataset.pro</code></li>
</ul>
<h2>元素关系</h2>
<ul>
<li><code>parentElement</code>：最顶端的为 <code>html</code></li>
<li><code>children</code>、<code>firstElementChild</code>、<code>lastElementChild</code></li>
<li><code>childElementCount</code></li>
<li><code>contains</code>：确定一个元素是不是后代</li>
</ul>
<h2>插入内容</h2>
<ul>
<li><code>innerHTML</code>、<code>outerHTML</code></li>
</ul>
<p>在所有现代浏览器中，通过 innerHTML 插入的<code>script</code>是不会执行的，</p>
<ul>
<li><code>innerText</code>、<code>outerText</code></li>
</ul>
<p>读取文本值时两者会返回同样的内容，在写入文本值时 <code>outerText</code> 会替换整个元素</p>
<p><code>outerText</code> 是一个非标准的属性，而且也没有被标准化的前景</p>
<ul>
<li>
<p><code>dom.textContent</code>  得到的是内部源代码中的文本</p>
</li>
<li>
<p><code>insertAdjacentHTML()</code>、<code>insertAdjacentText()</code></p>
</li>
</ul>
<p>它们都接收两个参数：要插入标记的位置和要插入的 HTML 或文本</p>
<h2>区域滚动</h2>
<p>HTML5  标准化了 <code>scrollIntoView</code> 方法，用于滚动页面中的某个区域</p>
<p><code>scrollIntoView</code> 方法存在于所有 HTML 元素上，可以滚动浏览器窗口或容器元素以便包含元素进入视口</p>
<ul>
<li>alignToTop：窗口滚动后元素的顶部 / 底部与视口顶部对齐</li>
<li>scrollIntoViewOptions：滚动的选项</li>
</ul>
<p><code>scrollIntoViewIfNeeded</code> 会在元素不可见的情况下，将其滚动到窗口或包含窗口中使其可见，但是非标准</p>
<h1>Attr</h1>
<p>元素的每个属性都是一个 Attr 节点</p>
<p>Attr节点的 nodeName 是对应属性的属性名，nodeValue 则是属性值，parentNode 为 null</p>
<p><code>attributes</code> 属性返回一个 NamedNodeMap 实例，其中包含的是元素的每个 Attr 节点</p>
<p>NamedNodeMap 有一些方法：</p>
<ul>
<li><code>getNamedItem</code>：返回属性名为参数的 Attr 节点</li>
<li><code>removeNamedItem</code>：删除属性名为参数的 Attr 节点</li>
<li><code>setNamedItem</code>：添加属性节点</li>
<li><code>item</code>：返回索引位置 pos 处的节点</li>
</ul>
<h1>Text</h1>
<p>HTML 中的每段文本都被一个 Text 节点包含，Text 节点为 Text 类型</p>
<p>通过 <code>document.createTextNode</code> 可以创建新的文本节点</p>
<p>Text 节点的特征：</p>
<ul>
<li><code>nodeName</code> 值为 <code>&quot;#text&quot;</code></li>
<li><code>nodeValue</code> 值为节点中包含的文本</li>
<li>不支持子节点</li>
</ul>
<p>Text 节点中包含的文本可以通过 nodeValue 属性访问，也可以通过 data 属性访问</p>
<ul>
<li><code>appendData(text)</code>：向节点末尾添加文本 text</li>
<li><code>deleteData(offset, count)</code>：从位置 offset 开始删除 count 个字符</li>
<li><code>insertData(offset, text)</code>：在位置 offset 插入 text</li>
<li><code>replaceData(offset, count, text)</code>：用 text 替换从位置 offset 到 offset + count 的 文本</li>
<li><code>splitText(offset)</code>：在位置 offset 将当前文本节点拆分为两个文本节点</li>
<li><code>substringData(offset, count)</code>：提取从位置 offset 到 offset + count 的文本</li>
</ul>
<h1>样式操作</h1>
<p>HTML 中的样式有 3 种定义方式：外部样式表、文档样式表、元素特定样式。</p>
<p>DOM2 Style 为这 3 种应用样式的机制都提供了 API</p>
<h2>classList</h2>
<p>通过 classList 可以方便的实现类名的添加、删除和替换</p>
<ul>
<li><code>add(value)</code> 向类名列表中添加指定的字符串值 <code>value</code></li>
<li><code>contains(value)</code> 返回布尔值，表示给定的 <code>value</code> 是否存在</li>
<li><code>remove(value)</code> 从类名列表中删除指定的字符串值 <code>value</code></li>
<li><code>toggle(value)</code> 如果类名列表中已经存在指定的 <code>value</code>，则删除；如果不存在，则添加</li>
</ul>
<h2>style</h2>
<p>style 属性是 CSSStyleDeclaration 类型的实例，其中包含通过 HTML style 属性为元素设置的所有样式信息</p>
<p>DOM2 Style 规范在 <code>style</code> 对象上定义了一些属性和方法，提供了元素 <code>style</code> 属性的信息并支持修改：</p>
<ul>
<li><code>cssText</code>：<code>style</code> 属性中的 CSS 代码</li>
<li><code>length</code>：应用给元素的 CSS 属性数量</li>
<li><code>parentRule</code>：表示 CSS 信息的 <code>CSSRule</code> 对象</li>
<li><code>getPropertyPriority(propertyName)</code>：如果属性使用了 <code>!important</code> 返回 <code>important</code>否则返回 <code>&#x27;&#x27;</code></li>
<li><code>getPropertyValue(propertyName)</code>：返回属性的字符串值</li>
<li><code>removeProperty(propertyName)</code>：从样式中删除 CSS 属性</li>
<li><code>setProperty(propertyName, value, priority)</code>：设置 CSS 属性，<code>priority</code> 是<code>important</code>或 <code>&#x27;&#x27;</code></li>
</ul>
<h2>计算样式</h2>
<p><code>window.getComputedStyle(dom, pseudoElement)</code> 返回 <code>CSSStyleDeclaration</code> 类型的对象</p>
<ul>
<li><code>pseudoElement</code>: 可选，伪类元素，当不查询伪类元素的时候可以忽略或者传入 <code>null</code></li>
<li>获取的样式是元素在浏览器中<strong>最终渲染效果的样式</strong></li>
<li>返回的计算样式的值都是<strong>绝对值</strong></li>
</ul>
<p>浏览器虽然会返回样式值，但返回值的格式不一定相同</p>
<h2>样式表</h2>
<p><code>CSSStyleSheet</code> 类型表示 CSS 样式表，包括使用元素和通过 <code>link</code> 和 <code>style</code> 素定义的样式表。</p>
<p><code>CSSStyleSheet</code> 类型继承 <code>StyleSheet</code>，后者可用作非 CSS 样式表的基类。</p>
<ul>
<li><code>disabled</code>：表示样式表是否被禁用，可读写</li>
<li><code>href</code>：<code>link</code> 包含的样式表返回 URL，否则返回 <code>null</code></li>
<li><code>ownerNode</code>：指向拥有当前样式表的节点，<code>link</code> 或 <code>style</code> 元素</li>
<li><code>parentStyleSheet</code>：如果当前样式表是通过 <code>@import</code> 导入，则这个属性指向导入它的样式表</li>
<li><code>cssRules</code>：当前样式表包含的样式规则的集合</li>
<li><code>ownerRule</code>：如果样式表是使用 <code>@import</code> 导入的，则指向导入规则，否则为 <code>null</code></li>
<li><code>deleteRule(index)</code>：在指定位置删除 cssRules 中的规则</li>
<li><code>insertRule(rule, index)</code>：在指定位置向 cssRules 中插入规则</li>
</ul>
<p>通过  <code>document.styleSheets</code> 可以得到页面上所有的 CSS 样式表</p>
<h3>CSS 规则</h3>
<p>CSSRule 类型表示样式表中的一条规则，这个类型也是一个通用基类。</p>
<p>最常用的是表示样式信息的是 CSSStyleRule 类型，继承自 CSSRule</p>
<p>CSSStyleRule 对象上可用的属性：</p>
<ul>
<li><code>cssText</code>：整条规则的文本，这里的文本可能与样式表中实际的文本不一样</li>
<li><code>parentRule</code>：如果这条规则被其他规则（如@media）包含，则指向包含规则，否则就是 null</li>
<li><code>parentStyleSheet</code>：包含当前规则的样式表</li>
<li><code>selectorText</code>：返回规则的选择符文本</li>
<li><code>style</code>：CSSStyleDeclaration 对象，可以设置和获取当前规则中的样式</li>
<li><code>type</code>：数值常量，表示规则类型，对于样式规则，它始终为 1</li>
</ul>
<h3>修改规则</h3>
<p>通过 <code>style</code> 属性可以通过类似修改元素 <code>style</code> 属性一样修改规则中的样式，但是这样修改规则会影响到页面上所有应用了该规则的元素</p>
<pre><code class="language-javascript">document.styleSheets[0].cssRules[0].style.height = &#x27;1000px&#x27;
</code></pre>
<h3>创建规则</h3>
<p>可以使用 <code>insertRule()</code> 方法向样式表中添加新规则，该方法接收两个参数：</p>
<ul>
<li>规则的文本</li>
<li>插入位置的索引值</li>
</ul>
<pre><code class="language-javascript">sheet.insertRule(&quot;body { background-color: silver }&quot;, 0);
</code></pre>
<h3>删除规则</h3>
<p>通过 <code>deleteRule()</code> 方法从样式表中删除一条规则，该方法的参数：要删除规则的索引</p>
<pre><code class="language-javascript">sheet.deleteRule(0)
</code></pre>
<h1>元素尺寸</h1>
<h2>偏移尺寸</h2>
<ul>
<li><code>offsetHeight</code>、<code>offsetWidth</code> 元素的<strong>可视区</strong>的宽高（包括滚动条，除了 <code>body</code> 和 <code>html</code>）</li>
<li><code>offsetLeft</code>、<code>offsetTop</code> 相对于包含元素的距离，包含元素保存在 <code>offsetParent</code> 属性中</li>
</ul>
<p><code>body</code> 的 <code>offsetLeft</code>、<code>offsetTop</code> 为 0</p>
<ul>
<li><code>offsetParent</code>
<ul>
<li>返回最近的<strong>有定位</strong>的父级；否则返回 <code>body</code></li>
<li><code>body</code> 的上一级为 <code>null</code></li>
</ul>
</li>
</ul>
<p><img src="http://oss.xiefeng.tech/img/20210306210831.png" alt=""/></p>
<h2>客户端尺寸</h2>
<blockquote>
<p>包含元素内容及其内边距所占用的空间</p>
</blockquote>
<ul>
<li>
<p><code>dom.clientWidth</code>、<code>dom.clientHeight</code></p>
<p>返回的是元素的显示的内容的宽高（ <code>padding-box - barWidth</code> ) ，元素内部的空间不包括滚动条</p>
</li>
</ul>
<p><code>documentElement.clientWidth / clientHeight</code>  返回的是<strong>视口</strong>的宽高（不包括滚动条的宽度）</p>
<p>与偏移尺寸一样，客户端尺寸也是只读的，而且每次访问都会重新计算。</p>
<p><img src="http://oss.xiefeng.tech/img/20210306210901.png" alt=""/></p>
<h2>滚动尺寸</h2>
<ul>
<li><code>scrollHeight</code>、<code>scrollWidth</code>：没有滚动条出现时，元素内容的总宽高</li>
<li><code>scrollLeft</code>、<code>scrollTop</code>：内容区左侧/顶部隐藏的像素数，设置这个属性可以改变元素的滚动位置。</li>
</ul>
<p>通常认位 <code>&lt;html&gt;</code> 是浏览器视口中的滚动元素，所以 <code>documentElement.scrollHeight</code> / <code>scrollWidth</code>代表的就是页面的高度 / 宽度。</p>
<p><img src="http://oss.xiefeng.tech/img/20210306210659.png" alt=""/></p>
<h2>确定元素尺寸</h2>
<p><code>getBoundingClientRect</code>，返回一个 <code>DOMRect</code> 对象，包含：<code>left</code>、<code>top</code>、<code>right</code>、<code>bottom</code>、<code>height</code> 和 <code>width</code>。这些属性给出了元素在页面中相对于视口的位置。</p>
<p><code>height</code>、<code>width</code> 是<strong>可视区</strong>的大小。</p>
<p><img src="https://oss.xiefeng.tech/img/20210821105750.png" alt=""/></p>
<h1>DOM遍历</h1>
<p>DOM2 Traversal and Range 模块定义了两个类型用于辅助顺序遍历 DOM 结构：</p>
<ul>
<li>
<p>NodeIterator</p>
</li>
<li>
<p>TreeWalker</p>
</li>
</ul>
<p>从某个起点开始执行对 DOM 结构的深度优先遍历，DOM 树中的任何节点都可以成为遍历的根节点</p>
<h2>NodeIterator</h2>
<p>通过 <code>document.createNodeIterator()</code> 方法创建实例：</p>
<ul>
<li><code>root</code>：作为遍历根节点的节点</li>
<li><code>whatToShow</code>：数值代码，表示应该访问哪些节点</li>
<li><code>filter</code>：NodeFilter 对象或函数，表示是否接收或跳过特定节点</li>
<li><code>entityReferenceExpansion</code>：表示是否扩展实体引用，HTML 文档中没有效果（实体引用永远不扩展）</li>
</ul>
<p><code>whatToShow</code> 是一个位掩码，指定访问哪些节点，对应的常量在 NodeFilter 上定义：</p>
<ul>
<li><code>NodeFilter.SHOW_ALL</code>：所有节点</li>
<li><code>NodeFilter.SHOW_ELEMENT</code>：元素节点</li>
<li><code>NodeFilter.SHOW_TEXT</code>：文本节点</li>
<li>.......</li>
</ul>
<p>除了 <code>NodeFilter.SHOW_ALL</code> 之外，其他值都可以通过按位或组合使用：</p>
<pre><code class="language-javascript">let whatToShow = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT; 
</code></pre>
<p>NodeFilter为有 <code>acceptNode(node)</code> 方法的对象 =&gt; <code>NodeFilter.FILTER_ACCEPT</code>、<code>NodeFilter.FILTER_SKIP</code></p>
<p>通过 <code>nextNode()</code> 和 <code>previousNode()</code> 方法进行遍历：</p>
<pre><code class="language-javascript">const iterator = document.createNodeIterator(
    document.getElementById(&quot;div1&quot;), 
    NodeFilter.SHOW_ELEMENT, 
    null, 
    false
);

let node = iterator.nextNode()

while (node) {
    console.log(node)
    node = iterator.nextNode()
}

console.log(node, iterator.previousNode())
</code></pre>
<h2>TreeWalker</h2>
<p>TreeWalker 是 NodeIterator 的高级版。除了 <code>nextNode()</code>、<code>previousNode()</code> 方法，还添加了在 DOM 结构中向不同方向遍历的方法：</p>
<ul>
<li><code>parentNode()</code>：遍历到当前节点的父节点</li>
<li><code>firstChild()</code>：遍历到当前节点的第一个子节点</li>
<li><code>lastChild()</code>：遍历到当前节点的最后一个子节点</li>
<li><code>nextSibling()</code>：遍历到当前节点的下一个同胞节点</li>
<li><code>previousSibling()</code>：遍历到当前节点的上一个同胞节点。</li>
</ul>
<p>通过 <code>document.createTreeWalker()</code> 方法创建实例，接收和 NodeIterator 相同的参数</p><div><a href="/notes/JavaScript/Web%20api">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"DOM","article":{"title":"DOM","content":"# Node\r\n\r\n所有 DOM 节点类型都实现了 Node 接口，Node 接口在 JavaScript中被实现为 Node 类型，所有类型的节点都继承 Node 类型\r\n\r\n## 节点类型\r\n\r\n每个节点都有 `nodeType` 属性，表示该节点的类型，Node 类型上定义了 12 个数值常量：\r\n\r\n- `Node.ELEMENT_NODE`（1）\r\n- `Node.ATTRIBUTE_NODE`（2）\r\n- `Node.TEXT_NODE`（3）\r\n- ......\r\n\r\n## 节点信息\r\n\r\n- `nodeName`： 节点的名称，对于元素 `nodeName` 始终等于元素的标签名\r\n\r\n- `nodeValue`：节点的值，Text 节点或 Comment 节点为文本内容，元素则始终为 `null`\r\n\r\n## 节点关系\r\n\r\n- `parentNode`：最顶端的为 `#document`\r\n- `childNodes`：NodeList 实例，DOM 结构的变化会自动地反映出来，而不是第一次访问内容的快照\r\n- `firstChild`、`lastChild`、`nextSibling`、`previousSibling`\r\n- `hasChildNodes()`：返回 `true` 则说明节点有一个或多个子节点\r\n- `ownerDocument`：指向自己所在的整个文档的文档节点\r\n\r\n## 节点操作\r\n\r\n- `appendChild`：如果传递的是已经存在的节点，则这个节点会从之前的位置被转移到新位置\r\n- `insertBefore`：如果参照节点是 `null`，效果等于 `appendChild`\r\n- `replaceChild`：要替换的节点会被返回并从文档树中完全移除，要插入的节点会取而代之\r\n- `removeChild`：被移除的节点会被返回\r\n- `cloneNode`：传入 `true` 会进行深复制（包括其整个子 DOM树），只复制 HTML 属性不包括事件\r\n- `normalize`：处理文档子树中的文本节点\r\n\t- 由于解析器实现的差异或 DOM 操作等原因，可能会出现并不包含文本的文本节点\r\n\t- 也可能出现文本节点之间互为同胞关系\r\n\t- `normalize` 会检测这个节点的所有后代进行修复\r\n\r\n并非所有节点类型都有子节点，如果在不支持子节点的节点上调用操作子节点的方法，则会导致抛出错误\r\n\r\n# Document\r\n\r\n`Document` 是 JavaScript 中表示文档节点的类型，表示 HTML 文档或其他 XML 文档\r\n\r\n`document` 是 `HTMLDocument` 实例，`HTMLDocument` 继承 `Document`\r\n\r\nDocument 节点的特点：\r\n\r\n- `nodeName`：`'#document'`\r\n- `nodeValue`：`null`\r\n- `parentNode`：`null`\r\n- `ownerDocument`：`null`\r\n\r\nDocument 节点的子节点可以是 DocumentType、Element、ProcessingInstruction 或 Comment\r\n\r\n## 快捷信息\r\n\r\ndocument 提供了几个访问子节点的快捷方式：\r\n\r\n- `document.documentElement`、`document.head`、`document.body`\r\n- `document.doctype`： 取得对 `\u003c!doctype\u003e` 标签的引用，节点类型为 DocumentType\r\n\r\ndocument 对象上提供了一些浏览器所加载网页的信息：\r\n\r\n- `document.title`：页面标题\r\n\r\n- `document.URL`：当前页面地址栏中的 URL，只读\r\n- `document.domain`：当前页面的域名\r\n- `document.referrer`：链接到当前页面的那个页面的 URL，只读\r\n\r\n通过修改 `document.domain` 的值可以实现跨域：\r\n\r\n当页面中包含来自某个不同**子域**的窗格（`\u003cframe\u003e`）或内嵌窗格（`\u003ciframe\u003e`）时，因为跨源通信存在安全隐患，所以不同子域的页面间无法通过 JavaScript 通信。此时，在每个页面上把 `document.domain` 设置为相同的父域名可以实现通信。\r\n\r\n`document` 对象上暴露了几个特殊集合，这些集合都是 HTMLCollection 的实例：\r\n\r\n- `document.anchors`：文档中所有带 `name` 属性的 `a` 元素\r\n- `document.forms`：文档中所有 `form` 元素\r\n- `document.images`：文档中所有 `img` 元素\r\n- `document.links`：文档中所有带 `href` 属性的 `a` 元素\r\n\r\n## 获取元素\r\n\r\ndocument 对象上暴露了一些方法，获取某个或某组元素的引用\r\n\r\n- `getElementById`\r\n- `getElementsByTagName`：传入 `*` 可以取得文档中的所有元素\r\n- `getElementsByClassName`\r\n\r\n返回 HTMLCollection 对象，和 NodeList 一样查询的结果都是实时的，具有和中括号相同作用的 `item` 方法\r\n\r\nHTMLCollection 对象有一个额外的方法 `namedItem`，可通过标签的 `name` 属性取得某一项的引用\r\n\r\nHTMLCollection 对象中括号既可以接收数值和字符串索引，背后会分别调用 `item` 和 `namedItem` 方法\r\n\r\n- `querySelector`\r\n- `querySelectorAll`\r\n\r\n`querySelectorAll` 返回的是一个 `NodeList` 的静态实例，避免了使用 `NodeList` 可能造成的性能问题\r\n\r\n在 Document 和 Element 类上均有定义：\r\n\r\n`getElementsByTagName`、`getElementsByClassName`、`querySelectorAll`、`querySelector` \r\n\r\n## 文档写入\r\n\r\n`document` 对象有一个古老的能力，即向网页输出流中写入内容。\r\n\r\n这个能力对应 4 个方法：`write`、 `writeln`、`open` 和 `close`。\r\n\r\n在页面加载完之后调用 `document.write`，则输出的内容会重写整个页面。\r\n\r\n`open` 和 `close` 方法分别用于打开和关闭网页输出流，在调用 `write` 和 `writeln` 时，这两个方法不是必需的\r\n\r\n## 其他扩展\r\n\r\n- `document.characterSet`：文档实际使用的字符集，可读写\r\n- `document.compatMode`：标准模式下是 `\"CSS1Compat\"`，而在混杂模式下是 `\"BackCompat\"`\r\n- `document.readyState`\r\n\t- `loading`：表示文档正在加载\r\n\t- `complete`：表示文档加载完成\r\n- `document.activeElement`：指向当前拥有焦点的 DOM 元素\r\n\t- 页面完全加载之前值为 null\r\n\t- 页面刚加载完之后为 document.body\r\n- `document.hasFocus()`：判断文档是否拥有焦点\r\n\r\n# Element\r\n\r\nElement 表示 XML 或 HTML 元素，对外暴露出访问元素标签名、子节点和属性的能力\r\n\r\nElement 类型的节点的特点：\r\n\r\n- `nodeName` 值为元素的标签名\r\n- `nodeValue` 值为 `null`\r\n\r\n使用 `document.createElement` 可以创建新的元素，同时新元素的 `ownerDocument` 会被设置为 `document`\r\n\r\n## HTML元素\r\n\r\n所有 HTML 元素都通过 `HTMLElement` 类型表示，所有 HTML 元素都是 HTMLElement 或其子类型的实例。\r\n\r\n例如：div 元素为 HTMLDivElement 类型的实例\r\n\r\n所有 HTML 元素上都有的标准属性：id、title、lang、dir、className\r\n\r\n## 属性操作\r\n\r\n每个元素都有零个或多个属性，通常用于为元素或其内容附加更多信息\r\n\r\n- `getAttribute`\r\n- `setAttribute`\r\n- `removeAttribute`\r\n\r\n分别用于操纵元素的属性，包括 HTML 属性和自定义的属性。\r\n\r\n- 通过 `.` 只能读写 HTML 属性，自定义的属性只能添加到相应的 js 对象身上而无法添加到 DOM 上\r\n\r\n- 通过 `attr` 方法既可以操作 HTML 属性，也可以操作自定义属性\r\n\r\nHTML5 允许给元素指定非标准的属性，但要使用前缀 `data-`，通过 `dataset` 来操作 `data-` 开头的自定义属性\r\n\r\n- `dom.dataset.pro`\r\n- `delete dom.dataset.pro`\r\n\r\n## 元素关系\r\n\r\n- `parentElement`：最顶端的为 `html`\r\n- `children`、`firstElementChild`、`lastElementChild`\r\n- `childElementCount`\r\n- `contains`：确定一个元素是不是后代\r\n\r\n## 插入内容\r\n\r\n- `innerHTML`、`outerHTML`\r\n\r\n在所有现代浏览器中，通过 innerHTML 插入的`script`是不会执行的，\r\n\r\n- `innerText`、`outerText`\r\n\r\n读取文本值时两者会返回同样的内容，在写入文本值时 `outerText` 会替换整个元素\r\n\r\n`outerText` 是一个非标准的属性，而且也没有被标准化的前景\r\n\r\n- `dom.textContent`  得到的是内部源代码中的文本\r\n\r\n- `insertAdjacentHTML()`、`insertAdjacentText()`\r\n\r\n它们都接收两个参数：要插入标记的位置和要插入的 HTML 或文本\r\n\r\n## 区域滚动\r\n\r\nHTML5  标准化了 `scrollIntoView` 方法，用于滚动页面中的某个区域\r\n\r\n`scrollIntoView` 方法存在于所有 HTML 元素上，可以滚动浏览器窗口或容器元素以便包含元素进入视口\r\n\r\n- alignToTop：窗口滚动后元素的顶部 / 底部与视口顶部对齐\r\n- scrollIntoViewOptions：滚动的选项\r\n\r\n`scrollIntoViewIfNeeded` 会在元素不可见的情况下，将其滚动到窗口或包含窗口中使其可见，但是非标准\r\n\r\n# Attr\r\n\r\n元素的每个属性都是一个 Attr 节点\r\n\r\nAttr节点的 nodeName 是对应属性的属性名，nodeValue 则是属性值，parentNode 为 null\r\n\r\n`attributes` 属性返回一个 NamedNodeMap 实例，其中包含的是元素的每个 Attr 节点\r\n\r\nNamedNodeMap 有一些方法：\r\n\r\n- `getNamedItem`：返回属性名为参数的 Attr 节点\r\n- `removeNamedItem`：删除属性名为参数的 Attr 节点\r\n- `setNamedItem`：添加属性节点\r\n- `item`：返回索引位置 pos 处的节点\r\n\r\n# Text\r\n\r\nHTML 中的每段文本都被一个 Text 节点包含，Text 节点为 Text 类型\r\n\r\n通过 `document.createTextNode` 可以创建新的文本节点\r\n\r\nText 节点的特征：\r\n\r\n- `nodeName` 值为 `\"#text\"`\r\n- `nodeValue` 值为节点中包含的文本\r\n- 不支持子节点\r\n\r\nText 节点中包含的文本可以通过 nodeValue 属性访问，也可以通过 data 属性访问\r\n\r\n- `appendData(text)`：向节点末尾添加文本 text\r\n- `deleteData(offset, count)`：从位置 offset 开始删除 count 个字符\r\n- `insertData(offset, text)`：在位置 offset 插入 text\r\n-  `replaceData(offset, count, text)`：用 text 替换从位置 offset 到 offset + count 的 文本\r\n- `splitText(offset)`：在位置 offset 将当前文本节点拆分为两个文本节点\r\n- `substringData(offset, count)`：提取从位置 offset 到 offset + count 的文本\r\n\r\n# 样式操作\r\n\r\nHTML 中的样式有 3 种定义方式：外部样式表、文档样式表、元素特定样式。\r\n\r\nDOM2 Style 为这 3 种应用样式的机制都提供了 API\r\n\r\n## classList\r\n\r\n通过 classList 可以方便的实现类名的添加、删除和替换\r\n\r\n- `add(value)` 向类名列表中添加指定的字符串值 `value`\r\n- `contains(value)` 返回布尔值，表示给定的 `value` 是否存在\r\n- `remove(value)` 从类名列表中删除指定的字符串值 `value`\r\n- `toggle(value)` 如果类名列表中已经存在指定的 `value`，则删除；如果不存在，则添加\r\n\r\n## style\r\n\r\nstyle 属性是 CSSStyleDeclaration 类型的实例，其中包含通过 HTML style 属性为元素设置的所有样式信息\r\n\r\nDOM2 Style 规范在 `style` 对象上定义了一些属性和方法，提供了元素 `style` 属性的信息并支持修改：\r\n\r\n- `cssText`：`style` 属性中的 CSS 代码\r\n-  `length`：应用给元素的 CSS 属性数量\r\n- `parentRule`：表示 CSS 信息的 `CSSRule` 对象\r\n- `getPropertyPriority(propertyName)`：如果属性使用了 `!important` 返回 `important`否则返回 `''`\r\n- `getPropertyValue(propertyName)`：返回属性的字符串值\r\n- `removeProperty(propertyName)`：从样式中删除 CSS 属性\r\n- `setProperty(propertyName, value, priority)`：设置 CSS 属性，`priority` 是`important`或 `''`\r\n\r\n## 计算样式\r\n\r\n`window.getComputedStyle(dom, pseudoElement)` 返回 `CSSStyleDeclaration` 类型的对象\r\n\r\n- `pseudoElement`: 可选，伪类元素，当不查询伪类元素的时候可以忽略或者传入 `null`\r\n- 获取的样式是元素在浏览器中**最终渲染效果的样式**\r\n- 返回的计算样式的值都是**绝对值**\r\n\r\n浏览器虽然会返回样式值，但返回值的格式不一定相同\r\n\r\n## 样式表\r\n\r\n`CSSStyleSheet` 类型表示 CSS 样式表，包括使用元素和通过 `link` 和 `style` 素定义的样式表。\r\n\r\n`CSSStyleSheet` 类型继承 `StyleSheet`，后者可用作非 CSS 样式表的基类。\r\n\r\n- `disabled`：表示样式表是否被禁用，可读写\r\n- `href`：`link` 包含的样式表返回 URL，否则返回 `null`\r\n- `ownerNode`：指向拥有当前样式表的节点，`link` 或 `style` 元素\r\n- `parentStyleSheet`：如果当前样式表是通过 `@import` 导入，则这个属性指向导入它的样式表\r\n- `cssRules`：当前样式表包含的样式规则的集合\r\n- `ownerRule`：如果样式表是使用 `@import` 导入的，则指向导入规则，否则为 `null`\r\n- `deleteRule(index)`：在指定位置删除 cssRules 中的规则\r\n- `insertRule(rule, index)`：在指定位置向 cssRules 中插入规则\r\n\r\n通过  `document.styleSheets` 可以得到页面上所有的 CSS 样式表\r\n\r\n###  CSS 规则\r\n\r\nCSSRule 类型表示样式表中的一条规则，这个类型也是一个通用基类。\r\n\r\n最常用的是表示样式信息的是 CSSStyleRule 类型，继承自 CSSRule\r\n\r\nCSSStyleRule 对象上可用的属性：\r\n\r\n- `cssText`：整条规则的文本，这里的文本可能与样式表中实际的文本不一样\r\n- `parentRule`：如果这条规则被其他规则（如@media）包含，则指向包含规则，否则就是 null\r\n- `parentStyleSheet`：包含当前规则的样式表\r\n- `selectorText`：返回规则的选择符文本\r\n- `style`：CSSStyleDeclaration 对象，可以设置和获取当前规则中的样式\r\n- `type`：数值常量，表示规则类型，对于样式规则，它始终为 1\r\n\r\n### 修改规则\r\n\r\n通过 `style` 属性可以通过类似修改元素 `style` 属性一样修改规则中的样式，但是这样修改规则会影响到页面上所有应用了该规则的元素\r\n\r\n```javascript\r\ndocument.styleSheets[0].cssRules[0].style.height = '1000px'\r\n```\r\n\r\n###  创建规则\r\n\r\n可以使用 `insertRule()` 方法向样式表中添加新规则，该方法接收两个参数：\r\n\r\n- 规则的文本\r\n- 插入位置的索引值\r\n\r\n```javascript\r\nsheet.insertRule(\"body { background-color: silver }\", 0);\r\n```\r\n\r\n### 删除规则\r\n\r\n通过 `deleteRule()` 方法从样式表中删除一条规则，该方法的参数：要删除规则的索引\r\n\r\n```javascript\r\nsheet.deleteRule(0)\r\n```\r\n\r\n# 元素尺寸\r\n\r\n## 偏移尺寸\r\n\r\n- `offsetHeight`、`offsetWidth` 元素的**可视区**的宽高（包括滚动条，除了 `body` 和 `html`）\r\n- `offsetLeft`、`offsetTop` 相对于包含元素的距离，包含元素保存在 `offsetParent` 属性中\r\n\r\n`body` 的 `offsetLeft`、`offsetTop` 为 0\r\n\r\n- `offsetParent`\r\n\t- 返回最近的**有定位**的父级；否则返回 `body`\r\n\t- `body` 的上一级为 `null`\r\n\r\n![](http://oss.xiefeng.tech/img/20210306210831.png)\r\n\r\n## 客户端尺寸\r\n\r\n\u003e 包含元素内容及其内边距所占用的空间\r\n\r\n- `dom.clientWidth`、`dom.clientHeight`\r\n\r\n\t返回的是元素的显示的内容的宽高（ `padding-box - barWidth` ) ，元素内部的空间不包括滚动条\r\n\r\n`documentElement.clientWidth / clientHeight`  返回的是**视口**的宽高（不包括滚动条的宽度）\r\n\r\n与偏移尺寸一样，客户端尺寸也是只读的，而且每次访问都会重新计算。\r\n\r\n![](http://oss.xiefeng.tech/img/20210306210901.png)\r\n\r\n## 滚动尺寸\r\n\r\n- `scrollHeight`、`scrollWidth`：没有滚动条出现时，元素内容的总宽高\r\n- `scrollLeft`、`scrollTop`：内容区左侧/顶部隐藏的像素数，设置这个属性可以改变元素的滚动位置。 \r\n\r\n通常认位 `\u003chtml\u003e` 是浏览器视口中的滚动元素，所以 `documentElement.scrollHeight` / `scrollWidth`代表的就是页面的高度 / 宽度。\r\n\r\n![](http://oss.xiefeng.tech/img/20210306210659.png)\r\n\r\n##  确定元素尺寸\r\n\r\n`getBoundingClientRect`，返回一个 `DOMRect` 对象，包含：`left`、`top`、`right`、`bottom`、`height` 和 `width`。这些属性给出了元素在页面中相对于视口的位置。\r\n\r\n`height`、`width` 是**可视区**的大小。\r\n\r\n![](https://oss.xiefeng.tech/img/20210821105750.png)\r\n\r\n# DOM遍历\r\n\r\nDOM2 Traversal and Range 模块定义了两个类型用于辅助顺序遍历 DOM 结构：\r\n\r\n- NodeIterator\r\n\r\n- TreeWalker\r\n\r\n从某个起点开始执行对 DOM 结构的深度优先遍历，DOM 树中的任何节点都可以成为遍历的根节点\r\n\r\n## NodeIterator\r\n\r\n通过 `document.createNodeIterator()` 方法创建实例：\r\n\r\n- `root`：作为遍历根节点的节点\r\n- `whatToShow`：数值代码，表示应该访问哪些节点\r\n- `filter`：NodeFilter 对象或函数，表示是否接收或跳过特定节点\r\n- `entityReferenceExpansion`：表示是否扩展实体引用，HTML 文档中没有效果（实体引用永远不扩展）\r\n\r\n`whatToShow` 是一个位掩码，指定访问哪些节点，对应的常量在 NodeFilter 上定义：\r\n\r\n- `NodeFilter.SHOW_ALL`：所有节点\r\n- `NodeFilter.SHOW_ELEMENT`：元素节点\r\n- `NodeFilter.SHOW_TEXT`：文本节点\r\n- .......\r\n\r\n除了 `NodeFilter.SHOW_ALL` 之外，其他值都可以通过按位或组合使用：\r\n\r\n```javascript\r\nlet whatToShow = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT; \r\n```\r\n\r\nNodeFilter为有 `acceptNode(node)` 方法的对象 =\u003e `NodeFilter.FILTER_ACCEPT`、`NodeFilter.FILTER_SKIP`\r\n\r\n通过 `nextNode()` 和 `previousNode()` 方法进行遍历：\r\n\r\n```javascript\r\nconst iterator = document.createNodeIterator(\r\n    document.getElementById(\"div1\"), \r\n    NodeFilter.SHOW_ELEMENT, \r\n    null, \r\n    false\r\n);\r\n\r\nlet node = iterator.nextNode()\r\n\r\nwhile (node) {\r\n    console.log(node)\r\n    node = iterator.nextNode()\r\n}\r\n\r\nconsole.log(node, iterator.previousNode())\r\n```\r\n\r\n## TreeWalker\r\n\r\nTreeWalker 是 NodeIterator 的高级版。除了 `nextNode()`、`previousNode()` 方法，还添加了在 DOM 结构中向不同方向遍历的方法：\r\n\r\n- `parentNode()`：遍历到当前节点的父节点\r\n- `firstChild()`：遍历到当前节点的第一个子节点\r\n- `lastChild()`：遍历到当前节点的最后一个子节点\r\n- `nextSibling()`：遍历到当前节点的下一个同胞节点\r\n- `previousSibling()`：遍历到当前节点的上一个同胞节点。\r\n\r\n通过 `document.createTreeWalker()` 方法创建实例，接收和 NodeIterator 相同的参数\r\n","meta":{"size":17620,"birthTime":1663496641397.411,"updateTime":1663496641397.7288}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["JavaScript","Web api","DOM"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
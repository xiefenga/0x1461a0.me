<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>canvas | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#图形" data-target-id="h2-图形-0">图形</a></li><li><a href="#背景填充" data-target-id="h2-背景填充-1">背景填充</a></li><li><a href="#其他" data-target-id="h2-其他-2">其他</a></li><li><a href="#图像处理" data-target-id="h2-图像处理-3">图像处理</a></li><li><a href="#尺寸设置" data-target-id="h2-尺寸设置-4">尺寸设置</a></li><li><a href="#画布状态" data-target-id="h2-画布状态-5">画布状态</a></li><li><a href="#路径" data-target-id="h2-路径-6">路径</a><ul><li><a href="#beginPath" data-target-id="h3-beginPath-0">beginPath</a></li></ul></li><li><a href="#变形" data-target-id="h2-变形-7">变形</a></li><li><a href="#path2D" data-target-id="h2-path2D-8">path2D</a></li><li><a href="#绘制平滑曲线" data-target-id="h2-绘制平滑曲线-9">绘制平滑曲线</a></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">canvas</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><p>vscode 添加 <code>/** @type {HTMLCanvasElement} **/</code>  即可拥有 canvas 提示</p>
<h2>图形</h2>
<ol>
<li>
<p>画线</p>
<pre><code class="language-js">const canvas = document.getElementById(&#x27;canvas&#x27;);
const ctx = canvas.getContext(&#x27;2d&#x27;);
ctx.beginPath();
ctx.moveTo(100, 100);
ctx.lineTo(200, 200);
ctx.stroke();
</code></pre>
</li>
<li>
<p>矩形</p>
<pre><code class="language-js">ctx.beginPath();
ctx.rect(100, 100, 200, 200);
ctx.stroke();
// or
ctx.beginPath();
ctx.strokeRect(100, 100, 200, 200);

// 填充矩形
ctx.beginPath();
ctx.fillRect(100, 100, 200, 200);
</code></pre>
</li>
<li>
<p>圆弧</p>
<ul>
<li>
<p><code>arc(x, y, radius, startAngle, endAngle, acticlockwise)</code></p>
<p><code>endAngle</code> 是顺时针方向来数，开始和结束的弧度都需要传弧度（<code>Math.PI</code>），最后一个参数是否逆时针</p>
</li>
</ul>
<pre><code class="language-js">ctx.beginPath();
ctx.arc(100, 100, 50, 0, 60 * Math.PI / 180, false);
ctx.stroke();
</code></pre>
<ul>
<li>
<p><code>arcTo(x1, y1, x2, y2, radius)</code></p>
<p><code>arcTo()</code> 方法在画布上创建介于两个切线之间的弧/曲线。</p>
<p><img src="https://oss.xiefeng.tech/images/20210906202258.png" alt=""/></p>
</li>
</ul>
<pre><code class="language-js">ctx.beginPath();
ctx.moveTo(110, 100);
ctx.arcTo(200, 100, 200, 150, 10);
ctx.arcTo(200, 200, 100, 200, 10);
ctx.arcTo(100, 200, 100, 100, 10);
ctx.arcTo(100, 100, 200, 100, 10);
ctx.stroke();
</code></pre>
</li>
</ol>
<h2>背景填充</h2>
<p>背景的填充都是从canvas的原点开始的</p>
<ol>
<li>
<p>纯色填充</p>
<pre><code class="language-js">ctx.fillStyle = &quot;red&quot;;
</code></pre>
</li>
<li>
<p>图片填充</p>
<pre><code class="language-js">ctx.beginPath();
const img = new Image();
img.src = &#x27;./1.jpg&#x27;;
img.onload = function () {
    const bg = ctx.createPattern(img, &#x27;no-repeat&#x27;);
    ctx.fillStyle = bg;
    ctx.translate(100, 100);
    ctx.fillRect(0, 0, 200, 200);
}
</code></pre>
</li>
<li>
<p>线性渐变</p>
<pre><code class="language-js">ctx.beginPath();
var bg = ctx.createLinearGradient(0, 0, 200, 0);
ctx.fillStyle = bg;
ctx.translate(100, 100);
bg.addColorStop(0, &quot;white&quot;);
bg.addColorStop(0.5, &quot;black&quot;);
bg.addColorStop(1, &quot;white&quot;);
ctx.fillRect(0, 0, 200, 200);
</code></pre>
</li>
<li>
<p>辐射渐变</p>
<pre><code class="language-js">ctx.beginPath();
var bg = ctx.createRadialGradient(100, 100, 0, 100, 100, 100);
ctx.fillStyle = bg;
ctx.translate(100, 100);
bg.addColorStop(0, &quot;white&quot;);
bg.addColorStop(0.5, &quot;black&quot;);
bg.addColorStop(1, &quot;white&quot;);
ctx.fillRect(0, 0, 200, 200);
</code></pre>
</li>
</ol>
<h2>其他</h2>
<ol>
<li>
<p>阴影</p>
<pre><code class="language-js">ctx.shadowColor = &quot;red&quot;;ctx.shadowBlur = 10;ctx.shadowOffsetX = 0;ctx.shadowOffsetY = 0;ctx.strokeRect(100, 100, 100, 100);
</code></pre>
</li>
<li>
<p>文字</p>
<p><code>ctx.strokeText(text, x, y)</code>    空心文字</p>
<p><code>ctx.font = &quot;20px consolas&quot;</code></p>
<p><code>ctx.fillText(text, x, y)</code>   实心文字</p>
<p><code>ctx.textAlign</code>、<code>ctx.textBaseline</code> 设置文字对齐方式</p>
<p><img src="https://oss.xiefeng.tech/images/20210906202258.png" alt=""/></p>
</li>
<li>
<p>线段样式</p>
<pre><code class="language-js">ctx.lineCap = &quot;butt | round | square&quot;;ctx.lineJoin = &quot;bevel | miter | round&quot;;ctx.miterLimit = 5;
</code></pre>
</li>
<li>
<p>属性合成</p>
<p><code>ctx.globalCompositeOperation</code>  属性设置或返回如何将一个源（新的）图像绘制到目标（已有）的图像上，该属性需要设置在两个图形绘制的中间</p>
<!-- -->&lt;img src=&quot;https://oss.xiefeng.tech/images/20210906202258.png&quot; style=&quot;zoom: 33%;&quot; /&gt;<!-- -->
<pre><code class="language-js">ctx.beginPath();ctx.fillStyle = &quot;#eee&quot;;ctx.fillRect(100, 100, 100, 100);ctx.globalCompositeOperation = &quot;source-out&quot;;  // 位置很重要ctx.beginPath();ctx.fillStyle = &quot;#aaa&quot;;ctx.fillRect(150, 150, 100, 100);
</code></pre>
</li>
</ol>
<h2>图像处理</h2>
<ol>
<li>
<p>设置图片</p>
<p><code>drawImage()</code> 方法在画布上绘制图像、画布或视频，也能够绘制图像的某些部分，以及/或者增加或减少图像的尺寸。</p>
<ol>
<li>定位</li>
</ol>
<pre><code class="language-js">ctx.drawImage(img,x,y);
</code></pre>
<ol>
<li>在画布上定位图像，并规定图像的宽度和高度</li>
</ol>
<pre><code class="language-js">ctx.drawImage(img,x,y,width,height);
</code></pre>
<ol>
<li>剪切图像，并在画布上定位被剪切的部分</li>
</ol>
<p>参数：开始剪切的 x y坐标，被剪切图像的宽高，在画布上放置图像的坐标，要使用的图像的宽高（放大/缩小）</p>
<pre><code class="language-js">ctx.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);
</code></pre>
</li>
<li>
<p>将 canvas 导出为图片</p>
<p><code>canvas.toDataURL()</code> 可以将该 canvas 的整个内容导出为一个base64的图片</p>
</li>
<li>
<p>得到图片的信息</p>
<p><code>ctx.getImageData(x, y, width, height)</code> 可以得到指定区域的像素点信息</p>
<p><code>ctx.putImageData(imgData,x,y,dirtyX,dirtyY,dirtyWidth,dirtyHeight)</code> 将图像数据（从指定的 <code>ImageData</code> 对象）放回画布上</p>
<p>参数：<code>ImageData</code> 对象左上角的坐标，在画布上放置图像的位置（可选），在画布上绘制图像所使用的宽高（可选）</p>
</li>
</ol>
<h2>尺寸设置</h2>
<p>Canvas 的默认大小为 300 × 150，元素实际在页面中占据的大小由 CSS 控制</p>
<p>画布会伸缩以适应 CSS 所设置的尺寸，当画布尺寸和 CSS 尺寸比例不一致时会出现扭曲</p>
<p>元素大小默认等于设置的画布大小（无 CSS 设置宽高的情况）</p>
<p>当改变画布的长度或者宽度时，画布中的内容会被清空，上下文对象的属性值会被重置</p>
<h2>画布状态</h2>
<p>CanvasRenderingContext2D 包含了多种绘图的样式状态（线的样式、填充样式、阴影样式等）</p>
<ul>
<li>
<p><code>save</code> 将当前 canvas 的状态压入绘图堆栈中，保存目前 canvas 的状态</p>
</li>
<li>
<p><code>restore</code> 从绘图堆栈中弹出上一个 canvas 状态，恢复之前的绘图状态</p>
</li>
</ul>
<p>存储在状态堆栈的数据列表：</p>
<ul>
<li>坐标变换（变换矩阵）信息</li>
<li>剪贴区域</li>
<li>渲染上下文对象（<code>CanvasRenderingContext2D</code>）的属性值</li>
</ul>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/strokeStyle"><code>strokeStyle</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/fillStyle"><code>fillStyle</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/globalAlpha"><code>globalAlpha</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineWidth"><code>lineWidth</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineCap"><code>lineCap</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineJoin"><code>lineJoin</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/miterLimit"><code>miterLimit</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineDashOffset"><code>lineDashOffset</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetX"><code>shadowOffsetX</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetY"><code>shadowOffsetY</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowBlur"><code>shadowBlur</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowColor"><code>shadowColor</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation"><code>globalCompositeOperation</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/font"><code>font</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/textAlign"><code>textAlign</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/textBaseline"><code>textBaseline</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/direction"><code>direction</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/imageSmoothingEnabled"><code>imageSmoothingEnabled</code></a></p>
</blockquote>
<h2>路径</h2>
<h3>beginPath</h3>
<p><code>beginPath</code> 方法用于开始一段新路径</p>
<p>canvas 中的绘制方法（<code>stroke</code>、<code>fill</code> 等）都会以上一次 <code>beginPath</code> 之后的所有路径为基础进行绘制</p>
<ol>
<li>无论使用 <code>moveTo</code> 把画笔移动到哪里，只要没有 <code>beginPath</code>，都是在画一条路径</li>
<li><code>fillRect</code> 与 <code>strokeRect</code> 这种直接画出独立区域的函数，也不会打断当前的路径</li>
</ol>
<pre><code class="language-javascript">ctx.beginPath()
ctx.moveTo(100.5, 20.5)
ctx.lineTo(200.5, 20.5)
ctx.stroke()

debugger
ctx.moveTo(100.5, 40.5)
ctx.lineTo(200.5, 40.5)
ctx.strokeStyle = &#x27;#f00&#x27;
ctx.stroke()
</code></pre>
<p>这段代码绘制出的图案是两条红线，因为两次 stroke 都是以 beginPath 后的所有路径为基础画的</p>
<p>第一条路径 stroke 了两下，第一下是黑的，第二下是红的，所以最终也是红的</p>
<p>![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220731165857256.png)</p>
<p>![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220731170011798.png)</p>
<h2>变形</h2>
<p><code>translate(x, y)</code> 将 canvas 的原点进行移动</p>
<pre><code class="language-javascript">for (let i = 0; i &lt; 3; i++) {
  for (let j = 0; j &lt; 3; j++) {
    ctx.save()
    ctx.fillStyle = `rgb(${51 * i}, ${255 - 51 * i}, 255)`
    ctx.translate(10 + j * 50, 10 + i * 50)
    ctx.fillRect(0, 0, 25, 25)
    ctx.restore()
  }
}
</code></pre>
<p><code>rotate(angle)</code> 将坐标轴顺时针旋转指定的弧度</p>
<ul>
<li>参数计算方式 <code>degree * Math.PI / 180</code></li>
<li>旋转中心点为 canvas 的原点</li>
</ul>
<p><code>scale(x, y)</code>  可以缩放画布的水平和垂直的单位</p>
<ul>
<li>x 为水平缩放因子，y 为垂直缩放因子</li>
<li>如果比 1 小，会缩小图形，如果比 1 大会放大图形</li>
<li>默认值为 1，为实际大小</li>
</ul>
<p><code>transform(a, b, c, d, e, f)</code>  用于使用矩阵多次叠加当前变换</p>
<ul>
<li>该方法是将当前的变形矩阵乘上一个基于自身参数的矩阵（每调用 transform 都会在前一个变换矩阵上构建）</li>
<li>可以缩放、旋转、移动和倾斜上下文</li>
<li><code>setTransform</code> 使用单位矩阵重新设置（覆盖）当前的变换</li>
<li><code>resetTransform</code> 重置坐标轴的变换</li>
</ul>
<p>矩阵：</p>
<pre><code class="language-javascript">a  c  e             x
b  d  f      *      y
0  0  1             1
</code></pre>
<p>![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220731213302126.png)</p>
<h2>path2D</h2>
<h2>绘制平滑曲线</h2>
<p>由于浏览器对 <code>mousemove</code> 事件的采集频率，使用 <code>lineTo</code> 无法绘制平滑的曲线</p>
<p>可以通过 <code>quadraticCurveTo</code> 绘制二次贝塞尔曲线的方式绘制出平滑曲线</p>
<p><img src="https://img2020.cnblogs.com/blog/449809/202008/449809-20200803174427946-1862846632.png" alt=""/></p>
<p><a href="https://segmentfault.com/a/1190000016672567">https://segmentfault.com/a/1190000016672567</a></p><div><a href="/notes/JavaScript/Web%20api">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"canvas","article":{"title":"canvas","content":"vscode 添加 `/** @type {HTMLCanvasElement} **/`  即可拥有 canvas 提示\n\n## 图形\n\n1. 画线\n\n   ```js\n   const canvas = document.getElementById('canvas');\n   const ctx = canvas.getContext('2d');\n   ctx.beginPath();\n   ctx.moveTo(100, 100);\n   ctx.lineTo(200, 200);\n   ctx.stroke();\n   ```\n\n2. 矩形\n\n   ```js\n   ctx.beginPath();\n   ctx.rect(100, 100, 200, 200);\n   ctx.stroke();\n   // or\n   ctx.beginPath();\n   ctx.strokeRect(100, 100, 200, 200);\n   \n   // 填充矩形\n   ctx.beginPath();\n   ctx.fillRect(100, 100, 200, 200);\n   ```\n\n3. 圆弧\n\n   - `arc(x, y, radius, startAngle, endAngle, acticlockwise)`   \n\n     `endAngle` 是顺时针方向来数，开始和结束的弧度都需要传弧度（`Math.PI`），最后一个参数是否逆时针\n\n   ```js\n   ctx.beginPath();\n   ctx.arc(100, 100, 50, 0, 60 * Math.PI / 180, false);\n   ctx.stroke();\n   ```\n\n   - `arcTo(x1, y1, x2, y2, radius)`\n\n     `arcTo()` 方法在画布上创建介于两个切线之间的弧/曲线。\n\n     ![](https://oss.xiefeng.tech/images/20210906202258.png)\n\n   ```js\n   ctx.beginPath();\n   ctx.moveTo(110, 100);\n   ctx.arcTo(200, 100, 200, 150, 10);\n   ctx.arcTo(200, 200, 100, 200, 10);\n   ctx.arcTo(100, 200, 100, 100, 10);\n   ctx.arcTo(100, 100, 200, 100, 10);\n   ctx.stroke();\n   ```\n\n\n\n## 背景填充\n\n背景的填充都是从canvas的原点开始的\n\n1. 纯色填充\n\n   ```js\n   ctx.fillStyle = \"red\";\n   ```\n\n2. 图片填充\n\n   ```js\n   ctx.beginPath();\n   const img = new Image();\n   img.src = './1.jpg';\n   img.onload = function () {\n       const bg = ctx.createPattern(img, 'no-repeat');\n       ctx.fillStyle = bg;\n       ctx.translate(100, 100);\n       ctx.fillRect(0, 0, 200, 200);\n   }\n   ```\n\n3. 线性渐变\n\n   ```js\n   ctx.beginPath();\n   var bg = ctx.createLinearGradient(0, 0, 200, 0);\n   ctx.fillStyle = bg;\n   ctx.translate(100, 100);\n   bg.addColorStop(0, \"white\");\n   bg.addColorStop(0.5, \"black\");\n   bg.addColorStop(1, \"white\");\n   ctx.fillRect(0, 0, 200, 200);\n   ```\n\n4. 辐射渐变\n\n   ```js\n   ctx.beginPath();\n   var bg = ctx.createRadialGradient(100, 100, 0, 100, 100, 100);\n   ctx.fillStyle = bg;\n   ctx.translate(100, 100);\n   bg.addColorStop(0, \"white\");\n   bg.addColorStop(0.5, \"black\");\n   bg.addColorStop(1, \"white\");\n   ctx.fillRect(0, 0, 200, 200);\n   ```\n\n## 其他\n\n1. 阴影\n\n   ```js\n   ctx.shadowColor = \"red\";ctx.shadowBlur = 10;ctx.shadowOffsetX = 0;ctx.shadowOffsetY = 0;ctx.strokeRect(100, 100, 100, 100);\n   ```\n\n2. 文字\n\n   `ctx.strokeText(text, x, y)`    空心文字\n\n   `ctx.font = \"20px consolas\"`\n\n   `ctx.fillText(text, x, y)`   实心文字\n\n   `ctx.textAlign`、`ctx.textBaseline` 设置文字对齐方式\n\n   ![](https://oss.xiefeng.tech/images/20210906202258.png)\n\n3. 线段样式\n\n   ```js\n   ctx.lineCap = \"butt | round | square\";ctx.lineJoin = \"bevel | miter | round\";ctx.miterLimit = 5;\n   ```\n\n4. 属性合成\n\n   `ctx.globalCompositeOperation`  属性设置或返回如何将一个源（新的）图像绘制到目标（已有）的图像上，该属性需要设置在两个图形绘制的中间\n\n   \u003cimg src=\"https://oss.xiefeng.tech/images/20210906202258.png\" style=\"zoom: 33%;\" /\u003e\n\n   ```js\n   ctx.beginPath();ctx.fillStyle = \"#eee\";ctx.fillRect(100, 100, 100, 100);ctx.globalCompositeOperation = \"source-out\";  // 位置很重要ctx.beginPath();ctx.fillStyle = \"#aaa\";ctx.fillRect(150, 150, 100, 100);\n   ```\n\n## 图像处理\n\n1. 设置图片\n\n   `drawImage()` 方法在画布上绘制图像、画布或视频，也能够绘制图像的某些部分，以及/或者增加或减少图像的尺寸。\n\n   1. 定位\n\n   ```js\n   ctx.drawImage(img,x,y);\n   ```\n\n   1. 在画布上定位图像，并规定图像的宽度和高度\n\n   ```js\n   ctx.drawImage(img,x,y,width,height);\n   ```\n\n   1. 剪切图像，并在画布上定位被剪切的部分\n\n   参数：开始剪切的 x y坐标，被剪切图像的宽高，在画布上放置图像的坐标，要使用的图像的宽高（放大/缩小）\n\n   ```js\n   ctx.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);\n   ```\n\n2. 将 canvas 导出为图片\n\n   `canvas.toDataURL()` 可以将该 canvas 的整个内容导出为一个base64的图片\n\n3. 得到图片的信息\n\n   `ctx.getImageData(x, y, width, height)` 可以得到指定区域的像素点信息\n\n   `ctx.putImageData(imgData,x,y,dirtyX,dirtyY,dirtyWidth,dirtyHeight)` 将图像数据（从指定的 `ImageData` 对象）放回画布上\n\n   参数：`ImageData` 对象左上角的坐标，在画布上放置图像的位置（可选），在画布上绘制图像所使用的宽高（可选）\n\n\n\n## 尺寸设置\n\nCanvas 的默认大小为 300 × 150，元素实际在页面中占据的大小由 CSS 控制\n\n画布会伸缩以适应 CSS 所设置的尺寸，当画布尺寸和 CSS 尺寸比例不一致时会出现扭曲\n\n元素大小默认等于设置的画布大小（无 CSS 设置宽高的情况）\n\n当改变画布的长度或者宽度时，画布中的内容会被清空，上下文对象的属性值会被重置\n\n## 画布状态\n\nCanvasRenderingContext2D 包含了多种绘图的样式状态（线的样式、填充样式、阴影样式等）\n\n- `save` 将当前 canvas 的状态压入绘图堆栈中，保存目前 canvas 的状态\n\n- `restore` 从绘图堆栈中弹出上一个 canvas 状态，恢复之前的绘图状态\n\n存储在状态堆栈的数据列表：\n\n- 坐标变换（变换矩阵）信息\n- 剪贴区域\n- 渲染上下文对象（`CanvasRenderingContext2D`）的属性值\n\n\u003e [`strokeStyle`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/strokeStyle), [`fillStyle`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/fillStyle), [`globalAlpha`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/globalAlpha), [`lineWidth`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineWidth), [`lineCap`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineCap), [`lineJoin`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineJoin), [`miterLimit`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/miterLimit), [`lineDashOffset`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineDashOffset), [`shadowOffsetX`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetX), [`shadowOffsetY`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetY), [`shadowBlur`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowBlur), [`shadowColor`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowColor), [`globalCompositeOperation`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation), [`font`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/font), [`textAlign`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/textAlign), [`textBaseline`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/textBaseline), [`direction`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/direction), [`imageSmoothingEnabled`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/imageSmoothingEnabled)\n\n## 路径\n\n### beginPath\n\n`beginPath` 方法用于开始一段新路径\n\ncanvas 中的绘制方法（`stroke`、`fill` 等）都会以上一次 `beginPath` 之后的所有路径为基础进行绘制\n\n1. 无论使用 `moveTo` 把画笔移动到哪里，只要没有 `beginPath`，都是在画一条路径\n2. `fillRect` 与 `strokeRect` 这种直接画出独立区域的函数，也不会打断当前的路径\n\n```javascript\nctx.beginPath()\nctx.moveTo(100.5, 20.5)\nctx.lineTo(200.5, 20.5)\nctx.stroke()\n\ndebugger\nctx.moveTo(100.5, 40.5)\nctx.lineTo(200.5, 40.5)\nctx.strokeStyle = '#f00'\nctx.stroke()\n```\n\n这段代码绘制出的图案是两条红线，因为两次 stroke 都是以 beginPath 后的所有路径为基础画的\n\n第一条路径 stroke 了两下，第一下是黑的，第二下是红的，所以最终也是红的\n\n![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220731165857256.png)\n\n![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220731170011798.png)\n\n## 变形\n\n`translate(x, y)` 将 canvas 的原点进行移动\n\n```javascript\nfor (let i = 0; i \u003c 3; i++) {\n  for (let j = 0; j \u003c 3; j++) {\n    ctx.save()\n    ctx.fillStyle = `rgb(${51 * i}, ${255 - 51 * i}, 255)`\n    ctx.translate(10 + j * 50, 10 + i * 50)\n    ctx.fillRect(0, 0, 25, 25)\n    ctx.restore()\n  }\n}\n```\n\n`rotate(angle)` 将坐标轴顺时针旋转指定的弧度\n\n- 参数计算方式 `degree * Math.PI / 180` \n- 旋转中心点为 canvas 的原点\n\n`scale(x, y)`  可以缩放画布的水平和垂直的单位\n\n- x 为水平缩放因子，y 为垂直缩放因子\n- 如果比 1 小，会缩小图形，如果比 1 大会放大图形\n- 默认值为 1，为实际大小\n\n`transform(a, b, c, d, e, f)`  用于使用矩阵多次叠加当前变换\n\n- 该方法是将当前的变形矩阵乘上一个基于自身参数的矩阵（每调用 transform 都会在前一个变换矩阵上构建）\n- 可以缩放、旋转、移动和倾斜上下文\n- `setTransform` 使用单位矩阵重新设置（覆盖）当前的变换\n- `resetTransform` 重置坐标轴的变换\n\n矩阵：\n\n```javascript\na  c  e             x\nb  d  f      *      y\n0  0  1             1\n```\n\n![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220731213302126.png)\n\n## path2D\n\n\n\n\n\n\n\n## 绘制平滑曲线\n\n由于浏览器对 `mousemove` 事件的采集频率，使用 `lineTo` 无法绘制平滑的曲线\n\n可以通过 `quadraticCurveTo` 绘制二次贝塞尔曲线的方式绘制出平滑曲线\n\n![](https://img2020.cnblogs.com/blog/449809/202008/449809-20200803174427946-1862846632.png)\n\nhttps://segmentfault.com/a/1190000016672567\n\n\n\n","meta":{"size":10014,"birthTime":1663496641399.6614,"updateTime":1663496641400.0774}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["JavaScript","Web api","canvas"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
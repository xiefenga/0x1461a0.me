<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>AJAX | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#XHR" data-target-id="h1-XHR-0">XHR</a><ul><li><a href="#方法" data-target-id="h2-方法-0">方法</a></li><li><a href="#属性" data-target-id="h2-属性-1">属性</a></li><li><a href="#readyState" data-target-id="h2-readyState-2">readyState</a></li><li><a href="#使用" data-target-id="h2-使用-3">使用</a></li></ul></li><li><a href="#FormData" data-target-id="h1-FormData-1">FormData</a><ul><li><a href="#方法" data-target-id="h2-方法-4">方法</a></li><li><a href="#使用" data-target-id="h2-使用-5">使用</a></li></ul></li><li><a href="#进度事件" data-target-id="h1-进度事件-2">进度事件</a><ul><li><a href="#事件" data-target-id="h2-事件-6">事件</a></li><li><a href="#使用" data-target-id="h2-使用-7">使用</a></li></ul></li><li><a href="#Fetch" data-target-id="h1-Fetch-3">Fetch</a><ul><li><a href="#中断请求" data-target-id="h2-中断请求-8">中断请求</a></li><li><a href="#Header" data-target-id="h2-Header-9">Header</a></li><li><a href="#Request" data-target-id="h2-Request-10">Request</a><ul><li><a href="#克隆Request" data-target-id="h3-克隆Request-0">克隆Request</a></li><li><a href="#传入fetch" data-target-id="h3-传入fetch-1">传入fetch</a></li></ul></li><li><a href="#Response" data-target-id="h2-Response-11">Response</a></li><li><a href="#Body" data-target-id="h2-Body-12">Body</a></li></ul></li><li><a href="#WebSocket" data-target-id="h1-WebSocket-4">WebSocket</a><ul><li><a href="#状态" data-target-id="h2-状态-13">状态</a></li><li><a href="#发送 / 接收数据" data-target-id="h2-发送 / 接收数据-14">发送 / 接收数据</a></li><li><a href="#事件" data-target-id="h2-事件-15">事件</a></li></ul></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">AJAX</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h1>XHR</h1>
<p>把 Ajax 推到历史舞台上的关键技术是 XMLHttpRequest(XHR)对象。这个对象最早由微软发明， 然后被其他浏览器所借鉴</p>
<p>所有现代浏览器都通过 XMLHttpRequest 构造函数原生支持 XHR 对象</p>
<pre><code class="language-javascript">const xhr = new XMLHttpRequest()
</code></pre>
<h2>方法</h2>
<ol>
<li><code>xhr.open(method, url, async)</code>：为发送请求做好准备</li>
<li><code>xhr.setRequestHeader(key, value)</code>：为保证请求头部被发送，必须在 <code>open</code> 之后、<code>send</code> 之前调用</li>
<li><code>overrideMimeType(mimetype)</code>：用于重写 XHR <strong>响应</strong>的 MIME 类型，在 <code>open</code> 之后、<code>send</code> 之前调用</li>
<li><code>xhr.send(data)</code>：没有消息体，必须传递 <code>null</code>，调用之后就会发送请求</li>
<li><code>xhr.abort()</code>：在收到响应之前取消异步请求</li>
<li><code>xhr.getResponseHeader(key)</code>：获取响应头部</li>
<li><code>xhr.getAllResponseHeaders()</code>：取得所有响应头部，该方法会返回包含所有响应头部的字符串</li>
</ol>
<pre><code class="language-http">Date: Sun, 14 Nov 2004 18:04:03 GMT
Server: Apache/1.3.29 (Unix)
Vary: Accept
X-Powered-By: PHP/4.3.8
Connection: close
Content-Type: text/html charset=iso-8859-1
</code></pre>
<h2>属性</h2>
<ol>
<li><code>timeout</code>：设置了 <code>timeout</code> 且超时之后，XHR 对象就会触发 <code>timeout</code> 事件，调用 <code>ontimeout</code> 事件处理程序</li>
<li><code>withCredentials</code>：设置跨源请求提供凭据（cookie、HTTP 认证和客户端 SSL 证书）</li>
<li><code>responseText</code>：作为响应主体被返回的文本</li>
<li><code>status</code>：相应的 HTTP 状态</li>
<li><code>statusText</code>：响应的 HTTP 状态描述</li>
</ol>
<h2>readyState</h2>
<p>XHR 对象有一个 readyState 属性，表示当前处在请求/响应过程的哪个阶段：</p>
<ul>
<li>
<p><code>0</code>：未初始化，尚未调用 <code>open()</code></p>
</li>
<li>
<p><code>1</code>：已打开，调用了 <code>open()</code>，还没有调用 <code>send()</code></p>
</li>
<li>
<p><code>2</code>：已发送，调用了 <code>send()</code>，还没有收到响应</p>
</li>
<li>
<p><code>3</code>：接收中，已经收到部分响应数据</p>
</li>
<li>
<p><code>4</code>：完成，已经接收到全部响应数据，可以使用</p>
</li>
</ul>
<p>为保证跨浏览器兼容，<code>readystatechange</code> 事件处理程序应该在调用 <code>open()</code> 之前注册</p>
<h2>使用</h2>
<pre><code class="language-javascript">const xhr = new XMLHttpRequest()

xhr.addEventListener(&#x27;readystatechange&#x27;, () =&gt; {
  if (xhr.readyState === 4) {
    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) {
      console.log(xhr.responseText)
    } else {
      console.log(&quot;Request was unsuccessful: &quot; + xhr.status)
    }
  }
})

xhr.open(&#x27;get&#x27;, &#x27;https://www.xiefeng.tech&#x27;, true)

xhr.timeout = 1000 // 设置 1 秒超时

xhr.ontimeout = () =&gt; console.log(&quot;Request did not return in a second.&quot;)

xhr.overrideMimeType(&quot;text/xml&quot;)

xhr.send(null)
</code></pre>
<h1>FormData</h1>
<p>FormData 类型便于创建 <code>multipart/form-data</code> 格式的数据，FormData 实例可以直接传给 XHR 对象的 <code>send()</code> 方法</p>
<pre><code class="language-javascript">const fd = new FormData()
</code></pre>
<p>可以通过直接给 FormData 构造函数传入一个表单元素</p>
<pre><code class="language-javascript">const fd = new FormData(document.forms[0])
</code></pre>
<h2>方法</h2>
<p><strong>append</strong></p>
<pre><code class="language-javascript">formData.append(name, value)
formData.append(name, value[, filename])  // value 为 Blob (包括子类型，如 File)
</code></pre>
<p><strong>set</strong></p>
<pre><code class="language-javascript">formData.set(name, value)
formData.set(name, value[, filename]) // value 为 Blob (包括子类型，如 File)
</code></pre>
<p><strong>区别：</strong> append 新添加的对应的 key 存在也不会覆盖原值，而是新增一个值，如果 key 不存在则新增一项属性值。</p>
<h2>使用</h2>
<pre><code class="language-javascript">const xhr = new XMLHttpRequest()
xhr.onreadystatechange = function() {
  if (xhr.readyState == 4) {
    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) {
      alert(xhr.responseText)
    } else {
      alert(&quot;Request was unsuccessful: &quot; + xhr.status)
    }
  }
}
xhr.open(&quot;post&quot;, &quot;postexample.php&quot;, true)
const form = document.getElementById(&quot;user-info&quot;)
xhr.send(new FormData(form)) 
</code></pre>
<h1>进度事件</h1>
<p>Progress Events 是 W3C 的工作草案，定义了客户端-服务器端通信，这些事件最初只针对 XHR，现在也推广到了其他类似的 API。</p>
<h2>事件</h2>
<ul>
<li><code>loadstart</code>：在接收到响应的第一个字节时触发</li>
<li><code>progress</code>：在接收响应期间反复触发</li>
<li><code>error</code>：在请求出错时触发</li>
<li><code>abort</code>：在调用 <code>abort()</code> 终止连接时触发</li>
<li><code>load</code>：在成功接收完响应时触发</li>
<li><code>loadend</code>：在通信完成时，且在 <code>error</code>、<code>abort</code> 或 <code>load</code> 之后触发</li>
</ul>
<p>每次请求会首先触发 loadstart 事件，之后是一个或多个 progress 事件，接着是 error、abort 或 load 中的一个，最后是 loadend 事件</p>
<p><strong>load</strong></p>
<p><code>load</code> 事件在响应接收完成后立即触发，这样就不用检查 <code>readyState</code> 属性</p>
<p><code>onload</code> 事件处理程序的 <code>event.target</code> 为 XHR 实例，但不是所有浏览器都实现了这个事件的 <code>event</code> 对象</p>
<p><strong>progress</strong></p>
<p><code>onprogress</code> 事件处理程序的 <code>event.target</code> 是 XHR 对象，且包含 3 个额外属性：<code>lengthComputable</code>、<code>position</code> 和 <code>totalSize</code></p>
<ul>
<li><code>lengthComputable</code> 是 一个布尔值，表示进度信息是否可用</li>
<li><code>position</code> 是接收到的字节数</li>
<li><code>totalSize</code> 是响应的 <code>ContentLength</code> 头部定义的总字节数</li>
</ul>
<p>为了保证正确执行，需要在调用 <code>open()</code> 之前添加 <code>onprogress</code> 事件处理程序</p>
<h2>使用</h2>
<pre><code class="language-javascript">const xhr = new XMLHttpRequest()
xhr.onload = () =&gt; {
  if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) {
    console.log(xhr.responseText)
  } else {
    console.log(&quot;Request was unsuccessful: &quot; + xhr.status)
  }
}
xhr.onprogress = event =&gt; {
  const divStatus = document.getElementById(&quot;status&quot;)
  if (event.lengthComputable) {
    divStatus.innerHTML = &quot;Received &quot; + event.position + &quot; of &quot; + event.totalSize + &quot; bytes&quot;
  }
}
xhr.open(&quot;get&quot;, &quot;https://xiefeng.tech&quot;, true)
xhr.send(null)
</code></pre>
<h1>Fetch</h1>
<p>只要服务器返回了响应，Promise 就会 resolved，如果服务器没有响应而导致浏览器超时，这样才会导致 Promise rejected</p>
<p>这个行为是合理的：系统级网络协议已经成功完成消息的一次往返传输，至于真正的“成功”请求，则需要在处理响应时再定义。</p>
<p>违反 CORS、无网络连接、HTTPS 错配及其他浏览器/网络策略问题都会导致 Promise 被拒绝</p>
<h2>中断请求</h2>
<p>Fetch API 支持通过 AbortController/AbortSignal 对中断请求</p>
<p><code>AbortController</code> 接口表示一个控制器对象，可以根据需要中止一个或多个 Web请求：</p>
<ul>
<li><code>signal</code>：返回 <code>AbortSignal</code> 对象实例，可以用来 with/abort 一个Web(网络)请求</li>
<li><code>abort()</code>：中止一个尚未完成的 Web 请求</li>
</ul>
<p><code>AbortSignal </code> 接口表示一个信号对象，通过 <code>AbortController</code> 对象与DOM请求进行通信并在需要时将其中止</p>
<ul>
<li><code>aborted</code>：与之通信的请求是否被终止（true）或未终止（false）</li>
<li><code>onabort</code>：当信号正在与之通信的DOM请求被中止时调用</li>
</ul>
<p>当初始化 fetch 时，将信号和控制器与获取请求相关联，可以允许我们通过调用 <code>abort()</code> 中止请求</p>
<p>当调用 <code>abort()</code> 时，<code>fetch</code> 会 reject 一个名为 <code>AbortError</code> 的 <code>DOMException</code></p>
<pre><code class="language-javascript">const abortController = new AbortController()

document.querySelector(&#x27;#fetch&#x27;).onclick = async () =&gt; {
  const url = &#x27;http://api.xiefeng.tech/api/daily/quote&#x27;
  try {
    // 将信号和控制器与获取请求相关联
    const resp = await fetch(url, { signal: abortController.signal })
    const data = await resp.json()
    console.log(data)
  } catch (error) {
    console.log(&#x27;request has been abort&#x27;, error)
  }
}

document.querySelector(&#x27;#abort&#x27;).onclick = () =&gt; {
  abortController.abort()
}
</code></pre>
<h2>Header</h2>
<p>Headers 对象是所有请求和响应头部的容器，通过 <code>Request.prototype.headers</code> 和 <code>Response.prototype.headers</code> 可以访问请求和响应包含着头部的 Headers 对象。</p>
<p>请求和响应的 Headers 对象的属性都是可以修改的，使用 <code>new Headers()</code> 也可以创建一个新的实例</p>
<p>Headers 类似于 Map，但是在初始化 Headers 对象时，可以使用键/值对形式的对象</p>
<pre><code class="language-javascript">const header = new Headers({&#x27;a&#x27;: &#x27;b&#x27;})
header.get(&#x27;a&#x27;)	// &#x27;b&#x27;
</code></pre>
<p>一个 HTTP 头部字段可以有多个值，Headers 对象通过 <code>append()</code> 方法支持添加多个值</p>
<pre><code class="language-javascript">const header = new Headers({&#x27;a&#x27;: &#x27;b&#x27;})
header.get(&#x27;a&#x27;)	// &#x27;b&#x27;
header.append(&#x27;a&#x27;, &#x27;c&#x27;)
header.get(&#x27;a&#x27;)	// &#x27;b, c&#x27;
</code></pre>
<h2>Request</h2>
<p>通过 <code>Request</code> 构造函数可以创建一个 <code>Request</code> 实例，参数和 <code>fetch</code> 相同</p>
<pre><code class="language-javascript">new Requset(&#x27;&#x27;, {})
</code></pre>
<h3>克隆Request</h3>
<p>Fetch API 提供了两种方式创建 Request 对象的副本：使用 Request 构造函数、使用 <code>clone()</code> 方法</p>
<p>将 Request 实例作为 input 参数传给 Request 构造函数，会得到该请求的一个副本：</p>
<pre><code class="language-javascript">const r1 = new Request(&#x27;https://foo.com&#x27;)
const r2 = new Request(r1)
</code></pre>
<p>这种克隆方式会使得第一个请求的请求体会被标记为“已使用”，并且可以传递第二个参数覆盖原始的值</p>
<pre><code class="language-javascript">r1.bodyUsed	// true
r2.bodyUsed	// false
</code></pre>
<p>使用 <code>clone()</code> 方法会创建一模一样的副本，也不会将任何请求的请求体标记为“已使用”：</p>
<pre><code class="language-javascript">const r1 = new Request(&#x27;https://foo.com&#x27;, { method: &#x27;POST&#x27;, body: &#x27;foobar&#x27; })
const r2 = r1.clone()

console.log(r1.bodyUsed) // false
console.log(r2.bodyUsed) // false
</code></pre>
<p>如果请求对象的请求体已被读取（<code>bodyUsed = true</code>），进行克隆会导致抛出 TypeError</p>
<h3>传入fetch</h3>
<p>fetch 的参数和 Request 的参数是一摸一样的，在调用 <code>fetch</code> 时，可以传入已经创建好的 Request 实例</p>
<pre><code class="language-javascript">const request = new Request(&#x27;https://foo.com&#x27;)
// 向 foo.com 发送 POST 请求
fetch(request, { method: &#x27;POST&#x27; })
</code></pre>
<p><code>fetch</code> 会在内部克隆传入的 Request 对象，通过 fetch 使用 Request 会将请求体标记为已使用</p>
<p><code>fetch</code> 也不能拿请求体已 经用过的 Request 对象来发送请求</p>
<pre><code class="language-javascript">const request = new Request(&#x27;https://foo.com&#x27;, { body: &#x27;foobar&#x27; })
fetch(request)
fetch(request)	// TypeError: Cannot construct a Request with a Request object that has already been used.
</code></pre>
<h2>Response</h2>
<p>Response 对象是获取资源响应的接口，这个接口暴露了响应的相关信息，也暴露了使用响应体的不同方式</p>
<p>可以使用构造函数创建 Response 实例</p>
<pre><code class="language-javascript">const response = new Response(&#x27;body content&#x27;)
</code></pre>
<p>大多数情况下，产生 Response 对象的主要方式是调用 fetch</p>
<p>使用 <code>clone</code> 方法会克隆 Response 实例，不会将任何请求的请求体标记为已使用，如果响应体已经被读取则会报错</p>
<p>通过创建带有原始响应体的 Response 实例，可以执行伪克隆操作，不会导致第一个 Response 实例标记为已读，但会共享 body</p>
<pre><code class="language-javascript">let r1 = new Response(&#x27;foobar&#x27;)
let r2 = new Response(r1.body)
console.log(r1.bodyUsed)    // false
console.log(r2.bodyUsed)    // false
r2.text().then(console.log) // foobar
r1.text().then(console.log) // TypeError: Failed to execute &#x27;text&#x27; on &#x27;Response&#x27;: body stream is locked
</code></pre>
<h2>Body</h2>
<p>Request 和 Response 都使用了 Fetch API 的 Body 混入，以实现两者承担有效载荷的能力，通过 body 即可访问</p>
<p>Body 混入提供了 5 个方法，用于将 ReadableStream 转存到缓冲区的内存里，以及通过 Promise 来产生结果</p>
<ol>
<li><code>body.text</code></li>
<li><code>body.json</code></li>
<li><code>body.formData</code></li>
<li><code>body.arrayBuffer</code></li>
<li><code>body.blob</code></li>
</ol>
<p>Body 混入是构建在 ReadableStream 之上的，所以主体流只能使用一次，再次调用就会抛出错误</p>
<p>在读取流时会给流加锁，无论流是否读完第二次调用都会报错，bodyUsed 表示流是否已<strong>摄受</strong>（读取器是否已经在流上加了锁）</p>
<pre><code class="language-javascript">request.blob(); // 第一次调用给流加锁
request.blob(); // 第二次调用再次加锁会失败
</code></pre>
<p>ReadableStream 暴露了 <code>getReader()</code> 方法，可以用于在数据到达时异步获取数据块，数据流的格式是 Uint8Array</p>
<pre><code class="language-javascript">const reader = response.body.getReader()
while (true) {
  const { value, done } = await reader.read()
  if (done) {
    break
  }
  console.log(value)
}
</code></pre>
<h1>WebSocket</h1>
<p>要创建一个新的 WebSocket，就要实例化一个 WebSocket 对象并传入提供连接的 URL</p>
<p>创建 WebSocket 实例之后浏览器会马上尝试连接，同源策略不会限制 WebSocket：</p>
<pre><code class="language-js">const socket = new WebSocket(&quot;ws://xxxxxxx&quot;)
</code></pre>
<h2>状态</h2>
<p>与 XHR 类似，WebSocket 也有一个 readyState 属性表示当前状态：</p>
<ul>
<li><code>WebSocket.OPENING</code>：正在连接</li>
<li><code>WebSocket.OPEN</code>：已经建立连接</li>
<li><code>WebSocket.CLOSING</code>：正在关闭连接</li>
<li><code>WebSocket.CLOSE</code>：已经关闭连接</li>
</ul>
<p>WebSocket 对象没有 readystatechange 事件，而是有与上述不同状态对应的其他事件</p>
<p>任何时候都可以调用 <code>close()</code> 方法关闭 Web Socket 连接</p>
<pre><code class="language-javascript">socket.close()
</code></pre>
<h2>发送 / 接收数据</h2>
<p>打开 Web Socket 之后，使用 <code>send()</code> 方法传入字符串、ArrayBuffer 或 Blob 即可向服务器发送数据：</p>
<pre><code class="language-js">const stringData = &quot;Hello world!&quot;
const arrayBufferData = Uint8Array.from([&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;])
const blobData = new Blob([&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;])
socket.send(stringData)
socket.send(arrayBufferData.buffer)
socket.send(blobData)
</code></pre>
<p>服务器向客户端发送消息时，WebSocket 对象上会触发 message 事件，可以通过 event.data 属性访问到有效载荷：</p>
<pre><code class="language-javascript">socket.onmessage = (event)=&gt; {
  const data = event.data
  // ......
}
</code></pre>
<p><code>event.data</code> 也可能是 ArrayBuffer 或 Blob，这由 <code>socket.binaryType</code> 属性决定，该属性值为 <code>&quot;blob&quot;</code> 或 <code>&quot;arraybuffer&quot;</code></p>
<h2>事件</h2>
<p>WebSocket 对象在连接生命周期中可能触发的事件：</p>
<ul>
<li>open：在连接成功建立时触发</li>
<li>error：在发生错误时触发，连接无法存续</li>
<li>message：接收到服务器消息时触发</li>
<li>close：在连接关闭时触发</li>
</ul>
<p>WebSocket 对象仅支持 DOM Level 0 风格的事件处理程序来监听这些事件</p><div><a href="/notes/JavaScript/Web%20api">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"AJAX","article":{"title":"AJAX","content":"# XHR\r\n\r\n把 Ajax 推到历史舞台上的关键技术是 XMLHttpRequest(XHR)对象。这个对象最早由微软发明， 然后被其他浏览器所借鉴\r\n\r\n所有现代浏览器都通过 XMLHttpRequest 构造函数原生支持 XHR 对象\r\n\r\n```javascript\r\nconst xhr = new XMLHttpRequest()\r\n```\r\n\r\n## 方法\r\n\r\n1. `xhr.open(method, url, async)`：为发送请求做好准备\r\n2. `xhr.setRequestHeader(key, value)`：为保证请求头部被发送，必须在 `open` 之后、`send` 之前调用\r\n3. `overrideMimeType(mimetype)`：用于重写 XHR **响应**的 MIME 类型，在 `open` 之后、`send` 之前调用\r\n4. `xhr.send(data)`：没有消息体，必须传递 `null`，调用之后就会发送请求\r\n5. `xhr.abort()`：在收到响应之前取消异步请求\r\n6. `xhr.getResponseHeader(key)`：获取响应头部\r\n7. `xhr.getAllResponseHeaders()`：取得所有响应头部，该方法会返回包含所有响应头部的字符串\r\n\r\n```http\r\nDate: Sun, 14 Nov 2004 18:04:03 GMT\r\nServer: Apache/1.3.29 (Unix)\r\nVary: Accept\r\nX-Powered-By: PHP/4.3.8\r\nConnection: close\r\nContent-Type: text/html charset=iso-8859-1\r\n```\r\n\r\n## 属性\r\n\r\n1. `timeout`：设置了 `timeout` 且超时之后，XHR 对象就会触发 `timeout` 事件，调用 `ontimeout` 事件处理程序\r\n2. `withCredentials`：设置跨源请求提供凭据（cookie、HTTP 认证和客户端 SSL 证书）\r\n3. `responseText`：作为响应主体被返回的文本\r\n4. `status`：相应的 HTTP 状态\r\n5. `statusText`：响应的 HTTP 状态描述\r\n\r\n## readyState\r\n\r\nXHR 对象有一个 readyState 属性，表示当前处在请求/响应过程的哪个阶段：\r\n\r\n- `0`：未初始化，尚未调用 `open()`\r\n- `1`：已打开，调用了 `open()`，还没有调用 `send()`\r\n- `2`：已发送，调用了 `send()`，还没有收到响应\r\n\r\n- `3`：接收中，已经收到部分响应数据\r\n\r\n- `4`：完成，已经接收到全部响应数据，可以使用\r\n\r\n为保证跨浏览器兼容，`readystatechange` 事件处理程序应该在调用 `open()` 之前注册\r\n\r\n## 使用\r\n\r\n```javascript\r\nconst xhr = new XMLHttpRequest()\r\n\r\nxhr.addEventListener('readystatechange', () =\u003e {\r\n  if (xhr.readyState === 4) {\r\n    if ((xhr.status \u003e= 200 \u0026\u0026 xhr.status \u003c 300) || xhr.status === 304) {\r\n      console.log(xhr.responseText)\r\n    } else {\r\n      console.log(\"Request was unsuccessful: \" + xhr.status)\r\n    }\r\n  }\r\n})\r\n\r\nxhr.open('get', 'https://www.xiefeng.tech', true)\r\n\r\nxhr.timeout = 1000 // 设置 1 秒超时\r\n\r\nxhr.ontimeout = () =\u003e console.log(\"Request did not return in a second.\")\r\n\r\nxhr.overrideMimeType(\"text/xml\")\r\n\r\nxhr.send(null)\r\n```\r\n\r\n# FormData\r\n\r\nFormData 类型便于创建 `multipart/form-data` 格式的数据，FormData 实例可以直接传给 XHR 对象的 `send()` 方法\r\n\r\n```javascript\r\nconst fd = new FormData()\r\n```\r\n\r\n可以通过直接给 FormData 构造函数传入一个表单元素\r\n\r\n```javascript\r\nconst fd = new FormData(document.forms[0])\r\n```\r\n\r\n## 方法\r\n\r\n**append**\r\n\r\n```javascript\r\nformData.append(name, value)\r\nformData.append(name, value[, filename])  // value 为 Blob (包括子类型，如 File)\r\n```\r\n\r\n**set**\r\n\r\n```javascript\r\nformData.set(name, value)\r\nformData.set(name, value[, filename]) // value 为 Blob (包括子类型，如 File)\r\n```\r\n\r\n**区别：** append 新添加的对应的 key 存在也不会覆盖原值，而是新增一个值，如果 key 不存在则新增一项属性值。\r\n\r\n## 使用\r\n\r\n```javascript\r\nconst xhr = new XMLHttpRequest()\r\nxhr.onreadystatechange = function() {\r\n  if (xhr.readyState == 4) {\r\n    if ((xhr.status \u003e= 200 \u0026\u0026 xhr.status \u003c 300) || xhr.status == 304) {\r\n      alert(xhr.responseText)\r\n    } else {\r\n      alert(\"Request was unsuccessful: \" + xhr.status)\r\n    }\r\n  }\r\n}\r\nxhr.open(\"post\", \"postexample.php\", true)\r\nconst form = document.getElementById(\"user-info\")\r\nxhr.send(new FormData(form)) \r\n```\r\n\r\n# 进度事件\r\n\r\nProgress Events 是 W3C 的工作草案，定义了客户端-服务器端通信，这些事件最初只针对 XHR，现在也推广到了其他类似的 API。\r\n\r\n## 事件\r\n\r\n- `loadstart`：在接收到响应的第一个字节时触发\r\n- `progress`：在接收响应期间反复触发\r\n- `error`：在请求出错时触发\r\n- `abort`：在调用 `abort()` 终止连接时触发\r\n- `load`：在成功接收完响应时触发\r\n- `loadend`：在通信完成时，且在 `error`、`abort` 或 `load` 之后触发\r\n\r\n每次请求会首先触发 loadstart 事件，之后是一个或多个 progress 事件，接着是 error、abort 或 load 中的一个，最后是 loadend 事件\r\n\r\n**load**\r\n\r\n`load` 事件在响应接收完成后立即触发，这样就不用检查 `readyState` 属性\r\n\r\n`onload` 事件处理程序的 `event.target` 为 XHR 实例，但不是所有浏览器都实现了这个事件的 `event` 对象\r\n\r\n**progress**\r\n\r\n`onprogress` 事件处理程序的 `event.target` 是 XHR 对象，且包含 3 个额外属性：`lengthComputable`、`position` 和 `totalSize`\r\n\r\n- `lengthComputable` 是 一个布尔值，表示进度信息是否可用\r\n- `position` 是接收到的字节数\r\n- `totalSize` 是响应的 `ContentLength` 头部定义的总字节数\r\n\r\n为了保证正确执行，需要在调用 `open()` 之前添加 `onprogress` 事件处理程序\r\n\r\n## 使用\r\n\r\n```javascript\r\nconst xhr = new XMLHttpRequest()\r\nxhr.onload = () =\u003e {\r\n  if ((xhr.status \u003e= 200 \u0026\u0026 xhr.status \u003c 300) || xhr.status === 304) {\r\n    console.log(xhr.responseText)\r\n  } else {\r\n    console.log(\"Request was unsuccessful: \" + xhr.status)\r\n  }\r\n}\r\nxhr.onprogress = event =\u003e {\r\n  const divStatus = document.getElementById(\"status\")\r\n  if (event.lengthComputable) {\r\n    divStatus.innerHTML = \"Received \" + event.position + \" of \" + event.totalSize + \" bytes\"\r\n  }\r\n}\r\nxhr.open(\"get\", \"https://xiefeng.tech\", true)\r\nxhr.send(null)\r\n```\r\n\r\n# Fetch\r\n\r\n只要服务器返回了响应，Promise 就会 resolved，如果服务器没有响应而导致浏览器超时，这样才会导致 Promise rejected\r\n\r\n这个行为是合理的：系统级网络协议已经成功完成消息的一次往返传输，至于真正的“成功”请求，则需要在处理响应时再定义。\r\n\r\n违反 CORS、无网络连接、HTTPS 错配及其他浏览器/网络策略问题都会导致 Promise 被拒绝\r\n\r\n## 中断请求\r\n\r\nFetch API 支持通过 AbortController/AbortSignal 对中断请求\r\n\r\n`AbortController` 接口表示一个控制器对象，可以根据需要中止一个或多个 Web请求：\r\n\r\n- `signal`：返回 `AbortSignal` 对象实例，可以用来 with/abort 一个Web(网络)请求\r\n- `abort()`：中止一个尚未完成的 Web 请求\r\n\r\n`AbortSignal ` 接口表示一个信号对象，通过 `AbortController` 对象与DOM请求进行通信并在需要时将其中止\r\n\r\n- `aborted`：与之通信的请求是否被终止（true）或未终止（false）\r\n- `onabort`：当信号正在与之通信的DOM请求被中止时调用\r\n\r\n当初始化 fetch 时，将信号和控制器与获取请求相关联，可以允许我们通过调用 `abort()` 中止请求\r\n\r\n当调用 `abort()` 时，`fetch` 会 reject 一个名为 `AbortError` 的 `DOMException`\r\n\r\n```javascript\r\nconst abortController = new AbortController()\r\n\r\ndocument.querySelector('#fetch').onclick = async () =\u003e {\r\n  const url = 'http://api.xiefeng.tech/api/daily/quote'\r\n  try {\r\n    // 将信号和控制器与获取请求相关联\r\n    const resp = await fetch(url, { signal: abortController.signal })\r\n    const data = await resp.json()\r\n    console.log(data)\r\n  } catch (error) {\r\n    console.log('request has been abort', error)\r\n  }\r\n}\r\n\r\ndocument.querySelector('#abort').onclick = () =\u003e {\r\n  abortController.abort()\r\n}\r\n```\r\n\r\n## Header\r\n\r\nHeaders 对象是所有请求和响应头部的容器，通过 `Request.prototype.headers` 和 `Response.prototype.headers` 可以访问请求和响应包含着头部的 Headers 对象。\r\n\r\n请求和响应的 Headers 对象的属性都是可以修改的，使用 `new Headers()` 也可以创建一个新的实例\r\n\r\nHeaders 类似于 Map，但是在初始化 Headers 对象时，可以使用键/值对形式的对象\r\n\r\n```javascript\r\nconst header = new Headers({'a': 'b'})\r\nheader.get('a')\t// 'b'\r\n```\r\n\r\n一个 HTTP 头部字段可以有多个值，Headers 对象通过 `append()` 方法支持添加多个值\r\n\r\n```javascript\r\nconst header = new Headers({'a': 'b'})\r\nheader.get('a')\t// 'b'\r\nheader.append('a', 'c')\r\nheader.get('a')\t// 'b, c'\r\n```\r\n\r\n## Request\r\n\r\n通过 `Request` 构造函数可以创建一个 `Request` 实例，参数和 `fetch` 相同\r\n\r\n```javascript\r\nnew Requset('', {})\r\n```\r\n\r\n### 克隆Request\r\n\r\nFetch API 提供了两种方式创建 Request 对象的副本：使用 Request 构造函数、使用 `clone()` 方法\r\n\r\n将 Request 实例作为 input 参数传给 Request 构造函数，会得到该请求的一个副本：\r\n\r\n```javascript\r\nconst r1 = new Request('https://foo.com')\r\nconst r2 = new Request(r1)\r\n```\r\n\r\n这种克隆方式会使得第一个请求的请求体会被标记为“已使用”，并且可以传递第二个参数覆盖原始的值\r\n\r\n```javascript\r\nr1.bodyUsed\t// true\r\nr2.bodyUsed\t// false\r\n```\r\n\r\n使用 `clone()` 方法会创建一模一样的副本，也不会将任何请求的请求体标记为“已使用”：\r\n\r\n```javascript\r\nconst r1 = new Request('https://foo.com', { method: 'POST', body: 'foobar' })\r\nconst r2 = r1.clone()\r\n\r\nconsole.log(r1.bodyUsed) // false\r\nconsole.log(r2.bodyUsed) // false\r\n```\r\n\r\n如果请求对象的请求体已被读取（`bodyUsed = true`），进行克隆会导致抛出 TypeError\r\n\r\n### 传入fetch\r\n\r\nfetch 的参数和 Request 的参数是一摸一样的，在调用 `fetch` 时，可以传入已经创建好的 Request 实例\r\n\r\n```javascript\r\nconst request = new Request('https://foo.com')\r\n// 向 foo.com 发送 POST 请求\r\nfetch(request, { method: 'POST' })\r\n```\r\n\r\n`fetch` 会在内部克隆传入的 Request 对象，通过 fetch 使用 Request 会将请求体标记为已使用\r\n\r\n`fetch` 也不能拿请求体已 经用过的 Request 对象来发送请求\r\n\r\n```javascript\r\nconst request = new Request('https://foo.com', { body: 'foobar' })\r\nfetch(request)\r\nfetch(request)\t// TypeError: Cannot construct a Request with a Request object that has already been used.\r\n```\r\n\r\n## Response\r\n\r\nResponse 对象是获取资源响应的接口，这个接口暴露了响应的相关信息，也暴露了使用响应体的不同方式\r\n\r\n可以使用构造函数创建 Response 实例\r\n\r\n```javascript\r\nconst response = new Response('body content')\r\n```\r\n\r\n大多数情况下，产生 Response 对象的主要方式是调用 fetch\r\n\r\n使用 `clone` 方法会克隆 Response 实例，不会将任何请求的请求体标记为已使用，如果响应体已经被读取则会报错\r\n\r\n通过创建带有原始响应体的 Response 实例，可以执行伪克隆操作，不会导致第一个 Response 实例标记为已读，但会共享 body\r\n\r\n```javascript\r\nlet r1 = new Response('foobar')\r\nlet r2 = new Response(r1.body)\r\nconsole.log(r1.bodyUsed)    // false\r\nconsole.log(r2.bodyUsed)    // false\r\nr2.text().then(console.log) // foobar\r\nr1.text().then(console.log) // TypeError: Failed to execute 'text' on 'Response': body stream is locked\r\n```\r\n\r\n## Body\r\n\r\nRequest 和 Response 都使用了 Fetch API 的 Body 混入，以实现两者承担有效载荷的能力，通过 body 即可访问\r\n\r\nBody 混入提供了 5 个方法，用于将 ReadableStream 转存到缓冲区的内存里，以及通过 Promise 来产生结果\r\n\r\n1. `body.text`\r\n2. `body.json`\r\n3. `body.formData`\r\n4. `body.arrayBuffer`\r\n5. `body.blob`\r\n\r\nBody 混入是构建在 ReadableStream 之上的，所以主体流只能使用一次，再次调用就会抛出错误\r\n\r\n在读取流时会给流加锁，无论流是否读完第二次调用都会报错，bodyUsed 表示流是否已**摄受**（读取器是否已经在流上加了锁）\r\n\r\n```javascript\r\nrequest.blob(); // 第一次调用给流加锁\r\nrequest.blob(); // 第二次调用再次加锁会失败\r\n```\r\n\r\nReadableStream 暴露了 `getReader()` 方法，可以用于在数据到达时异步获取数据块，数据流的格式是 Uint8Array\r\n\r\n```javascript\r\nconst reader = response.body.getReader()\r\nwhile (true) {\r\n  const { value, done } = await reader.read()\r\n  if (done) {\r\n    break\r\n  }\r\n  console.log(value)\r\n}\r\n```\r\n\r\n# WebSocket\r\n\r\n要创建一个新的 WebSocket，就要实例化一个 WebSocket 对象并传入提供连接的 URL\r\n\r\n创建 WebSocket 实例之后浏览器会马上尝试连接，同源策略不会限制 WebSocket：\r\n\r\n```js\r\nconst socket = new WebSocket(\"ws://xxxxxxx\")\r\n```\r\n\r\n## 状态\r\n\r\n与 XHR 类似，WebSocket 也有一个 readyState 属性表示当前状态：\r\n\r\n- `WebSocket.OPENING`：正在连接\r\n- `WebSocket.OPEN`：已经建立连接\r\n- `WebSocket.CLOSING`：正在关闭连接\r\n- `WebSocket.CLOSE`：已经关闭连接\r\n\r\nWebSocket 对象没有 readystatechange 事件，而是有与上述不同状态对应的其他事件\r\n\r\n任何时候都可以调用 `close()` 方法关闭 Web Socket 连接\r\n\r\n```javascript\r\nsocket.close()\r\n```\r\n\r\n## 发送 / 接收数据\r\n\r\n打开 Web Socket 之后，使用 `send()` 方法传入字符串、ArrayBuffer 或 Blob 即可向服务器发送数据：\r\n\r\n```js\r\nconst stringData = \"Hello world!\"\r\nconst arrayBufferData = Uint8Array.from(['f', 'o', 'o'])\r\nconst blobData = new Blob(['f', 'o', 'o'])\r\nsocket.send(stringData)\r\nsocket.send(arrayBufferData.buffer)\r\nsocket.send(blobData)\r\n```\r\n\r\n服务器向客户端发送消息时，WebSocket 对象上会触发 message 事件，可以通过 event.data 属性访问到有效载荷：\r\n\r\n```javascript\r\nsocket.onmessage = (event)=\u003e {\r\n  const data = event.data\r\n  // ......\r\n}\r\n```\r\n\r\n`event.data` 也可能是 ArrayBuffer 或 Blob，这由 `socket.binaryType` 属性决定，该属性值为 `\"blob\"` 或 `\"arraybuffer\"`\r\n\r\n## 事件\r\n\r\nWebSocket 对象在连接生命周期中可能触发的事件：\r\n\r\n- open：在连接成功建立时触发\r\n- error：在发生错误时触发，连接无法存续\r\n- message：接收到服务器消息时触发\r\n- close：在连接关闭时触发\r\n\r\nWebSocket 对象仅支持 DOM Level 0 风格的事件处理程序来监听这些事件","meta":{"size":14256,"birthTime":1663496641396.8425,"updateTime":1663496641397.074}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["JavaScript","Web api","AJAX"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
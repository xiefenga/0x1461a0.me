<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>File API | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#Blob" data-target-id="h1-Blob-0">Blob</a><ul><li><a href="#构造函数" data-target-id="h2-构造函数-0">构造函数</a></li><li><a href="#实例对象" data-target-id="h2-实例对象-1">实例对象</a></li></ul></li><li><a href="#File" data-target-id="h1-File-1">File</a><ul><li><a href="#文件信息" data-target-id="h2-文件信息-2">文件信息</a></li><li><a href="#读取文件" data-target-id="h2-读取文件-3">读取文件</a></li></ul></li><li><a href="#FileReader" data-target-id="h1-FileReader-2">FileReader</a><ul><li><a href="#读取方法" data-target-id="h2-读取方法-4">读取方法</a></li><li><a href="#事件类型" data-target-id="h2-事件类型-5">事件类型</a></li><li><a href="#读取结果" data-target-id="h2-读取结果-6">读取结果</a></li></ul></li><li><a href="#FileReaderSync" data-target-id="h1-FileReaderSync-3">FileReaderSync</a><ul><li><a href="#使用限制" data-target-id="h2-使用限制-7">使用限制</a></li><li><a href="#异常" data-target-id="h2-异常-8">异常</a></li></ul></li><li><a href="#ObjectURL" data-target-id="h1-ObjectURL-4">ObjectURL</a><ul><li><a href="#创建URL" data-target-id="h2-创建URL-9">创建URL</a></li><li><a href="#释放URL" data-target-id="h2-释放URL-10">释放URL</a></li></ul></li><li><a href="#读取文件夹" data-target-id="h1-读取文件夹-5">读取文件夹</a></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">File API</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h1>Blob</h1>
<p>Blob 表示一个不可变、原始数据的类文件对象，是 JavaScript 对不可修改二进制数据的封装类型。</p>
<p>包含字符串的数组、ArrayBuffers、ArrayBufferViews，甚至其他 Blob 都可以用来创建 blob 对象</p>
<h2>构造函数</h2>
<pre><code class="language-javascript">new Blob(blobParts[, options])
</code></pre>
<ul>
<li><code>blobParts</code>：<code>ArrayBuffer</code>, <code>ArrayBufferView</code>, <code>Blob</code>, <code>string</code> 等构成的数组，这些都是 blob 的内容</li>
<li><code>options</code>：<!-- -->
<ul>
<li><code>type</code>：默认值为 <code>&quot;&quot;</code>，内容的MIME类型</li>
<li><code>endings</code>：用于指定包含行结束符 <code>\n</code> 的字符串如何被写入，默认值为 <code>&quot;transparent&quot;</code>
<ul>
<li><code>native</code>：行结束符会被更改为适合宿主操作系统文件系统的换行符</li>
<li><code>transparent</code>：保持blob中保存的结束符不变</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>实例对象</h2>
<p>Blob 对象具有两个只读属性：</p>
<ul>
<li><code>size</code>：数据大小</li>
<li><code>type</code>：数据的 MIME 类型</li>
</ul>
<p>Blob 的实例方法：</p>
<ul>
<li><code>slice([start[, end[, contentType]]])</code>：返回一个新的 <code>Blob</code> 对象，包含了源 <code>Blob</code> 对象中指定范围内的数据</li>
<li><code>stream()</code>：返回一个能读取blob内容的 <code>ReadableStream</code></li>
<li><code>text()</code>：返回一个promise且包含blob所有内容的UTF-8格式的字符串</li>
<li><code>arrayBuffer()</code>：返回一个promise且包含blob所有内容的二进制格式的 <code>ArrayBuffer</code></li>
</ul>
<pre><code class="language-javascript">const blob = new Blob([&#x27;aaa&#x27;, &#x27;bbb&#x27;, &#x27;ccc&#x27;, &#x27;ddd&#x27;])

blob.text().then(res =&gt; console.log(res)) // aaabbbcccddd
</code></pre>
<h1>File</h1>
<p>File 类型提供了文件的信息，允许 JavaScript 可以访问其内容。File 继承自 Blob，在此基础上扩展支持用户系统上的文件。</p>
<h2>文件信息</h2>
<p>每个 File 对象都有一些只读属性，表示文件的信息：</p>
<ul>
<li><code>name</code>：本地系统中的文件名</li>
<li><code>size</code>：以字节计的文件大小</li>
<li><code>type</code>：文件 MIME 类型</li>
<li><code>lastModified</code>：文件最后修改时间的时间戳</li>
<li><code>lastModifiedDate</code>：文件最后修改时间 Date 类型</li>
</ul>
<p>通过构造函数也可以创建一个 File 实例：</p>
<pre><code class="language-javascript">new File(bits, name[, options])
</code></pre>
<ul>
<li><code>bits</code>：一个包含 <code>ArrayBuffer</code>，<code>ArrayBufferView</code>，<code>Blob</code>，或者 <code>string</code> 的数组，这是 UTF-8 编码的文件内容</li>
<li><code>name</code>：表示文件名称，或者文件路径</li>
<li><code>options</code> ：选项对象，包含文件的可选属性<!-- -->
<ul>
<li><code>type</code>：表示将要放到文件中的内容的 MIME 类型，默认值为 <code>&quot;&quot;</code> 。</li>
<li><code>lastModified</code>：表示文件最后修改时间的 Unix 时间戳（毫秒），默认值为 <code>Date.now()</code></li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">const file = new File([&quot;foo&quot;], &quot;foo.txt&quot;, { type: &quot;text/plain&quot; })
</code></pre>
<h2>读取文件</h2>
<p>File API 仍然以表单中的文件输入字段为基础，通过表单控件所选择的文件保存在 <code>input.files</code> 属性中，该属性是一个 FileList 类型。</p>
<p>FileList 是一个类数组，每一项都是一个 File 类型，FileList 类型也实现了 Iterator 接口。</p>
<pre><code class="language-javascript">const filesList = document.getElementById(&quot;files-list&quot;)
filesList.addEventListener(&quot;change&quot;, (event) =&gt; {
  const files = event.target.files
  for(const file of files) {
    console.log(`${file.name}: (${file.type}, ${file.size} bytes)`)
  }
})
</code></pre>
<h1>FileReader</h1>
<p>FileReader 类型表示一种异步文件读取机制，使用 File 或 Blob 对象指定要读取的文件或数据。</p>
<h2>读取方法</h2>
<p>FileReader 类型提供了几个读取文件数据的方法：</p>
<ul>
<li><code>readAsText(blob[, encoding])</code>：读取文件为字符串保存在 <code>result</code> 属性中，第二个参数表示编码，默认 <code>&#x27;utf-8&#x27;</code></li>
<li><code>readAsDataURL(blob)</code>：读取文件并将内容的数据编码为 base64 保存在 <code>result</code> 属性中</li>
<li><code>readAsBinaryString(blob)</code>：读取文件并将每个字符的二进制数据保存在 <code>result</code> 属性中</li>
<li><code>readAsArrayBuffer(blob)</code>：读取文件并将文件内容以 ArrayBuffer 形式保存在 <code>result</code> 属性中</li>
<li><code>abort()</code>：中止读取操作，<code>readyState</code> 属性变为 <code>DONE</code></li>
</ul>
<h2>事件类型</h2>
<p>FileReader 类型的事件：</p>
<ul>
<li><code>abort</code>：该事件在读取操作被中断时触发，通过 <code>abort</code> 方法触发</li>
<li><code>error</code>：该事件在读取操作发生错误时触发</li>
<li><code>load</code>：该事件在读取操作完成时触发</li>
<li><code>loadstart</code>：该事件在读取操作开始时触发</li>
<li><code>loadend</code>：该事件在读取操作结束时（要么成功，要么失败）触发</li>
<li><code>progress</code>：progress 事件每 50 毫秒就会触发一次，在 progress 事件中可以读取 <code>result</code> 属性，即使其中尚未包含全部数据</li>
</ul>
<p>因为 FileReader 继承自 <code>EventTarget</code>，所以可以通过 <code>addEventListener</code> 方法注册</p>
<h2>读取结果</h2>
<p>FileReader 实例具有一些只读属性，用于表示读取结果：</p>
<ul>
<li><code>result</code>：文件的内容。该属性仅在读取操作完成后才有效，数据的格式取决于使用哪个方法来启动读取操作</li>
<li><code>readyState</code>：表示 FileReader 状态的常量<!-- -->
<ul>
<li><code>FileReader.EMPTY</code>：还没有加载任何数据</li>
<li><code>FileReader.LOADING</code>：数据正在被加载</li>
<li><code>FileReader.DONE</code>：已完成全部的读取请求</li>
</ul>
</li>
<li><code>error</code>：在读取文件发生错误时该属性会包含错误信息<!-- -->
<ul>
<li>只包含一个属性：code</li>
<li>code 取值：1（未找到文件）、2（安全错误）、3（读取被中断）、4（文件不可读）、 5（编码错误）</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">const input = document.querySelector(&#x27;input&#x27;)
input.onchange = e =&gt; {
  const file = e.target.files[0]
  read.readAsDataURL(file)
}
const read = new FileReader()
read.onload = e =&gt; console.log(read.result)
read.onprogress = e =&gt; console.log(e.loaded / e.total)
</code></pre>
<p><img src="http://oss.xiefeng.tech/img/20210326094011.png" alt=""/></p>
<h1>FileReaderSync</h1>
<p>FileReaderSync 接口允许以同步的方式读取 File 或 Blob 对象中的内容。</p>
<h2>使用限制</h2>
<p>FileReaderSync 只在工作线程中可用，因为在主线程里进行同步I/O操作可能会阻塞用户界面。</p>
<ul>
<li><code>readAsArrayBuffer(blob)</code></li>
<li><code>readAsText(blob[, encoding])</code></li>
<li><code>readAsDataUrl(blob)</code></li>
<li><code>readAsBinaryString(blob)</code></li>
</ul>
<h2>异常</h2>
<p>读取的结果在返回值中，读取可能会引发下述异常：</p>
<ul>
<li><code>NotFoundError</code></li>
<li><code>SecurityError</code></li>
<li><code>NotReadableError</code></li>
<li><code>EncodingError</code></li>
</ul>
<pre><code class="language-javascript">// worker.js 
self.omessage = (messageEvent) =&gt; {
    const syncReader = new FileReaderSync() 
    // 读取文件时阻塞工作线程 
    const result = syncReader.readAsDataUrl(messageEvent.data) // PDF 文件的示例响应
    console.log(result) // data:application/pdfbase64,JVBERi0xLjQK... 
    self.postMessage(result)	// 把 URL 发回去 
}
</code></pre>
<h1>ObjectURL</h1>
<p>对象 URL 有时候也称作 Blob URL，是指引用存储在 File 或 Blob 中数据的 URL。</p>
<p>对象 URL 的优点是不用把文件内容读取到 JavaScript 也可以使用文件，只要在适当位置提供对象 URL 即可</p>
<h2>创建URL</h2>
<p>通过 <code>window.URL.createObjectURL(blob)</code> 可以创建 ObjectURL，返回的值是一个指向内存中地址的字符串，并且这个字符串可以在 DOM 中直接使用。</p>
<pre><code class="language-javascript">const filesList = document.getElementById(&quot;files-list&quot;)
filesList.addEventListener(&quot;change&quot;, (event) =&gt; {
  const file = event.target.files[0]
  const url = window.URL.createObjectURL(files[0])
  img.src = url
})
</code></pre>
<h2>释放URL</h2>
<p>使用完数据之后，最好能释放与之关联的内存，使用 <code>window.URL.revokeObjectURL(URL)</code> 可以释放对象 URL</p>
<p>页面卸载时所有对象 URL 占用的内存都会被释放，最好在不使用时就立即释放内存，以便尽可能保持页面占用最少资源。</p>
<p>使用对象 URL 实现文件导出：</p>
<pre><code class="language-javascript">const createDownloadURL = data =&gt; window.URL.createObjectURL(new Blob([data], { type: &#x27;text/plain&#x27; }))

const exportFile = (data, fileName, ext) =&gt; {
    const download = document.createElement(&#x27;a&#x27;)
    download.display = &#x27;none&#x27;
    const url = createDownloadURL(data)
    download.href = url
    download.download = `${fileName}.${ext}`
    document.body.appendChild(download)
    download.click()
    document.body.removeChild(download)
    window.URL.revokeObjectURL(url)
}
</code></pre>
<h1>读取文件夹</h1>
<p>通过给 input 标签添加 <code>webkitdirectory</code> 属性可以上传文件夹中的所有文件，即使存在子文件夹。</p>
<p>通过 <code>webkitRelativePath</code> 属性即可判断文件所属文件夹</p>
<pre><code class="language-html"> &lt;input type=&quot;file&quot; webkitdirectory directory&gt;
</code></pre>
<pre><code class="language-javascript">const input = document.querySelector(&#x27;#file&#x27;)

input.addEventListener(&#x27;change&#x27;, e =&gt; {
  for (const file of e.target.files) {
    console.log(file)
  }
})
</code></pre>
<p><img src="https://oss.xiefeng.tech/images/20210911111828.png" alt=""/></p><div><a href="/notes/JavaScript/Web%20api">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"File API","article":{"title":"File API","content":"# Blob\n\nBlob 表示一个不可变、原始数据的类文件对象，是 JavaScript 对不可修改二进制数据的封装类型。\n\n包含字符串的数组、ArrayBuffers、ArrayBufferViews，甚至其他 Blob 都可以用来创建 blob 对象\n\n## 构造函数\n\n```javascript\nnew Blob(blobParts[, options])\n```\n\n- `blobParts`：`ArrayBuffer`, `ArrayBufferView`, `Blob`, `string` 等构成的数组，这些都是 blob 的内容\n- `options`：\n\t- `type`：默认值为 `\"\"`，内容的MIME类型\n\t- `endings`：用于指定包含行结束符 `\\n` 的字符串如何被写入，默认值为 `\"transparent\"`\n\t\t- `native`：行结束符会被更改为适合宿主操作系统文件系统的换行符\n\t\t- `transparent`：保持blob中保存的结束符不变\n\n## 实例对象\n\nBlob 对象具有两个只读属性：\n\n- `size`：数据大小\n- `type`：数据的 MIME 类型\n\nBlob 的实例方法：\n\n- `slice([start[, end[, contentType]]])`：返回一个新的 `Blob` 对象，包含了源 `Blob` 对象中指定范围内的数据\n- `stream()`：返回一个能读取blob内容的 `ReadableStream`\n- `text()`：返回一个promise且包含blob所有内容的UTF-8格式的字符串\n- `arrayBuffer()`：返回一个promise且包含blob所有内容的二进制格式的 `ArrayBuffer` \n\n```javascript\nconst blob = new Blob(['aaa', 'bbb', 'ccc', 'ddd'])\n\nblob.text().then(res =\u003e console.log(res)) // aaabbbcccddd\n```\n\n# File\n\nFile 类型提供了文件的信息，允许 JavaScript 可以访问其内容。File 继承自 Blob，在此基础上扩展支持用户系统上的文件。\n\n## 文件信息\n\n每个 File 对象都有一些只读属性，表示文件的信息：\n\n- `name`：本地系统中的文件名\n- `size`：以字节计的文件大小\n- `type`：文件 MIME 类型\n- `lastModified`：文件最后修改时间的时间戳\n- `lastModifiedDate`：文件最后修改时间 Date 类型\n\n通过构造函数也可以创建一个 File 实例：\n\n```javascript\nnew File(bits, name[, options])\n```\n\n- `bits`：一个包含 `ArrayBuffer`，`ArrayBufferView`，`Blob`，或者 `string` 的数组，这是 UTF-8 编码的文件内容\n- `name`：表示文件名称，或者文件路径\n- `options` ：选项对象，包含文件的可选属性\n\t- `type`：表示将要放到文件中的内容的 MIME 类型，默认值为 `\"\"` 。\n\t- `lastModified`：表示文件最后修改时间的 Unix 时间戳（毫秒），默认值为 `Date.now()`\n\n```javascript\nconst file = new File([\"foo\"], \"foo.txt\", { type: \"text/plain\" })\n```\n\n## 读取文件\n\nFile API 仍然以表单中的文件输入字段为基础，通过表单控件所选择的文件保存在 `input.files` 属性中，该属性是一个 FileList 类型。\n\nFileList 是一个类数组，每一项都是一个 File 类型，FileList 类型也实现了 Iterator 接口。\n\n```javascript\nconst filesList = document.getElementById(\"files-list\")\nfilesList.addEventListener(\"change\", (event) =\u003e {\n  const files = event.target.files\n  for(const file of files) {\n    console.log(`${file.name}: (${file.type}, ${file.size} bytes)`)\n  }\n})\n```\n\n# FileReader\n\nFileReader 类型表示一种异步文件读取机制，使用 File 或 Blob 对象指定要读取的文件或数据。\n\n## 读取方法\n\nFileReader 类型提供了几个读取文件数据的方法：\n\n- `readAsText(blob[, encoding])`：读取文件为字符串保存在 `result` 属性中，第二个参数表示编码，默认 `'utf-8'`\n- `readAsDataURL(blob)`：读取文件并将内容的数据编码为 base64 保存在 `result` 属性中\n- `readAsBinaryString(blob)`：读取文件并将每个字符的二进制数据保存在 `result` 属性中\n- `readAsArrayBuffer(blob)`：读取文件并将文件内容以 ArrayBuffer 形式保存在 `result` 属性中\n- `abort()`：中止读取操作，`readyState` 属性变为 `DONE`\n\n## 事件类型\n\nFileReader 类型的事件：\n\n- `abort`：该事件在读取操作被中断时触发，通过 `abort` 方法触发\n- `error`：该事件在读取操作发生错误时触发\n- `load`：该事件在读取操作完成时触发\n- `loadstart`：该事件在读取操作开始时触发\n- `loadend`：该事件在读取操作结束时（要么成功，要么失败）触发\n- `progress`：progress 事件每 50 毫秒就会触发一次，在 progress 事件中可以读取 `result` 属性，即使其中尚未包含全部数据\n\n因为 FileReader 继承自 `EventTarget`，所以可以通过 `addEventListener` 方法注册\n\n## 读取结果\n\nFileReader 实例具有一些只读属性，用于表示读取结果：\n\n- `result`：文件的内容。该属性仅在读取操作完成后才有效，数据的格式取决于使用哪个方法来启动读取操作\n- `readyState`：表示 FileReader 状态的常量\n\t- `FileReader.EMPTY`：还没有加载任何数据\n\t- `FileReader.LOADING`：数据正在被加载\n\t- `FileReader.DONE`：已完成全部的读取请求\n- `error`：在读取文件发生错误时该属性会包含错误信息\n  - 只包含一个属性：code\n  - code 取值：1（未找到文件）、2（安全错误）、3（读取被中断）、4（文件不可读）、 5（编码错误）\n\n```javascript\nconst input = document.querySelector('input')\ninput.onchange = e =\u003e {\n  const file = e.target.files[0]\n  read.readAsDataURL(file)\n}\nconst read = new FileReader()\nread.onload = e =\u003e console.log(read.result)\nread.onprogress = e =\u003e console.log(e.loaded / e.total)\n```\n\n![](http://oss.xiefeng.tech/img/20210326094011.png)\n\n# FileReaderSync\n\nFileReaderSync 接口允许以同步的方式读取 File 或 Blob 对象中的内容。\n\n## 使用限制\n\nFileReaderSync 只在工作线程中可用，因为在主线程里进行同步I/O操作可能会阻塞用户界面。\n\n- `readAsArrayBuffer(blob)`\n- `readAsText(blob[, encoding])`\n- `readAsDataUrl(blob)`\n- `readAsBinaryString(blob)`\n\n## 异常\n\n读取的结果在返回值中，读取可能会引发下述异常：\n\n- `NotFoundError`\n- `SecurityError`\n- `NotReadableError`\n- `EncodingError`\n\n```javascript\n// worker.js \nself.omessage = (messageEvent) =\u003e {\n    const syncReader = new FileReaderSync() \n    // 读取文件时阻塞工作线程 \n    const result = syncReader.readAsDataUrl(messageEvent.data) // PDF 文件的示例响应\n    console.log(result) // data:application/pdfbase64,JVBERi0xLjQK... \n    self.postMessage(result)\t// 把 URL 发回去 \n}\n```\n\n# ObjectURL\n\n对象 URL 有时候也称作 Blob URL，是指引用存储在 File 或 Blob 中数据的 URL。\n\n对象 URL 的优点是不用把文件内容读取到 JavaScript 也可以使用文件，只要在适当位置提供对象 URL 即可\n\n## 创建URL\n\n通过 `window.URL.createObjectURL(blob)` 可以创建 ObjectURL，返回的值是一个指向内存中地址的字符串，并且这个字符串可以在 DOM 中直接使用。\n\n```javascript\nconst filesList = document.getElementById(\"files-list\")\nfilesList.addEventListener(\"change\", (event) =\u003e {\n  const file = event.target.files[0]\n  const url = window.URL.createObjectURL(files[0])\n  img.src = url\n})\n```\n\n## 释放URL\n\n使用完数据之后，最好能释放与之关联的内存，使用 `window.URL.revokeObjectURL(URL)` 可以释放对象 URL\n\n页面卸载时所有对象 URL 占用的内存都会被释放，最好在不使用时就立即释放内存，以便尽可能保持页面占用最少资源。\n\n使用对象 URL 实现文件导出：\n\n```javascript\nconst createDownloadURL = data =\u003e window.URL.createObjectURL(new Blob([data], { type: 'text/plain' }))\n\nconst exportFile = (data, fileName, ext) =\u003e {\n    const download = document.createElement('a')\n    download.display = 'none'\n    const url = createDownloadURL(data)\n    download.href = url\n    download.download = `${fileName}.${ext}`\n    document.body.appendChild(download)\n    download.click()\n    document.body.removeChild(download)\n    window.URL.revokeObjectURL(url)\n}\n```\n\n# 读取文件夹\n\n通过给 input 标签添加 `webkitdirectory` 属性可以上传文件夹中的所有文件，即使存在子文件夹。\n\n通过 `webkitRelativePath` 属性即可判断文件所属文件夹\n\n```html\n \u003cinput type=\"file\" webkitdirectory directory\u003e\n```\n\n```javascript\nconst input = document.querySelector('#file')\n\ninput.addEventListener('change', e =\u003e {\n  for (const file of e.target.files) {\n    console.log(file)\n  }\n})\n```\n\n![](https://oss.xiefeng.tech/images/20210911111828.png)\n\n","meta":{"size":8386,"birthTime":1663496641398.0503,"updateTime":1663496641398.4204}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["JavaScript","Web api","File API"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>IndexedDB | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#打开数据库" data-target-id="h1-打开数据库-0">打开数据库</a></li><li><a href="#对象仓库" data-target-id="h1-对象仓库-1">对象仓库</a><ul><li><a href="#创建" data-target-id="h2-创建-0">创建</a></li><li><a href="#删除" data-target-id="h2-删除-1">删除</a></li></ul></li><li><a href="#事务" data-target-id="h1-事务-2">事务</a></li><li><a href="#新增数据" data-target-id="h1-新增数据-3">新增数据</a></li><li><a href="#读取数据" data-target-id="h1-读取数据-4">读取数据</a></li><li><a href="#更新数据" data-target-id="h1-更新数据-5">更新数据</a></li><li><a href="#删除数据" data-target-id="h1-删除数据-6">删除数据</a></li><li><a href="#游标" data-target-id="h1-游标-7">游标</a><ul><li><a href="#创建游标" data-target-id="h2-创建游标-2">创建游标</a></li><li><a href="#数据更新" data-target-id="h2-数据更新-3">数据更新</a></li><li><a href="#移动游标" data-target-id="h2-移动游标-4">移动游标</a></li><li><a href="#键范围" data-target-id="h2-键范围-5">键范围</a></li><li><a href="#游标方向" data-target-id="h2-游标方向-6">游标方向</a></li></ul></li><li><a href="#索引" data-target-id="h1-索引-8">索引</a><ul><li><a href="#创建索引" data-target-id="h2-创建索引-7">创建索引</a></li><li><a href="#创建游标" data-target-id="h2-创建游标-8">创建游标</a></li><li><a href="#获取数据" data-target-id="h2-获取数据-9">获取数据</a></li><li><a href="#删除索引" data-target-id="h2-删除索引-10">删除索引</a></li></ul></li><li><a href="#并发" data-target-id="h1-并发-9">并发</a></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">IndexedDB</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h1>打开数据库</h1>
<p><code>indexedDB.open</code> 方法可以打开数据库，不存在会自动新建数据库。</p>
<p>该方法接收两个参数，第一个是数据库的名字，第二个是数据库的版本，打开已有数据库时，默认为当前版本；新建数据库时，默认为 <code>1</code></p>
<pre><code class="language-javascript">cosnt request = indexedDB.open(dbName[, version]);
</code></pre>
<p>该方法返回一个 <code>IDBRequest</code> 对象，该对象具有三个事件：</p>
<ul>
<li><code>error</code>：打开数据库失败</li>
<li><code>success</code>：打开数据库成功，此时通过 <code>requset.result</code> 或 <code>e.target.result</code> 可以拿到数据库对象</li>
<li><code>upgradeneeded</code>：当数据库不存在或者传入的版本号比当前高，会触发该事件，可以通过相同的方式拿到数据库对象</li>
</ul>
<p>当打开存在的数据库时，通过 <code>success</code> 事件处理后序，当新建数据库/升级版本时通过 <code>upgradeneeded</code> 事件处理后序。即 <code>success</code> 事件和 <code>upgradeneeded</code> 事件只会触发一个。</p>
<pre><code class="language-javascript">request.onupgradeneeded = e =&gt; {
    const db = e.target.result;
    const objectStore = db.createObjectStore(&#x27;person&#x27;, { keyPath: &#x27;id&#x27; });
    objectStore.createIndex(&#x27;name&#x27;, &#x27;name&#x27;, { unique: false });
    objectStore.createIndex(&#x27;email&#x27;, &#x27;email&#x27;, { unique: true });
}
</code></pre>
<h1>对象仓库</h1>
<p>每个数据库包含若干个对象仓库（object store）。它类似于关系型数据库的表格，存储的是一个个 <code>object</code> 类型的数据。</p>
<h2>创建</h2>
<p>通过 <code>db.createObjectStore</code> 创建对象存储，只能在 <code>onupgradeneeded</code> 事件处理函数中创建。</p>
<p>第一个参数为仓库名，第二个参数指定主键。</p>
<pre><code class="language-javascript">request.onupgradeneeded = e =&gt; {
    db = e.target.result;
    let objectStore;
    if (!db.objectStoreNames.contains(&#x27;person&#x27;)) {
        objectStore = db.createObjectStore(&#x27;person&#x27;, { keyPath: &#x27;id&#x27; });
    }
}
</code></pre>
<h2>删除</h2>
<p>通过<code>db.deleteObjectStore</code> 删除对象仓库，该方法也只能用于 <code>onupgradeneeded</code> 事件处理函数中。</p>
<pre><code class="language-javascript">request.onupgradeneeded = e =&gt; {
    db = e.target.result;
    db.deleteObjectStore(&#x27;person&#x27;, { keyPath: &#x27;id&#x27; });
}
</code></pre>
<h1>事务</h1>
<p>数据记录的读写和删改，都要通过事务完成。这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>
<p>事务要通过调用数据库对象的 <code>transaction</code> 方法创建。</p>
<p>第一个参数为第二个参数为访问数据的方式：<code>readonly</code>、<code>readwrite</code>、<code>versionchange</code>，默认为 <code>readonly</code></p>
<pre><code class="language-javascript">const transaction = db.transaction([&#x27;person&#x27;], &#x27;readwrite&#x27;);
const store = transaction.objectStore(&quot;person&quot;);
const request = store.get(&quot;007&quot;);

request.onerror = e =&gt; console.log(&quot;Did not get the object!&quot;);
request.onsuccess = e =&gt; console.log(e.target.result);
</code></pre>
<p>为一个事务可以完成任意多个请求，所以事务对象本身也有事件处理程序：<code>onerror</code> 和 <code>oncomplete</code>。</p>
<p>不能通过 <code>oncomplete</code> 事件处理程序的 event 对象访问请求返回的任何数据。</p>
<pre><code class="language-javascript">transaction.onerror = (event) =&gt; {
    // 整个事务被取消
};
transaction.oncomplete = (event) =&gt; {
    // 整个事务成功完成
}; 
</code></pre>
<h1>新增数据</h1>
<p>新建事务以后，通过 <code>transaction.objectStore(name)</code> 方法，拿到 <code>IDBObjectStore</code> 对象，再通过表格对象的 <code>add()</code> 方法，向表格写入一条记录。</p>
<pre><code class="language-javascript">const transaction = db.transaction([&#x27;person&#x27;], &#x27;readwrite&#x27;);
const store = transaction.objectStore(&#x27;person&#x27;);
const request = store.add({ id: 1, name: &#x27;张三&#x27;, age: 24, email: &#x27;zhangsan@example.com&#x27; });

request.onsuccess = e =&gt; console.log(&#x27;数据写入成功&#x27;);

request.onerror = e =&gt; console.log(&#x27;数据写入失败&#x27;);
</code></pre>
<h1>读取数据</h1>
<p>新建事务以后，通过 <code>transaction.objectStore(name)</code> 方法，拿到 <code>IDBObjectStore</code> 对象，再通过表格对象的 <code>get()</code> 方法，向表格写入一条记录</p>
<pre><code class="language-javascript">const transaction = db.transaction([&#x27;person&#x27;]);
const store = transaction.objectStore(&#x27;person&#x27;);
cosnt request = store.get(1);

request.onerror = e =&gt; console.log(&#x27;事务失败&#x27;);

request.onsuccess = e =&gt; {
    if (request.result) {
        console.log(&#x27;Name: &#x27; + request.result.name);
        console.log(&#x27;Age: &#x27; + request.result.age);
        console.log(&#x27;Email: &#x27; + request.result.email);
    } else {
        console.log(&#x27;未获得数据记录&#x27;);
    }
};
</code></pre>
<h1>更新数据</h1>
<p>通过 <code>IDBObject.put()</code> 方法更新数据。</p>
<p><code>add</code> 和 <code>put</code> 的区别：在新增数据的键名已存在时，<code>add</code> 会导致错误，而 <code>put</code> 会简单地重写该对象。</p>
<pre><code class="language-javascript">const request = db.transaction([&#x27;person&#x27;], &#x27;readwrite&#x27;)
	.objectStore(&#x27;person&#x27;)
	.put({ id: 1, name: &#x27;李四&#x27;, age: 35, email: &#x27;lisi@example.com&#x27; });

request.onsuccess = e =&gt; console.log(&#x27;数据更新成功&#x27;);

request.onerror = e =&gt; console.log(&#x27;数据更新失败&#x27;);
</code></pre>
<h1>删除数据</h1>
<p><code>IDBObjectStore.delete()</code> 方法用于删除记录。</p>
<pre><code class="language-javascript">const request = db.transaction([&#x27;person&#x27;], &#x27;readwrite&#x27;)
	.objectStore(&#x27;person&#x27;)
	.delete(1);

request.onsuccess = e =&gt; console.log(&#x27;数据删除成功&#x27;);
</code></pre>
<h1>游标</h1>
<p>使用事务可以通过一个已知键取得一条记录。如果想取得多条数据，则需要在事务中创建一个游标。</p>
<p>与传统数据库查询不同，游标不会事先收集所有结果。相反，游标指向第一个结果，并在接到指令前不会主动查找下一条数据。</p>
<h2>创建游标</h2>
<p>在对象存储上调用 <code>openCursor()</code> 方法创建游标的请求对象，为它添加 <code>onsuccess</code> 和 <code>onerror</code> 事件处理程序。</p>
<p><code>e.target.result</code> 的值为游标，游标为 <code>IDBCursor</code> 实例，当没有下一个值时，游标为 <code>null</code>。</p>
<pre><code class="language-javascript">const transaction = db.transaction(&quot;users&quot;);
const store = transaction.objectStore(&quot;users&quot;);
store.openCursor().onsuccess = e =&gt; {
    const cursor = e.target.result;
    if (cursor) { // 永远要检查
        console.log(`Key: ${cursor.key}, Value: ${JSON.stringify(cursor.value)}`);
    }
};
request.onerror = e =&gt; console.log(&#x27;error&#x27;)
</code></pre>
<p><code>IDBCursor</code> 实例有几个属性：</p>
<ul>
<li><code>direction</code>：字符串常量，表示游标的前进方向以及是否应该遍历所有重复的值<!-- -->
<ul>
<li><code>next</code></li>
<li><code>nextunique</code></li>
<li><code>prev</code></li>
<li><code>prevunique</code></li>
</ul>
</li>
<li><code>key</code>：键的值</li>
<li><code>value</code>：从数据库中拿到的对象值</li>
<li><code>primaryKey</code>：游标使用的键，游标用的键可能是对象键或索引键</li>
</ul>
<h2>数据更新</h2>
<p>游标原型具有 <code>updata</code> 方法，可用来更新数据。</p>
<pre><code class="language-javascript">const value = cursor.value; // 取得当前对象
value.password = &quot;magic!&quot;; // 更新数据
const updateRequest = cursor.update(value); // 请求保存更新后的对象
updateRequest.onsuccess = () =&gt; { };
updateRequest.onerror = () =&gt; { };
</code></pre>
<p>使用 <code>delelte()</code> 来删除游标位置的记录。</p>
<pre><code class="language-javascript">const deleteRequest = cursor.delete(); // 请求删除对象
deleteRequest.onsuccess = () =&gt; { };
deleteRequest.onerror = () =&gt; { };
</code></pre>
<p>如果事务没有修改对象存储的权限，<code>update()</code> 和 <code>delete()</code> 都会抛出错误。</p>
<h2>移动游标</h2>
<p>游标原型具有 <code>continue</code> 和 <code>advance</code> 方法，用于移动游标。</p>
<ul>
<li><code>continue([key])</code>：移动到结果集中的下一条记录。如果指定了 <code>key</code>，则游标移动到指定的键</li>
<li><code>advance(count)</code>：游标向前移动指定的 <code>count</code> 条记录</li>
</ul>
<p>这两个方法都会让游标重用相同的请求，因此也会重用 <code>onsuccess</code> 和 <code>onerror</code> 处理程序，直至不再需要。</p>
<pre><code class="language-javascript">request.onsuccess = e =&gt; {
    const cursor = e.target.result;
    if (cursor) {
        console.log(`Key: ${cursor.key}, Value: ${JSON.stringify(cursor.value)}`);
        cursor.continue(); // 移动到下一条记录
    } else {
        console.log(&quot;Done!&quot;);
    }
}; 
</code></pre>
<h2>键范围</h2>
<p>使用游标会给人一种不太理想的感觉，因为获取数据的方式受到了限制。使用键范围可以让游标更容易管理。</p>
<p>键范围对应 <code>IDBKeyRange</code> 的实例，有四种方式指定键范围：</p>
<ol>
<li>
<p>通过 <code>only()</code> 方法并传入想要获取的键</p>
<pre><code class="language-javascript">const onlyRange = IDBKeyRange.only(&quot;007&quot;);
</code></pre>
</li>
<li>
<p><code>lowerBound()</code> 定义结果集的下限</p>
<pre><code class="language-javascript">// 从&quot;007&quot;记录开始，直到最后
const lowerRange = IDBKeyRange.lowerBound(&quot;007&quot;);
// 从&quot;007&quot;的下一条记录开始，直到最后
const lowerRange = IDBKeyRange.lowerBound(&quot;007&quot;, true);
</code></pre>
</li>
<li>
<p><code>upperBound()</code> 定义结果集的上限 / 上下限</p>
<pre><code class="language-javascript">// 从头开始，到&quot;ace&quot;记录为止
const upperRange = IDBKeyRange.upperBound(&quot;ace&quot;);
// 从头开始，到&quot;ace&quot;的前一条记录为止
const upperRange = IDBKeyRange.upperBound(&quot;ace&quot;, true);
// 从&quot;007&quot;记录开始，到&quot;ace&quot;记录停止
const boundRange = IDBKeyRange.bound(&quot;007&quot;, &quot;ace&quot;);
// 从&quot;007&quot;的下一条记录开始，到&quot;ace&quot;记录停止
const boundRange = IDBKeyRange.bound(&quot;007&quot;, &quot;ace&quot;, true);
// 从&quot;007&quot;的下一条记录开始，到&quot;ace&quot;的前一条记录停止
const boundRange = IDBKeyRange.bound(&quot;007&quot;, &quot;ace&quot;, true, true);
// 从&quot;007&quot;记录开始，到&quot;ace&quot;的前一条记录停止
const boundRange = IDBKeyRange.bound(&quot;007&quot;, &quot;ace&quot;, false, true);
</code></pre>
</li>
</ol>
<p>定义了范围之后，把它传给 <code>openCursor()</code> 方法，就可以得到位于该范围内的游标，如果传递 <code>null</code>，表示键范围是所有值。</p>
<pre><code class="language-javascript">const store = db.transaction(&quot;users&quot;).objectStore(&quot;users&quot;);
const range = IDBKeyRange.bound(&quot;007&quot;, &quot;ace&quot;);
store.openCursor(range).onsuccess = e =&gt; {
    const cursor = e.target.result;
    if (cursor) { // 永远要检查
        console.log(`Key: ${cursor.key}, Value: ${JSON.stringify(cursor.value)}`);
        cursor.continue(); // 移动到下一条记录
    } else {
        console.log(&quot;Done!&quot;);
    }
}; 
</code></pre>
<h2>游标方向</h2>
<p><code>openCursor()</code> 方法实际上可以接收两个参数，第一个是 <code>IDBKeyRange</code> 的实例，第二个是表示方向的字符串。</p>
<p>通常，游标都是从对象存储的第一条记录开始，每次调用 <code>continue()</code> 或 <code>advance()</code> 都会向最后一条记录前进。</p>
<p>默认值为 <code>next</code>，如果传递 <code>nextunique</code>，则会跳过键重复的项。<code>prev</code>、<code>prevunique</code> 则是相反。</p>
<pre><code class="language-javascript">const transaction = db.transaction(&quot;users&quot;);
const store = transaction.objectStore(&quot;users&quot;);
const request = store.openCursor(null, &quot;nextunique&quot;);
</code></pre>
<h1>索引</h1>
<p>索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键。</p>
<h2>创建索引</h2>
<p>要创建新索引，首先要取得对象存储的引用，然后调用 <code>createIndex()</code></p>
<pre><code class="language-javascript">const transaction = db.transaction(&quot;users&quot;);
const store = transaction.objectStore(&quot;users&quot;);
const index = store.createIndex(&quot;username&quot;, &quot;username&quot;, { unique: true });
</code></pre>
<p><code>createIndex</code> 的第一个参数是索引的名称，第二个参数是索引属性的名称，第三个参数是包含 键 <code>unique</code> 的 <code>options</code> 对象。这个选项中的 <code>unique</code> 应该必须指定，表示这个键是否在所有记录中唯 一。</p>
<p><code>createIndex()</code> 返回的是 <code>IDBIndex</code> 实例。在对象存储上调用 <code>index()</code> 方法也可以得到同一个实例。</p>
<pre><code class="language-javascript">const transaction = db.transaction(&quot;users&quot;);
const store = transaction.objectStore(&quot;users&quot;);
const index = store.index(&quot;username&quot;);
</code></pre>
<h2>创建游标</h2>
<p>在索引上使用 <code>openCursor()</code> 方法创建新游标，这个游标与在对象存储上调用 <code>openCursor()</code> 创建的游标完全一样。区别仅在于其<code>result.key</code> 属性中保存的是索引键，而不是主键。</p>
<pre><code class="language-javascript">const transaction = db.transaction(&quot;users&quot;);
const store = transaction.objectStore(&quot;users&quot;);
const index = store.index(&quot;username&quot;);
const request = index.openCursor();
request.onsuccess = e =&gt; { }; 
</code></pre>
<p>使用 <code>openKeyCursor()</code> 方法也可以在索引上创建特殊游标，只返回每条记录的主键。</p>
<p>这个方法接收的参数与 <code>openCursor()</code> 一样。不同在于 <code>event.result.key</code> 是索引键，且 <code>event.result.value</code> 是主键而不是整个记录。</p>
<h2>获取数据</h2>
<p>可以使用 <code>get()</code> 方法并传入索引键通过索引取得单条记录</p>
<pre><code class="language-javascript">const transaction = db.transaction(&quot;users&quot;);
const store = transaction.objectStore(&quot;users&quot;);
const index = store.index(&quot;username&quot;);
const request = index.get(&quot;007&quot;);
request.onsuccess = e =&gt; { };
request.onerror = e =&gt; { };
</code></pre>
<h2>删除索引</h2>
<p>在对象存储上调用 <code>deleteIndex()</code> 方法并传入索引的名称可以删除索引</p>
<pre><code class="language-javascript">const transaction = db.transaction(&quot;users&quot;);
const store = transaction.objectStore(&quot;users&quot;);
const store.deleteIndex(&quot;username&quot;);
</code></pre>
<h1>并发</h1>
<p>如果两个不同的浏览器标签页同时打开了同一个网页，则有可能出现一个网页尝试升级数据库而另一个尚未就绪的情形。</p>
<p>第一次打开数据库时，添加 <code>onversionchange</code> 事件处理程序非常重要。另一个同源标签页将数据库打开到新版本时，将执行此回调。</p>
<p>对这个事件最好的回应是立即关闭数据库，以便完成版本升级。</p>
<pre><code class="language-javascript">let request, database;
request = indexedDB.open(&quot;admin&quot;, 1);
request.onsuccess = e =&gt; {
    database = e.target.result;
    database.onversionchange = () =&gt; database.close();
}; 
</code></pre><div><a href="/notes/JavaScript/Web%20api">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"IndexedDB","article":{"title":"IndexedDB","content":"# 打开数据库\r\n\r\n`indexedDB.open` 方法可以打开数据库，不存在会自动新建数据库。\r\n\r\n该方法接收两个参数，第一个是数据库的名字，第二个是数据库的版本，打开已有数据库时，默认为当前版本；新建数据库时，默认为 `1`\r\n\r\n```javascript\r\ncosnt request = indexedDB.open(dbName[, version]);\r\n```\r\n\r\n该方法返回一个 `IDBRequest` 对象，该对象具有三个事件：\r\n\r\n- `error`：打开数据库失败\r\n- `success`：打开数据库成功，此时通过 `requset.result` 或 `e.target.result` 可以拿到数据库对象\r\n- `upgradeneeded`：当数据库不存在或者传入的版本号比当前高，会触发该事件，可以通过相同的方式拿到数据库对象\r\n\r\n当打开存在的数据库时，通过 `success` 事件处理后序，当新建数据库/升级版本时通过 `upgradeneeded` 事件处理后序。即 `success` 事件和 `upgradeneeded` 事件只会触发一个。\r\n\r\n```javascript\r\nrequest.onupgradeneeded = e =\u003e {\r\n    const db = e.target.result;\r\n    const objectStore = db.createObjectStore('person', { keyPath: 'id' });\r\n    objectStore.createIndex('name', 'name', { unique: false });\r\n    objectStore.createIndex('email', 'email', { unique: true });\r\n}\r\n```\r\n\r\n# 对象仓库\r\n\r\n每个数据库包含若干个对象仓库（object store）。它类似于关系型数据库的表格，存储的是一个个 `object` 类型的数据。\r\n\r\n## 创建\r\n\r\n通过 `db.createObjectStore` 创建对象存储，只能在 `onupgradeneeded` 事件处理函数中创建。\r\n\r\n第一个参数为仓库名，第二个参数指定主键。\r\n\r\n```javascript\r\nrequest.onupgradeneeded = e =\u003e {\r\n    db = e.target.result;\r\n    let objectStore;\r\n    if (!db.objectStoreNames.contains('person')) {\r\n        objectStore = db.createObjectStore('person', { keyPath: 'id' });\r\n    }\r\n}\r\n```\r\n\r\n## 删除\r\n\r\n通过`db.deleteObjectStore` 删除对象仓库，该方法也只能用于 `onupgradeneeded` 事件处理函数中。\r\n\r\n```javascript\r\nrequest.onupgradeneeded = e =\u003e {\r\n    db = e.target.result;\r\n    db.deleteObjectStore('person', { keyPath: 'id' });\r\n}\r\n```\r\n\r\n# 事务\r\n\r\n数据记录的读写和删改，都要通过事务完成。这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。\r\n\r\n事务要通过调用数据库对象的 `transaction` 方法创建。\r\n\r\n第一个参数为第二个参数为访问数据的方式：`readonly`、`readwrite`、`versionchange`，默认为 `readonly`\r\n\r\n```javascript\r\nconst transaction = db.transaction(['person'], 'readwrite');\r\nconst store = transaction.objectStore(\"person\");\r\nconst request = store.get(\"007\");\r\n\r\nrequest.onerror = e =\u003e console.log(\"Did not get the object!\");\r\nrequest.onsuccess = e =\u003e console.log(e.target.result);\r\n```\r\n\r\n为一个事务可以完成任意多个请求，所以事务对象本身也有事件处理程序：`onerror` 和 `oncomplete`。\r\n\r\n不能通过 `oncomplete` 事件处理程序的 event 对象访问请求返回的任何数据。\r\n\r\n```javascript\r\ntransaction.onerror = (event) =\u003e {\r\n    // 整个事务被取消\r\n};\r\ntransaction.oncomplete = (event) =\u003e {\r\n    // 整个事务成功完成\r\n}; \r\n```\r\n\r\n# 新增数据\r\n\r\n新建事务以后，通过 `transaction.objectStore(name)` 方法，拿到 `IDBObjectStore` 对象，再通过表格对象的 `add()` 方法，向表格写入一条记录。\r\n\r\n```javascript\r\nconst transaction = db.transaction(['person'], 'readwrite');\r\nconst store = transaction.objectStore('person');\r\nconst request = store.add({ id: 1, name: '张三', age: 24, email: 'zhangsan@example.com' });\r\n\r\nrequest.onsuccess = e =\u003e console.log('数据写入成功');\r\n\r\nrequest.onerror = e =\u003e console.log('数据写入失败');\r\n```\r\n\r\n# 读取数据\r\n\r\n新建事务以后，通过 `transaction.objectStore(name)` 方法，拿到 `IDBObjectStore` 对象，再通过表格对象的 `get()` 方法，向表格写入一条记录\r\n\r\n```javascript\r\nconst transaction = db.transaction(['person']);\r\nconst store = transaction.objectStore('person');\r\ncosnt request = store.get(1);\r\n\r\nrequest.onerror = e =\u003e console.log('事务失败');\r\n\r\nrequest.onsuccess = e =\u003e {\r\n    if (request.result) {\r\n        console.log('Name: ' + request.result.name);\r\n        console.log('Age: ' + request.result.age);\r\n        console.log('Email: ' + request.result.email);\r\n    } else {\r\n        console.log('未获得数据记录');\r\n    }\r\n};\r\n```\r\n\r\n# 更新数据\r\n\r\n通过 `IDBObject.put()` 方法更新数据。\r\n\r\n`add` 和 `put` 的区别：在新增数据的键名已存在时，`add` 会导致错误，而 `put` 会简单地重写该对象。\r\n\r\n```javascript\r\nconst request = db.transaction(['person'], 'readwrite')\r\n\t.objectStore('person')\r\n\t.put({ id: 1, name: '李四', age: 35, email: 'lisi@example.com' });\r\n\r\nrequest.onsuccess = e =\u003e console.log('数据更新成功');\r\n\r\nrequest.onerror = e =\u003e console.log('数据更新失败');\r\n```\r\n\r\n# 删除数据\r\n\r\n`IDBObjectStore.delete()` 方法用于删除记录。\r\n\r\n```javascript\r\nconst request = db.transaction(['person'], 'readwrite')\r\n\t.objectStore('person')\r\n\t.delete(1);\r\n\r\nrequest.onsuccess = e =\u003e console.log('数据删除成功');\r\n```\r\n\r\n# 游标\r\n\r\n使用事务可以通过一个已知键取得一条记录。如果想取得多条数据，则需要在事务中创建一个游标。\r\n\r\n与传统数据库查询不同，游标不会事先收集所有结果。相反，游标指向第一个结果，并在接到指令前不会主动查找下一条数据。\r\n\r\n## 创建游标\r\n\r\n在对象存储上调用 `openCursor()` 方法创建游标的请求对象，为它添加 `onsuccess` 和 `onerror` 事件处理程序。\r\n\r\n`e.target.result` 的值为游标，游标为 `IDBCursor` 实例，当没有下一个值时，游标为 `null`。\r\n\r\n```javascript\r\nconst transaction = db.transaction(\"users\");\r\nconst store = transaction.objectStore(\"users\");\r\nstore.openCursor().onsuccess = e =\u003e {\r\n    const cursor = e.target.result;\r\n    if (cursor) { // 永远要检查\r\n        console.log(`Key: ${cursor.key}, Value: ${JSON.stringify(cursor.value)}`);\r\n    }\r\n};\r\nrequest.onerror = e =\u003e console.log('error')\r\n```\r\n\r\n`IDBCursor` 实例有几个属性：\r\n\r\n- `direction`：字符串常量，表示游标的前进方向以及是否应该遍历所有重复的值\r\n\t- `next`\r\n\t- `nextunique`\r\n\t- `prev`\r\n\t- `prevunique`\r\n- `key`：键的值\r\n- `value`：从数据库中拿到的对象值\r\n- `primaryKey`：游标使用的键，游标用的键可能是对象键或索引键\r\n\r\n## 数据更新\r\n\r\n游标原型具有 `updata` 方法，可用来更新数据。\r\n\r\n```javascript\r\nconst value = cursor.value; // 取得当前对象\r\nvalue.password = \"magic!\"; // 更新数据\r\nconst updateRequest = cursor.update(value); // 请求保存更新后的对象\r\nupdateRequest.onsuccess = () =\u003e { };\r\nupdateRequest.onerror = () =\u003e { };\r\n```\r\n\r\n使用 `delelte()` 来删除游标位置的记录。\r\n\r\n```javascript\r\nconst deleteRequest = cursor.delete(); // 请求删除对象\r\ndeleteRequest.onsuccess = () =\u003e { };\r\ndeleteRequest.onerror = () =\u003e { };\r\n```\r\n\r\n如果事务没有修改对象存储的权限，`update()` 和 `delete()` 都会抛出错误。\r\n\r\n## 移动游标\r\n\r\n游标原型具有 `continue` 和 `advance` 方法，用于移动游标。\r\n\r\n- `continue([key])`：移动到结果集中的下一条记录。如果指定了 `key`，则游标移动到指定的键\r\n- `advance(count)`：游标向前移动指定的 `count` 条记录\r\n\r\n这两个方法都会让游标重用相同的请求，因此也会重用 `onsuccess` 和 `onerror` 处理程序，直至不再需要。\r\n\r\n```javascript\r\nrequest.onsuccess = e =\u003e {\r\n    const cursor = e.target.result;\r\n    if (cursor) {\r\n        console.log(`Key: ${cursor.key}, Value: ${JSON.stringify(cursor.value)}`);\r\n        cursor.continue(); // 移动到下一条记录\r\n    } else {\r\n        console.log(\"Done!\");\r\n    }\r\n}; \r\n```\r\n\r\n## 键范围\r\n\r\n使用游标会给人一种不太理想的感觉，因为获取数据的方式受到了限制。使用键范围可以让游标更容易管理。\r\n\r\n键范围对应 `IDBKeyRange` 的实例，有四种方式指定键范围：\r\n\r\n1. 通过 `only()` 方法并传入想要获取的键\r\n\r\n\t```javascript\r\n\tconst onlyRange = IDBKeyRange.only(\"007\");\r\n\t```\r\n\r\n2. `lowerBound()` 定义结果集的下限\r\n\r\n\t```javascript\r\n\t// 从\"007\"记录开始，直到最后\r\n\tconst lowerRange = IDBKeyRange.lowerBound(\"007\");\r\n\t// 从\"007\"的下一条记录开始，直到最后\r\n\tconst lowerRange = IDBKeyRange.lowerBound(\"007\", true);\r\n\t```\r\n\r\n3. `upperBound()` 定义结果集的上限 / 上下限\r\n\r\n\t```javascript\r\n\t// 从头开始，到\"ace\"记录为止\r\n\tconst upperRange = IDBKeyRange.upperBound(\"ace\");\r\n\t// 从头开始，到\"ace\"的前一条记录为止\r\n\tconst upperRange = IDBKeyRange.upperBound(\"ace\", true);\r\n\t// 从\"007\"记录开始，到\"ace\"记录停止\r\n\tconst boundRange = IDBKeyRange.bound(\"007\", \"ace\");\r\n\t// 从\"007\"的下一条记录开始，到\"ace\"记录停止\r\n\tconst boundRange = IDBKeyRange.bound(\"007\", \"ace\", true);\r\n\t// 从\"007\"的下一条记录开始，到\"ace\"的前一条记录停止\r\n\tconst boundRange = IDBKeyRange.bound(\"007\", \"ace\", true, true);\r\n\t// 从\"007\"记录开始，到\"ace\"的前一条记录停止\r\n\tconst boundRange = IDBKeyRange.bound(\"007\", \"ace\", false, true);\r\n\t```\r\n\r\n定义了范围之后，把它传给 `openCursor()` 方法，就可以得到位于该范围内的游标，如果传递 `null`，表示键范围是所有值。\r\n\r\n```javascript\r\nconst store = db.transaction(\"users\").objectStore(\"users\");\r\nconst range = IDBKeyRange.bound(\"007\", \"ace\");\r\nstore.openCursor(range).onsuccess = e =\u003e {\r\n    const cursor = e.target.result;\r\n    if (cursor) { // 永远要检查\r\n        console.log(`Key: ${cursor.key}, Value: ${JSON.stringify(cursor.value)}`);\r\n        cursor.continue(); // 移动到下一条记录\r\n    } else {\r\n        console.log(\"Done!\");\r\n    }\r\n}; \r\n```\r\n\r\n## 游标方向\r\n\r\n`openCursor()` 方法实际上可以接收两个参数，第一个是 `IDBKeyRange` 的实例，第二个是表示方向的字符串。\r\n\r\n通常，游标都是从对象存储的第一条记录开始，每次调用 `continue()` 或 `advance()` 都会向最后一条记录前进。\r\n\r\n默认值为 `next`，如果传递 `nextunique`，则会跳过键重复的项。`prev`、`prevunique` 则是相反。\r\n\r\n```javascript\r\nconst transaction = db.transaction(\"users\");\r\nconst store = transaction.objectStore(\"users\");\r\nconst request = store.openCursor(null, \"nextunique\");\r\n```\r\n\r\n# 索引\r\n\r\n索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键。\r\n\r\n## 创建索引\r\n\r\n要创建新索引，首先要取得对象存储的引用，然后调用 `createIndex()`\r\n\r\n```javascript\r\nconst transaction = db.transaction(\"users\");\r\nconst store = transaction.objectStore(\"users\");\r\nconst index = store.createIndex(\"username\", \"username\", { unique: true });\r\n```\r\n\r\n`createIndex` 的第一个参数是索引的名称，第二个参数是索引属性的名称，第三个参数是包含 键 `unique` 的 `options` 对象。这个选项中的 `unique` 应该必须指定，表示这个键是否在所有记录中唯 一。\r\n\r\n`createIndex()` 返回的是 `IDBIndex` 实例。在对象存储上调用 `index()` 方法也可以得到同一个实例。\r\n\r\n```javascript\r\nconst transaction = db.transaction(\"users\");\r\nconst store = transaction.objectStore(\"users\");\r\nconst index = store.index(\"username\");\r\n```\r\n\r\n## 创建游标\r\n\r\n在索引上使用 `openCursor()` 方法创建新游标，这个游标与在对象存储上调用 `openCursor()` 创建的游标完全一样。区别仅在于其`result.key` 属性中保存的是索引键，而不是主键。\r\n\r\n```javascript\r\nconst transaction = db.transaction(\"users\");\r\nconst store = transaction.objectStore(\"users\");\r\nconst index = store.index(\"username\");\r\nconst request = index.openCursor();\r\nrequest.onsuccess = e =\u003e { }; \r\n```\r\n\r\n使用 `openKeyCursor()` 方法也可以在索引上创建特殊游标，只返回每条记录的主键。\r\n\r\n这个方法接收的参数与 `openCursor()` 一样。不同在于 `event.result.key` 是索引键，且 `event.result.value` 是主键而不是整个记录。\r\n\r\n## 获取数据\r\n\r\n可以使用 `get()` 方法并传入索引键通过索引取得单条记录\r\n\r\n```javascript\r\nconst transaction = db.transaction(\"users\");\r\nconst store = transaction.objectStore(\"users\");\r\nconst index = store.index(\"username\");\r\nconst request = index.get(\"007\");\r\nrequest.onsuccess = e =\u003e { };\r\nrequest.onerror = e =\u003e { };\r\n```\r\n\r\n## 删除索引\r\n\r\n在对象存储上调用 `deleteIndex()` 方法并传入索引的名称可以删除索引\r\n\r\n```javascript\r\nconst transaction = db.transaction(\"users\");\r\nconst store = transaction.objectStore(\"users\");\r\nconst store.deleteIndex(\"username\");\r\n```\r\n\r\n# 并发\r\n\r\n如果两个不同的浏览器标签页同时打开了同一个网页，则有可能出现一个网页尝试升级数据库而另一个尚未就绪的情形。\r\n\r\n第一次打开数据库时，添加 `onversionchange` 事件处理程序非常重要。另一个同源标签页将数据库打开到新版本时，将执行此回调。\r\n\r\n对这个事件最好的回应是立即关闭数据库，以便完成版本升级。\r\n\r\n```javascript\r\nlet request, database;\r\nrequest = indexedDB.open(\"admin\", 1);\r\nrequest.onsuccess = e =\u003e {\r\n    database = e.target.result;\r\n    database.onversionchange = () =\u003e database.close();\r\n}; \r\n```\r\n\r\n\r\n\r\n\r\n\r\n","meta":{"size":13685,"birthTime":1663496641398.5015,"updateTime":1663496641398.7083}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["JavaScript","Web api","IndexedDB"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
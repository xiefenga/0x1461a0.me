<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>BOM | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#窗口关系" data-target-id="h2-窗口关系-0">窗口关系</a></li><li><a href="#像素比" data-target-id="h2-像素比-1">像素比</a></li><li><a href="#窗口位置" data-target-id="h2-窗口位置-2">窗口位置</a></li><li><a href="#窗口大小" data-target-id="h2-窗口大小-3">窗口大小</a></li><li><a href="#视口位置" data-target-id="h2-视口位置-4">视口位置</a></li><li><a href="#导航和新窗口" data-target-id="h2-导航和新窗口-5">导航和新窗口</a><ul><li><a href="#窗口名" data-target-id="h3-窗口名-0">窗口名</a></li><li><a href="#窗口特性" data-target-id="h3-窗口特性-1">窗口特性</a></li><li><a href="#窗口控制" data-target-id="h3-窗口控制-2">窗口控制</a></li></ul></li><li><a href="#location" data-target-id="h2-location-6">location</a><ul><li><a href="#URL 信息" data-target-id="h3-URL 信息-3">URL 信息</a></li><li><a href="#操作地址" data-target-id="h3-操作地址-4">操作地址</a></li><li><a href="#URLSearchParams" data-target-id="h3-URLSearchParams-5">URLSearchParams</a></li><li><a href="#URL 编码" data-target-id="h3-URL 编码-6">URL 编码</a></li></ul></li><li><a href="#不进行编码" data-target-id="h1-不进行编码-0">不进行编码</a></li><li><a href="#也会进行编码" data-target-id="h1-也会进行编码-1">也会进行编码</a><ul><li><a href="#history" data-target-id="h2-history-7">history</a><ul><li><a href="#导航" data-target-id="h3-导航-7">导航</a></li><li><a href="#历史状态" data-target-id="h3-历史状态-8">历史状态</a></li></ul></li></ul></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">BOM</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h2>窗口关系</h2>
<p>在应用有 iframe 的页面时：</p>
<ul>
<li>top 对象始终指向最上层窗口，即浏览器窗口本身</li>
<li>parent 对象则始终指向当前窗口的父窗口</li>
<li>self 对象始终会指向 window</li>
</ul>
<p>如果没有使用 iframe 则都指向 window</p>
<h2>像素比</h2>
<p>CSS 像素是 Web 开发中使用的统一像素单位。</p>
<p>这个单位的背后其实是一个角度：0.0213°。</p>
<p>如果屏幕距离人眼是一臂长，则以这个角度计算的 CSS 像素大小约为 1/96 英寸，这样定义像素大小是为了在不同设备上统一标准。</p>
<p>物理像素与 CSS 像素之间的转换比率由 <code>window.devicePixelRatio</code> 属性提供</p>
<p><code>window.devicePixelRatio</code> 实际上与 DPI 相对应，DPI 表示单位像素密度，<code>window.devicePixelRatio</code> 表示物理像素与逻辑像素之间的缩放系数</p>
<h2>窗口位置</h2>
<p>现代浏览器提供了 <code>screenLeft</code> 和 <code>screenTop</code> 属性，用于表示窗口相对于屏幕左侧和顶部的位置 ，返回值的单位是 CSS 像素。</p>
<p>使用 <code>moveTo()</code> 和 <code>moveBy()</code> 方法可以移动窗口，</p>
<h2>窗口大小</h2>
<p>所有现代浏览器都支持 4 个属性：<code>innerWidth</code>、<code>innerHeight</code>、<code>outerWidth</code> 和 <code>outerHeight</code>。</p>
<ul>
<li><code>outerWidth</code> 和 <code>outerHeight</code> 返回浏览器窗口自身的大小</li>
<li><code>innerWidth</code> 和 <code>innerHeight</code> 返回浏览器窗口中页面视口的大小</li>
</ul>
<p><code>resizeTo()</code> 和 <code>resizeBy()</code> 方法可以调整窗口大小，缩放窗口的方法可能会被浏览器禁用，缩放窗口只能应用到最上层的 window 对象。</p>
<h2>视口位置</h2>
<p>度量文档相对于视口滚动距离的属性有两对，并且返回相同的值：</p>
<ul>
<li><code>window.pageXoffset</code>、<code>window.pageYoffset</code></li>
<li><code>window. scrollX</code>、<code>window.scrollY</code></li>
</ul>
<p>使用 <code>scroll()</code>、<code>scrollTo()</code> 和 <code>scrollBy()</code> 方法可以滚动页面：</p>
<ol>
<li><code>scroll</code> 和 <code>scrollTo</code> 相同</li>
<li>除了可以接受偏移距离，也可以接收一个 ScrollToOptions 字典参数<!-- -->
<ol>
<li>ScrollToOptions 对象具有 <code>left</code> 和 <code>top</code> 属性</li>
<li>ScrollToOptions 对象还具有 <code>behavior</code> 属性，描述滚动行为，取值 <code>auto</code> 和 <code>smooth</code></li>
</ol>
</li>
</ol>
<pre><code class="language-javascript">// 正常滚动
window.scrollTo({
  left: 100,
  top: 100,
  behavior: &#x27;auto&#x27;
})
// 平滑滚动
window.scrollTo({ 
  left: 100,
  top: 100,
  behavior: &#x27;smooth&#x27;
})
</code></pre>
<h2>导航和新窗口</h2>
<p><code>window.open()</code> 方法可以用于导航到指定 URL，也可以用于打开新浏览器窗口。</p>
<p>该方法接收四个参数：URL、目标窗口名、特性字符串、替换当前页面</p>
<h3>窗口名</h3>
<p>如果第二个参数是一个已经存在的窗口或窗格(frame)的名字，则会在对应的窗口或窗格中打开 URL</p>
<pre><code class="language-javascript">// 与&lt;a href=&quot;http://www.wrox.com&quot; target=&quot;topFrame&quot;/&gt;相同 
window.open(&quot;http://www.wrox.com/&quot;, &quot;topFrame&quot;);
</code></pre>
<p>该参数也可以是一个特殊的窗口名，比如<code>_self</code>、 <code>_parent</code>、<code>_top</code> 或 <code>_blank</code>。</p>
<h3>窗口特性</h3>
<p>如果不是打开已有窗口，则会打开一个新窗口或标签页。</p>
<ol>
<li>当特性字符串中至少包含 <code>width</code> 或 <code>height</code> 时则会打开一个新的窗口</li>
<li>如果打开的不是新窗口，则忽略该参数</li>
<li>特性字符串是一个逗号分隔的设置字符串，用于指定新窗口包含的特性</li>
</ol>
<table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">height、width</td><td style="text-align:center">number</td><td style="text-align:center">新窗口的高度和宽度，不能小于 100</td></tr><tr><td style="text-align:center">top、left</td><td style="text-align:center">number</td><td style="text-align:center">新窗口的 x、y 轴坐标，不能小于 0</td></tr><tr><td style="text-align:center">location</td><td style="text-align:center">&#x27;yes&#x27; | &#x27;no&#x27;</td><td style="text-align:center">表示是否显示地址栏，不同浏览器的默认值不一样</td></tr><tr><td style="text-align:center">Menubar</td><td style="text-align:center">&#x27;yes&#x27; | &#x27;no&#x27;</td><td style="text-align:center">表示是否显示菜单栏，默认为&quot;no&quot;</td></tr><tr><td style="text-align:center">resizable</td><td style="text-align:center">&#x27;yes&#x27;  | &#x27;no&#x27;</td><td style="text-align:center">表示是否可以拖动改变新窗口大小。默认为&quot;no&quot;</td></tr><tr><td style="text-align:center">scrollbars</td><td style="text-align:center">&#x27;yes&#x27; | &#x27;no&#x27;</td><td style="text-align:center">表示是否可以在内容过长时滚动，默认为&quot;no&quot;</td></tr><tr><td style="text-align:center">status</td><td style="text-align:center">&#x27;yes&#x27; | &#x27;no&#x27;</td><td style="text-align:center">表示是否显示状态栏，不同浏览器的默认值不一样</td></tr><tr><td style="text-align:center">toolbar</td><td style="text-align:center">&#x27;yes&#x27; | &#x27;no&#x27;</td><td style="text-align:center">表示是否显示工具栏，默认为&quot;no&quot;</td></tr></tbody></table>
<pre><code class="language-javascript">window.open(&#x27;https://xiefeng.tech&#x27;, null, &#x27;height=400,width=400&#x27;)
</code></pre>
<h3>窗口控制</h3>
<p><code>window.open()</code> 方法返回一个对新建窗口的引用，这个对象与普通 window 对象没有区别，只是为控制新窗口提供了方便。</p>
<p>某些浏览器默认不允许缩放或移动主窗口，但可能允许缩放或移动通过 <code>window.open()</code> 创建的窗口，比如 chrome</p>
<p>Chrome 下无法 resize 和 move 主窗口，也没有办法 close 主窗口，但是允许通过 open 返回的对象对新建窗口进行操作：</p>
<ol>
<li>可以关闭新建窗口</li>
<li>非跨域情况可以正常 <code>resizeTo</code>、<code>moveTo</code> 操作</li>
</ol>
<p>新创建窗口的 window 对象的 opener 属性指向打开它的窗口：</p>
<pre><code class="language-javascript">const child = window.open(&#x27;/index.html&#x27;, null, `height=400,width=400`)
console.log(child.opener === window)	// true
</code></pre>
<p>现代浏览器都是多进程架构，每个标签页会运行在独立的进程中。</p>
<p>如果一个标签页打开了另一个，window 对象可能需要跟另一个标签页通信，那么新的标签页不能运行在独立的进程中。</p>
<p>将新打开标签页的 opener 设置为 null，表示新打开的标签页可以运行在独立的进程中，这个连接一旦切断就无法恢复。</p>
<pre><code class="language-javascript">const child = window.open(&#x27;/index.html&#x27;, null, `height=400,width=400`)
child.opener = null
</code></pre>
<h2>location</h2>
<p>location 对象提供了当前窗口中加载文档的信息，以及通常的导航功能</p>
<h3>URL 信息</h3>
<ul>
<li>location.hash：URL 中的 hash 值，包括 <code>#</code></li>
<li>location.host：主机名及端口号</li>
<li>location.hostname：主机名（域名）</li>
<li>location.href：当前加载页面的完整 URL，location 的 <code>toString()</code> 方法也返回这个值</li>
<li>location.port：URL 中的端口号，没有即为 <code>&#x27;&#x27;</code></li>
<li>location.protocol：页面使用的协议，通常是 <code>&quot;http:&quot;</code> 或 <code>&quot;https:&quot;</code></li>
<li>location.search：URL 中的查询字符串，包括 <code>?</code></li>
<li>location.origin：URL 的源地址，只读</li>
</ul>
<h3>操作地址</h3>
<p>可以通过修改 location 对象修改浏览器的地址，除了 <code>location.origin</code> 其他的属性都可以修改从而改变当前的 URL</p>
<p>使用 <code>location.assign</code> 方法会立即启动导航到新 URL 的操作，同时在浏览器历史记录中增加一条记录</p>
<pre><code class="language-javascript">// 相同的效果
location.assign(&#x27;https://xiefeng.tech&#x27;)
location.href = &#x27;https://xiefeng.tech&#x27;
window.location = &#x27;https://xiefeng.tech&#x27;
</code></pre>
<p>如果不希望增加历史记录，可以使用 <code>location.replace</code> 方法，使用该方法重新加载后不会增加历史记录</p>
<pre><code class="language-javascript">location.replace(&#x27;https://xiefeng.tech&#x27;)
</code></pre>
<p>使用 <code>location.reload</code> 可以重新加载当前显示的页面，如果想强制从服务器重新加载页面，可以传递参数 true</p>
<pre><code class="language-javascript">location.reload(); // 重新加载，可能是从缓存加载 
location.reload(true); // 重新加载，从服务器加载
</code></pre>
<p>位于 <code>reload</code> 之后的代码可能执行也可能不执行，这取决于网络延迟和系统资源等因素，最好把 <code>reload</code> 作为最后一行代码。</p>
<h3>URLSearchParams</h3>
<p>URLSearchParams 提供了一组标准 API 方法，通过它们可以检查和修改查询字符串：</p>
<pre><code class="language-javascript">const qs = &#x27;?q=javascript&amp;num=10&#x27;

const searchParams = new URLSearchParams(qs)

console.log(searchParams.toString())	// q=javascript&amp;num=10

console.log(
  searchParams.has(&#x27;q&#x27;),
  searchParams.get(&#x27;q&#x27;)
)	// true &#x27;javascript&#x27;

searchParams.set(&#x27;page&#x27;, &#x27;10&#x27;)

searchParams.delete(&#x27;num&#x27;)

console.log(searchParams.toString())	// q=javascript&amp;page=10
</code></pre>
<p>URLSearchParams 也实现了迭代器接口：</p>
<pre><code class="language-javascript">for (let param of searchParams) {
  console.log(param);
}
// [&quot;q&quot;, &quot;javascript&quot;]
// [&quot;num&quot;, &quot;10&quot;]
</code></pre>
<h3>URL 编码</h3>
<p>JavaScript 内置了一些进行 URL 编码和解码的函数</p>
<ul>
<li>
<p><code>escape</code></p>
<ul>
<li>不能直接用于URL编码，它的真正作用是返回一个字符的 Unicode 编码值</li>
<li>除了ASCII字母、数字、标点符号 @ * _ + - . / 以外，对其他所有字符进行编码</li>
<li>解码函数是 <code>unescape()</code></li>
</ul>
<pre><code class="language-javascript">escape(&#x27;https://xiefeng.tech/Vue2的响应式原理.html&#x27;)
// &#x27;https%3A//xiefeng.tech/Vue2%u7684%u54CD%u5E94%u5F0F%u539F%u7406.html&#x27;

unescape(&#x27;https%3A//xiefeng.tech/Vue2%u7684%u54CD%u5E94%u5F0F%u539F%u7406.html&#x27;)
// &#x27;https://xiefeng.tech/Vue2的响应式原理.html&#x27;
</code></pre>
</li>
<li>
<p><code>encodeURI</code></p>
<ul>
<li>对整个URL进行编码，对 URL 中特殊的含义的符号 ; / ? : @ &amp; = + $ , # 不进行编码</li>
<li>编码后输出为 utf-8 形式，并且在每个字节前加上%</li>
<li>对应的解码函数是 <code>decodeURI()</code></li>
</ul>
</li>
<li>
<p><code>encodeURIComponent</code></p>
<ul>
<li>对URL的组成部分进行个别编码，; / ? : @ &amp; = + $ , # 也会进行编码</li>
<li>编码方法和 <code>encodeURL</code> 相同</li>
<li>解码函数是 <code>decodeURIComponent()</code></li>
</ul>
</li>
</ul>
<h2>history</h2>
<p>history 对象表示当前窗口首次使用以来用户的导航历史记录，出于安全考虑，该对象不会暴露用户访问过的 URL， 但可以通过它在不知道实际 URL 的情况下前进和后退。</p>
<h3>导航</h3>
<p><code>history.go</code> 可以在用户历史记录中沿任何方向导航，可以前进也可以后退：</p>
<pre><code class="language-javascript">history.go(-1)
history.go(1)
</code></pre>
<p><code>history.go</code> 有两个简写方法：<code>history.back</code> 和 <code>history.forward</code>，这两个方法模拟了浏览器的后退按钮和前进按钮</p>
<p><code>history.length</code> 表示历史记录中有多个条目</p>
<h3>历史状态</h3>
<p>HTML5 为 history 对象增加了方便的状态管理特性，状态管理 API 可以让开发者改变浏览器 URL 而不会加载新页面。</p>
<p><code>history.pushState()</code> 方法接收 3 个参数：一个 state 对象、一个新状态的标题、一个相对 URL（可选）</p>
<ul>
<li>第一 个参数包含初始化页面状态所必需的信息，状态的对象大小通常在 500KB~1MB 以内</li>
<li>第二个参数并未被当前实现所使用</li>
<li>方法执行后，状态信息就会被推到历史记录中，浏览器地址栏也会改变以反映新的 URL</li>
</ul>
<p>通过 pushState 所添加的历史记录，在进行前进、后退操作时会触发 window 的 <code>popstate</code> 事件：</p>
<pre><code class="language-javascript">window.addEventListener(&#x27;popstate&#x27;, e =&gt; {
  console.log(e.state)
})
</code></pre>
<p>页面初次加载时没有状态，因此后退到最初页面时，event.state 为 <code>null</code></p>
<p>可以通过 <code>history.state</code> 获取当前的状态对象，通过 <code>replaceState</code> 可以更新当前的状态，参数和 <code>pushState</code> 前两个参数相同</p><div><a href="/notes/JavaScript/Web%20api">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"BOM","article":{"title":"BOM","content":"## 窗口关系\n\n在应用有 iframe 的页面时：\n\n- top 对象始终指向最上层窗口，即浏览器窗口本身\n- parent 对象则始终指向当前窗口的父窗口\n-  self 对象始终会指向 window\n\n如果没有使用 iframe 则都指向 window\n\n## 像素比\n\nCSS 像素是 Web 开发中使用的统一像素单位。\n\n这个单位的背后其实是一个角度：0.0213°。\n\n如果屏幕距离人眼是一臂长，则以这个角度计算的 CSS 像素大小约为 1/96 英寸，这样定义像素大小是为了在不同设备上统一标准。\n\n物理像素与 CSS 像素之间的转换比率由 `window.devicePixelRatio` 属性提供\n\n`window.devicePixelRatio` 实际上与 DPI 相对应，DPI 表示单位像素密度，`window.devicePixelRatio` 表示物理像素与逻辑像素之间的缩放系数\n\n## 窗口位置\n\n现代浏览器提供了 `screenLeft` 和 `screenTop` 属性，用于表示窗口相对于屏幕左侧和顶部的位置 ，返回值的单位是 CSS 像素。\n\n使用 `moveTo()` 和 `moveBy()` 方法可以移动窗口，\n\n## 窗口大小\n\n所有现代浏览器都支持 4 个属性：`innerWidth`、`innerHeight`、`outerWidth` 和 `outerHeight`。\n\n- `outerWidth` 和 `outerHeight` 返回浏览器窗口自身的大小\n- `innerWidth` 和 `innerHeight` 返回浏览器窗口中页面视口的大小\n\n`resizeTo()` 和 `resizeBy()` 方法可以调整窗口大小，缩放窗口的方法可能会被浏览器禁用，缩放窗口只能应用到最上层的 window 对象。\n\n## 视口位置\n\n度量文档相对于视口滚动距离的属性有两对，并且返回相同的值：\n\n- `window.pageXoffset`、`window.pageYoffset`\n- `window. scrollX`、`window.scrollY`\n\n使用 `scroll()`、`scrollTo()` 和 `scrollBy()` 方法可以滚动页面：\n\n1. `scroll` 和 `scrollTo` 相同\n2. 除了可以接受偏移距离，也可以接收一个 ScrollToOptions 字典参数\n   1. ScrollToOptions 对象具有 `left` 和 `top` 属性\n   2. ScrollToOptions 对象还具有 `behavior` 属性，描述滚动行为，取值 `auto` 和 `smooth`\n\n```javascript\n// 正常滚动\nwindow.scrollTo({\n  left: 100,\n  top: 100,\n  behavior: 'auto'\n})\n// 平滑滚动\nwindow.scrollTo({ \n  left: 100,\n  top: 100,\n  behavior: 'smooth'\n})\n```\n\n## 导航和新窗口\n\n`window.open()` 方法可以用于导航到指定 URL，也可以用于打开新浏览器窗口。\n\n该方法接收四个参数：URL、目标窗口名、特性字符串、替换当前页面\n\n### 窗口名\n\n如果第二个参数是一个已经存在的窗口或窗格(frame)的名字，则会在对应的窗口或窗格中打开 URL\n\n```javascript\n// 与\u003ca href=\"http://www.wrox.com\" target=\"topFrame\"/\u003e相同 \nwindow.open(\"http://www.wrox.com/\", \"topFrame\");\n```\n\n该参数也可以是一个特殊的窗口名，比如`_self`、 `_parent`、`_top` 或 `_blank`。\n\n### 窗口特性\n\n如果不是打开已有窗口，则会打开一个新窗口或标签页。\n\n1. 当特性字符串中至少包含 `width` 或 `height` 时则会打开一个新的窗口\n2. 如果打开的不是新窗口，则忽略该参数\n3. 特性字符串是一个逗号分隔的设置字符串，用于指定新窗口包含的特性\n\n|     参数      |       值       |                     说明                     |\n| :-----------: | :------------: | :------------------------------------------: |\n| height、width |     number     |       新窗口的高度和宽度，不能小于 100       |\n|   top、left   |     number     |       新窗口的 x、y 轴坐标，不能小于 0       |\n|   location    | 'yes' \\| 'no'  | 表示是否显示地址栏，不同浏览器的默认值不一样 |\n|    Menubar    | 'yes' \\| 'no'  |        表示是否显示菜单栏，默认为\"no\"        |\n|   resizable   | 'yes'  \\| 'no' |  表示是否可以拖动改变新窗口大小。默认为\"no\"  |\n|  scrollbars   | 'yes' \\| 'no'  |   表示是否可以在内容过长时滚动，默认为\"no\"   |\n|    status     | 'yes' \\| 'no'  | 表示是否显示状态栏，不同浏览器的默认值不一样 |\n|    toolbar    | 'yes' \\| 'no'  |        表示是否显示工具栏，默认为\"no\"        |\n\n```javascript\nwindow.open('https://xiefeng.tech', null, 'height=400,width=400')\n```\n\n### 窗口控制\n\n`window.open()` 方法返回一个对新建窗口的引用，这个对象与普通 window 对象没有区别，只是为控制新窗口提供了方便。\n\n某些浏览器默认不允许缩放或移动主窗口，但可能允许缩放或移动通过 `window.open()` 创建的窗口，比如 chrome\n\nChrome 下无法 resize 和 move 主窗口，也没有办法 close 主窗口，但是允许通过 open 返回的对象对新建窗口进行操作：\n\n1. 可以关闭新建窗口\n2. 非跨域情况可以正常 `resizeTo`、`moveTo` 操作\n\n新创建窗口的 window 对象的 opener 属性指向打开它的窗口：\n\n```javascript\nconst child = window.open('/index.html', null, `height=400,width=400`)\nconsole.log(child.opener === window)\t// true\n```\n\n现代浏览器都是多进程架构，每个标签页会运行在独立的进程中。\n\n如果一个标签页打开了另一个，window 对象可能需要跟另一个标签页通信，那么新的标签页不能运行在独立的进程中。\n\n将新打开标签页的 opener 设置为 null，表示新打开的标签页可以运行在独立的进程中，这个连接一旦切断就无法恢复。\n\n```javascript\nconst child = window.open('/index.html', null, `height=400,width=400`)\nchild.opener = null\n```\n\n## location\n\nlocation 对象提供了当前窗口中加载文档的信息，以及通常的导航功能\n\n### URL 信息\n\n- location.hash：URL 中的 hash 值，包括 `#`\n- location.host：主机名及端口号\n- location.hostname：主机名（域名）\n- location.href：当前加载页面的完整 URL，location 的 `toString()` 方法也返回这个值\n- location.port：URL 中的端口号，没有即为 `''`\n- location.protocol：页面使用的协议，通常是 `\"http:\"` 或 `\"https:\"`\n- location.search：URL 中的查询字符串，包括 `?`\n- location.origin：URL 的源地址，只读\n\n### 操作地址\n\n可以通过修改 location 对象修改浏览器的地址，除了 `location.origin` 其他的属性都可以修改从而改变当前的 URL\n\n使用 `location.assign` 方法会立即启动导航到新 URL 的操作，同时在浏览器历史记录中增加一条记录\n\n```javascript\n// 相同的效果\nlocation.assign('https://xiefeng.tech')\nlocation.href = 'https://xiefeng.tech'\nwindow.location = 'https://xiefeng.tech'\n```\n\n如果不希望增加历史记录，可以使用 `location.replace` 方法，使用该方法重新加载后不会增加历史记录\n\n```javascript\nlocation.replace('https://xiefeng.tech')\n```\n\n使用 `location.reload` 可以重新加载当前显示的页面，如果想强制从服务器重新加载页面，可以传递参数 true\n\n```javascript\nlocation.reload(); // 重新加载，可能是从缓存加载 \nlocation.reload(true); // 重新加载，从服务器加载\n```\n\n位于 `reload` 之后的代码可能执行也可能不执行，这取决于网络延迟和系统资源等因素，最好把 `reload` 作为最后一行代码。\n\n### URLSearchParams\n\nURLSearchParams 提供了一组标准 API 方法，通过它们可以检查和修改查询字符串：\n\n```javascript\nconst qs = '?q=javascript\u0026num=10'\n\nconst searchParams = new URLSearchParams(qs)\n\nconsole.log(searchParams.toString())\t// q=javascript\u0026num=10\n\nconsole.log(\n  searchParams.has('q'),\n  searchParams.get('q')\n)\t// true 'javascript'\n\nsearchParams.set('page', '10')\n\nsearchParams.delete('num')\n\nconsole.log(searchParams.toString())\t// q=javascript\u0026page=10\n```\n\n URLSearchParams 也实现了迭代器接口：\n\n```javascript\nfor (let param of searchParams) {\n  console.log(param);\n}\n// [\"q\", \"javascript\"]\n// [\"num\", \"10\"]\n```\n\n### URL 编码\n\nJavaScript 内置了一些进行 URL 编码和解码的函数\n\n- `escape`\n\n  - 不能直接用于URL编码，它的真正作用是返回一个字符的 Unicode 编码值\n  - 除了ASCII字母、数字、标点符号 @ * _ + - . / 以外，对其他所有字符进行编码\n  - 解码函数是 `unescape()`\n\n  ```javascript\n  escape('https://xiefeng.tech/Vue2的响应式原理.html')\n  // 'https%3A//xiefeng.tech/Vue2%u7684%u54CD%u5E94%u5F0F%u539F%u7406.html'\n  \n  unescape('https%3A//xiefeng.tech/Vue2%u7684%u54CD%u5E94%u5F0F%u539F%u7406.html')\n  // 'https://xiefeng.tech/Vue2的响应式原理.html'\n  ```\n\n- `encodeURI`\n\n  - 对整个URL进行编码，对 URL 中特殊的含义的符号 ; / ? : @ \u0026 = + $ , # 不进行编码\n  - 编码后输出为 utf-8 形式，并且在每个字节前加上%\n  - 对应的解码函数是 `decodeURI()`\n\n- `encodeURIComponent`\n\n  - 对URL的组成部分进行个别编码，; / ? : @ \u0026 = + $ , # 也会进行编码\n  - 编码方法和 `encodeURL` 相同\n  - 解码函数是 `decodeURIComponent()`\n\n## history\n\nhistory 对象表示当前窗口首次使用以来用户的导航历史记录，出于安全考虑，该对象不会暴露用户访问过的 URL， 但可以通过它在不知道实际 URL 的情况下前进和后退。\n\n### 导航\n\n`history.go` 可以在用户历史记录中沿任何方向导航，可以前进也可以后退：\n\n```javascript\nhistory.go(-1)\nhistory.go(1)\n```\n\n`history.go` 有两个简写方法：`history.back` 和 `history.forward`，这两个方法模拟了浏览器的后退按钮和前进按钮\n\n`history.length` 表示历史记录中有多个条目\n\n### 历史状态\n\nHTML5 为 history 对象增加了方便的状态管理特性，状态管理 API 可以让开发者改变浏览器 URL 而不会加载新页面。\n\n`history.pushState()` 方法接收 3 个参数：一个 state 对象、一个新状态的标题、一个相对 URL（可选）\n\n- 第一 个参数包含初始化页面状态所必需的信息，状态的对象大小通常在 500KB~1MB 以内\n- 第二个参数并未被当前实现所使用\n- 方法执行后，状态信息就会被推到历史记录中，浏览器地址栏也会改变以反映新的 URL\n\n通过 pushState 所添加的历史记录，在进行前进、后退操作时会触发 window 的 `popstate` 事件：\n\n```javascript\nwindow.addEventListener('popstate', e =\u003e {\n  console.log(e.state)\n})\n```\n\n页面初次加载时没有状态，因此后退到最初页面时，event.state 为 `null`\n\n可以通过 `history.state` 获取当前的状态对象，通过 `replaceState` 可以更新当前的状态，参数和 `pushState` 前两个参数相同","meta":{"size":10525,"birthTime":1663496641397.1501,"updateTime":1663496641397.3313}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["JavaScript","Web api","BOM"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
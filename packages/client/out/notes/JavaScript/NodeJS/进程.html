<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>进程 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#进程" data-target-id="h1-进程-0">进程</a><ul><li><a href="#信息" data-target-id="h2-信息-0">信息</a></li><li><a href="#事件" data-target-id="h2-事件-1">事件</a></li><li><a href="#方法" data-target-id="h2-方法-2">方法</a></li></ul></li><li><a href="#子进程" data-target-id="h1-子进程-1">子进程</a><ul><li><a href="#创建" data-target-id="h2-创建-3">创建</a></li><li><a href="#通信" data-target-id="h2-通信-4">通信</a></li><li><a href="#句柄传递" data-target-id="h2-句柄传递-5">句柄传递</a></li></ul></li><li><a href="#集群" data-target-id="h1-集群-2">集群</a><ul><li><a href="#工作原理" data-target-id="h2-工作原理-6">工作原理</a></li><li><a href="#功能" data-target-id="h2-功能-7">功能</a></li></ul></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">进程</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h1>进程</h1>
<p><code>process</code> 提供有关当前 Node.js 进程的信息并对其进行控制</p>
<h2>信息</h2>
<ul>
<li><code>argv</code>：返回启动 Node.js 进程时传入的命令行参数组成的数组</li>
<li><code>channel</code>：如果该进程是被创建的子进程，则该属性是对 IPC 通道的引用</li>
<li><code>env</code>：返回包含用户环境的对象</li>
<li><code>pid</code>：返回当前进程的进程 id</li>
<li><code>ppid</code>：返回父进程的 id</li>
</ul>
<h2>事件</h2>
<ul>
<li><code>message</code>：收到父进程通过 IPC 发送的消息时触发</li>
<li><code>unhandledRejection</code>：<code>Promise</code> 被拒绝并且在事件循环的一个轮询内没有添加错误句柄处理时触发</li>
<li><code>rejectionHandled</code>：每当 <code>Promise</code> 被拒绝并且错误句柄被附加时晚于一轮事件循环时触发</li>
<li><code>exit</code>：进程退出时触发，进程退出时机：<!-- -->
<ul>
<li><code>process.exit()</code> 方法被显式调用</li>
<li>事件循环不再需要执行任何额外的工作</li>
</ul>
</li>
</ul>
<h2>方法</h2>
<ul>
<li><code>exit</code>：指示 Node.js 以指定的退出状态同步终止进程，默认为 0 （成功）</li>
<li><code>cwd</code>：返回 Node.js 进程的当前工作目录</li>
<li><code>kill</code>：杀死指定 id 的进程，实际上只是一个信号发送者，就像 <code>kill</code> 系统调用一样</li>
</ul>
<h1>子进程</h1>
<p>通过 <code>child_process</code> 模块可以创建子进程，并可以通过 IPC 与子进程进行通信。</p>
<h2>创建</h2>
<p>异步创建方式：</p>
<ul>
<li><code>exec</code>：创建一个子进程（shell）执行命令，通过回调（子进程退出时调用）可以获取 shell 的输出</li>
<li><code>spawn</code>：创建一个子进程（shell）执行命令，但是没有回调去获取输出</li>
<li><code>execFile</code>：创建一个子进程执行可执行文件，如果是 js 文件则文件开头必须有 <code>#!/user/bin/env node</code></li>
<li><code>fork</code>：创建一个子进程执行 js 文件</li>
</ul>
<pre><code class="language-javascript">// exec
const child = exec(&#x27;node -v&#x27;,  (err, stdout, stderr) =&gt; console.log(stdout));

// spawn
const child = spawn(&#x27;node&#x27;, [&#x27;-v&#x27;]);
child.on(&#x27;spawn&#x27;, () =&gt; child.stdout.pipe(process.stdout));

// execFile
const child = execFile(&#x27;./worker.js&#x27;);

// fork
const child = fork(&#x27;./worker.js&#x27;);
</code></pre>
<h2>通信</h2>
<p>实现进程间通信的方式有很多，比如：管道、socket、信号量、共享内存、消息队列、Domain Socket等。</p>
<p>Node 实现 IPC 采用的管道（抽象层面的称呼），具体的细节由 libuv 实现：在 windows 下采用命名管道实现，而*nix系统则采用 Unix Domain Socket 实现。</p>
<p>对于上层的暴露的接口十分简单，通信方式只有 <code>send</code> 方法和 <code>message</code> 事件。</p>
<pre><code class="language-javascript">const worker = fork(join(__dirname, &#x27;./worker.js&#x27;));
// 子进程创建成功触发此事件
worker.on(&#x27;spawn&#x27;, () =&gt;  worker.send(&#x27;hello&#x27;));

// worker.js

console.log(&#x27;子进程启动成功, processID:&#x27;, process.pid);

process.on(&#x27;message&#x27;, msg =&gt;  console.log(&#x27;子进程收到消息:&#x27;, msg));
</code></pre>
<p>具体的过程：</p>
<ol>
<li>父进程在实际创建子进程之前，会先创建IPC通道并监听它，然后再真正的创建子进程。</li>
<li>通过环境变量 <code>NODE_CHANNEL_FD</code> 告知子进程 IPC 通道的文件描述符</li>
<li>子进程在启动过程中，根据文件描述符去连接该 IPC 通道</li>
</ol>
<pre><code class="language-mermaid">flowchart LR
process(父进程) --创建--&gt; child_process(子进程)
process(父进程) --监听/接收--&gt; IPC(IPC通道)
child_process(子进程) --连接--&gt; IPC(IPC通道)
</code></pre>
<p>异步创建的子进程会返回一个 <code>ChildProcess</code> 的实例，表示创建的子进程，通过该实例可以向 IPC 通道传递信息。</p>
<p><strong>事件：</strong></p>
<ul>
<li><code>spawn</code>：子进程创建成功触发</li>
<li><code>message</code>：收到子进程的消息触发</li>
<li><code>exit</code>：子进程退出触发</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li><code>send</code>：向子进程发送消息，会触发子进程的 <code>message</code> 事件</li>
<li><code>kill</code>：kill 该子进程，接着触发 <code>exit</code> 事件</li>
</ul>
<h2>句柄传递</h2>
<p><code>send</code> 方法除了可以发送一般的数据，还可以传递句柄（文件描述符）目前只支持传递 TCP 和 UDP 套接字。</p>
<p>利用 <code>send</code> 发送套接字即可实现多个子进程监听同一个端口：</p>
<pre><code class="language-javascript">// master.js
const server = createServer(socket =&gt; socket.end(&#x27;父进程处理请求&#x27;));

const workers = new Map();

for (let i = 0; i &lt; cpus().length; i++) {
    const worker = fork(&#x27;./worker.js&#x27;);
    workers.set(worker.pid, worker);
}

server.listen(8080, () =&gt; workers.forEach(w =&gt; w.send(&#x27;server&#x27;, server)));

// worker.js
process.on(&#x27;message&#x27;, (msg, server) =&gt; {
    if (msg === &#x27;server&#x27;) {
        server.on(&#x27;connection&#x27;, socket =&gt; socket.end(`子进程 ${process.pid} 处理请求`));
    }
});
</code></pre>
<p>当多个进程监听同一个端口，一个连接只能被一个进程所处理，目前仅在 Unix 平台上支持。</p>
<p><strong>句柄的发送和还原</strong></p>
<p>发送到 IPC 管道中的文件描述符（句柄），实际上就是一个整数值。</p>
<p>而发送的消息先会被封装成一个对象，接着会被 <code>JSON.stringify</code> 序列化：</p>
<pre><code class="language-json">{
    cmd: &quot;NODE_HANDLE&quot;,
    type: &quot;net.Server&quot;,
    msg: message
}
</code></pre>
<p>当子进程接收到父进程发来的消息，会先通过 <code>JSON.parse</code> 解析消息，然后触发 <code>message</code> 事件将消息传递上去。</p>
<pre><code class="language-mermaid">graph LR
process(父进程) --发送--&gt; 序列化 --写入--&gt;IPC((IPC)) -- 读取--&gt; 解析数据 --消息--&gt; child_process(子进程)
</code></pre>
<p>在这个过程中，如果消息对象的 <code>message.cmd</code> 以 <code>NODE_</code> 为前缀则会响应一个内部事件 <code>internalMessage</code>。</p>
<p>如果 <code>message.cmd</code> 的值为 <code>NODE_HANDLE</code>，则会依据 <code>message.type</code> 的值和文件描述符一起还原出一个对象。</p>
<p>具体的就是如果 <code>message.type</code> 值为 <code>net.Socket</code> 则会创建一个 TCP 服务器对象，并让该对象监听文件描述符。</p>
<p>我们在 <code>message</code> 事件处理程序中得到的 <code>handle</code> 就是这个新创建的 <code>net.Server</code> 对象。</p>
<pre><code class="language-javascript">// 伪代码
const server = new net.Server();
server.listen(fd);
</code></pre>
<p>而多个应用监听相同的端口时，文件描述符同一时间只能被一个进程所使用，所以当来请求时只有一个进程能够幸运的抢到连接。</p>
<h1>集群</h1>
<p><code>cluster</code> 模块可以创建共享服务器端口的子进程，使用 <code>child_process</code> 构建集群比较麻烦需要解决许多问题。</p>
<pre><code class="language-javascript">const cluster = require(&#x27;cluster&#x27;);
const http = require(&#x27;http&#x27;);
const count = require(&#x27;os&#x27;).cpus().length;

if (cluster.isMaster) {
    // 衍生工作进程。
    for (let i = 0; i &lt; count; i++) {
        cluster.fork();
    }
} else {
    console.log(`工作进程 ${process.pid} 已启动`);
    // 工作进程可以共享任何 TCP 连接。
    // 在本例子中，共享的是 HTTP 服务器。
    http.createServer((_, res) =&gt; res.end(`工作进程 ${process.pid} 处理请求`)).listen(8000);
}
</code></pre>
<h2>工作原理</h2>
<p><code>cluster</code> 模块就是 <code>child_process</code> 和 <code>net</code> 的组合应用。</p>
<p>当 <code>culster</code> 启动时会在内部启动 TCP 服务器，父进程会将 TCP 的 socket 发送给子进程。</p>
<p>通过 <code>culster.fork</code> 出来的子进程存在环境变量 <code>NODE_UNIQUE_ID</code>，只要子进程中使用了 <code>listen</code> 就会通过文件描述符重用端口。</p>
<p><a href="https://cnodejs.org/topic/56e84480833b7c8a0492e20c">cluster 实现原理</a></p>
<h2>功能</h2>
<p>事件：</p>
<ul>
<li>
<p><code>message</code>：当集群主进程从任何工作进程接收到消息时触发</p>
</li>
<li>
<p><code>online</code>：当衍生一个新的工作进程后，工作进程应当响应一个上线消息</p>
</li>
<li>
<p><code>exit</code>：当任何一个工作进程关闭的时候，cluster 模块都将会触发 <code>&#x27;exit&#x27;</code> 事件</p>
</li>
</ul>
<p>方法：</p>
<ul>
<li><code>setupMaster</code>：用于修改默认的 &#x27;fork&#x27; 行为，只能主进程调用</li>
<li><code>fork</code>：衍生出一个新的工作进程，只能主进程调用</li>
</ul>
<p>可以通过 <code>setupMaster</code> 方法将主进程和子进程在代码上分开。</p>
<pre><code class="language-javascript">const { setupMaster, fork } = require(&#x27;cluster&#x27;);
const cpus = require(&#x27;os&#x27;).cpus().length;
setupMaster({
    exec: &#x27;worker.js&#x27;
});
for (let i = 0; i &lt; cpus; i++) {
    fork();
}
</code></pre><div><a href="/notes/JavaScript/NodeJS">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"进程","article":{"title":"进程","content":"# 进程\r\n\r\n`process` 提供有关当前 Node.js 进程的信息并对其进行控制\r\n\r\n## 信息\r\n\r\n- `argv`：返回启动 Node.js 进程时传入的命令行参数组成的数组\r\n- `channel`：如果该进程是被创建的子进程，则该属性是对 IPC 通道的引用\r\n- `env`：返回包含用户环境的对象\r\n- `pid`：返回当前进程的进程 id\r\n- `ppid`：返回父进程的 id\r\n\r\n## 事件\r\n\r\n- `message`：收到父进程通过 IPC 发送的消息时触发\r\n- `unhandledRejection`：`Promise` 被拒绝并且在事件循环的一个轮询内没有添加错误句柄处理时触发\r\n- `rejectionHandled`：每当 `Promise` 被拒绝并且错误句柄被附加时晚于一轮事件循环时触发\r\n- `exit`：进程退出时触发，进程退出时机：\r\n\t-  `process.exit()` 方法被显式调用\r\n\t- 事件循环不再需要执行任何额外的工作\r\n\r\n## 方法\r\n\r\n- `exit`：指示 Node.js 以指定的退出状态同步终止进程，默认为 0 （成功）\r\n- `cwd`：返回 Node.js 进程的当前工作目录\r\n- `kill`：杀死指定 id 的进程，实际上只是一个信号发送者，就像 `kill` 系统调用一样\r\n\r\n# 子进程\r\n\r\n通过 `child_process` 模块可以创建子进程，并可以通过 IPC 与子进程进行通信。\r\n\r\n## 创建\r\n\r\n异步创建方式：\r\n\r\n- `exec`：创建一个子进程（shell）执行命令，通过回调（子进程退出时调用）可以获取 shell 的输出\r\n- `spawn`：创建一个子进程（shell）执行命令，但是没有回调去获取输出\r\n- `execFile`：创建一个子进程执行可执行文件，如果是 js 文件则文件开头必须有 `#!/user/bin/env node` \r\n- `fork`：创建一个子进程执行 js 文件\r\n\r\n```javascript\r\n// exec\r\nconst child = exec('node -v',  (err, stdout, stderr) =\u003e console.log(stdout));\r\n\r\n// spawn\r\nconst child = spawn('node', ['-v']);\r\nchild.on('spawn', () =\u003e child.stdout.pipe(process.stdout));\r\n\r\n// execFile\r\nconst child = execFile('./worker.js');\r\n\r\n// fork\r\nconst child = fork('./worker.js');\r\n```\r\n\r\n## 通信\r\n\r\n实现进程间通信的方式有很多，比如：管道、socket、信号量、共享内存、消息队列、Domain Socket等。\r\n\r\nNode 实现 IPC 采用的管道（抽象层面的称呼），具体的细节由 libuv 实现：在 windows 下采用命名管道实现，而*nix系统则采用 Unix Domain Socket 实现。\r\n\r\n对于上层的暴露的接口十分简单，通信方式只有 `send` 方法和 `message` 事件。\r\n\r\n```javascript\r\nconst worker = fork(join(__dirname, './worker.js'));\r\n// 子进程创建成功触发此事件\r\nworker.on('spawn', () =\u003e  worker.send('hello'));\r\n\r\n// worker.js\r\n\r\nconsole.log('子进程启动成功, processID:', process.pid);\r\n\r\nprocess.on('message', msg =\u003e  console.log('子进程收到消息:', msg));\r\n```\r\n\r\n具体的过程：\r\n\r\n1. 父进程在实际创建子进程之前，会先创建IPC通道并监听它，然后再真正的创建子进程。\r\n2. 通过环境变量 `NODE_CHANNEL_FD` 告知子进程 IPC 通道的文件描述符\r\n3. 子进程在启动过程中，根据文件描述符去连接该 IPC 通道\r\n\r\n```mermaid\r\nflowchart LR\r\nprocess(父进程) --创建--\u003e child_process(子进程)\r\nprocess(父进程) --监听/接收--\u003e IPC(IPC通道)\r\nchild_process(子进程) --连接--\u003e IPC(IPC通道)\r\n```\r\n\r\n异步创建的子进程会返回一个 `ChildProcess` 的实例，表示创建的子进程，通过该实例可以向 IPC 通道传递信息。\r\n\r\n**事件：**\r\n\r\n- `spawn`：子进程创建成功触发\r\n- `message`：收到子进程的消息触发\r\n- `exit`：子进程退出触发\r\n\r\n**方法：**\r\n\r\n- `send`：向子进程发送消息，会触发子进程的 `message` 事件\r\n- `kill`：kill 该子进程，接着触发 `exit` 事件\r\n\r\n## 句柄传递\r\n\r\n`send` 方法除了可以发送一般的数据，还可以传递句柄（文件描述符）目前只支持传递 TCP 和 UDP 套接字。\r\n\r\n利用 `send` 发送套接字即可实现多个子进程监听同一个端口：\r\n\r\n```javascript\r\n// master.js\r\nconst server = createServer(socket =\u003e socket.end('父进程处理请求'));\r\n\r\nconst workers = new Map();\r\n\r\nfor (let i = 0; i \u003c cpus().length; i++) {\r\n    const worker = fork('./worker.js');\r\n    workers.set(worker.pid, worker);\r\n}\r\n\r\nserver.listen(8080, () =\u003e workers.forEach(w =\u003e w.send('server', server)));\r\n\r\n// worker.js\r\nprocess.on('message', (msg, server) =\u003e {\r\n    if (msg === 'server') {\r\n        server.on('connection', socket =\u003e socket.end(`子进程 ${process.pid} 处理请求`));\r\n    }\r\n});\r\n```\r\n\r\n当多个进程监听同一个端口，一个连接只能被一个进程所处理，目前仅在 Unix 平台上支持。\r\n\r\n**句柄的发送和还原**\r\n\r\n发送到 IPC 管道中的文件描述符（句柄），实际上就是一个整数值。\r\n\r\n而发送的消息先会被封装成一个对象，接着会被 `JSON.stringify` 序列化：\r\n\r\n```json\r\n{\r\n    cmd: \"NODE_HANDLE\",\r\n    type: \"net.Server\",\r\n    msg: message\r\n}\r\n```\r\n\r\n当子进程接收到父进程发来的消息，会先通过 `JSON.parse` 解析消息，然后触发 `message` 事件将消息传递上去。\r\n\r\n```mermaid\r\ngraph LR\r\nprocess(父进程) --发送--\u003e 序列化 --写入--\u003eIPC((IPC)) -- 读取--\u003e 解析数据 --消息--\u003e child_process(子进程)\r\n```\r\n\r\n在这个过程中，如果消息对象的 `message.cmd` 以 `NODE_` 为前缀则会响应一个内部事件 `internalMessage`。\r\n\r\n如果 `message.cmd` 的值为 `NODE_HANDLE`，则会依据 `message.type` 的值和文件描述符一起还原出一个对象。\r\n\r\n具体的就是如果 `message.type` 值为 `net.Socket` 则会创建一个 TCP 服务器对象，并让该对象监听文件描述符。\r\n\r\n我们在 `message` 事件处理程序中得到的 `handle` 就是这个新创建的 `net.Server` 对象。\r\n\r\n```javascript\r\n// 伪代码\r\nconst server = new net.Server();\r\nserver.listen(fd);\r\n```\r\n\r\n而多个应用监听相同的端口时，文件描述符同一时间只能被一个进程所使用，所以当来请求时只有一个进程能够幸运的抢到连接。\r\n\r\n# 集群\r\n\r\n`cluster` 模块可以创建共享服务器端口的子进程，使用 `child_process` 构建集群比较麻烦需要解决许多问题。\r\n\r\n```javascript\r\nconst cluster = require('cluster');\r\nconst http = require('http');\r\nconst count = require('os').cpus().length;\r\n\r\nif (cluster.isMaster) {\r\n    // 衍生工作进程。\r\n    for (let i = 0; i \u003c count; i++) {\r\n        cluster.fork();\r\n    }\r\n} else {\r\n    console.log(`工作进程 ${process.pid} 已启动`);\r\n    // 工作进程可以共享任何 TCP 连接。\r\n    // 在本例子中，共享的是 HTTP 服务器。\r\n    http.createServer((_, res) =\u003e res.end(`工作进程 ${process.pid} 处理请求`)).listen(8000);\r\n}\r\n```\r\n\r\n## 工作原理\r\n\r\n`cluster` 模块就是 `child_process` 和 `net` 的组合应用。\r\n\r\n当 `culster` 启动时会在内部启动 TCP 服务器，父进程会将 TCP 的 socket 发送给子进程。\r\n\r\n通过 `culster.fork` 出来的子进程存在环境变量 `NODE_UNIQUE_ID`，只要子进程中使用了 `listen` 就会通过文件描述符重用端口。\r\n\r\n[cluster 实现原理](https://cnodejs.org/topic/56e84480833b7c8a0492e20c)\r\n\r\n## 功能\r\n\r\n事件：\r\n\r\n- `message`：当集群主进程从任何工作进程接收到消息时触发\r\n- `online`：当衍生一个新的工作进程后，工作进程应当响应一个上线消息\r\n\r\n- `exit`：当任何一个工作进程关闭的时候，cluster 模块都将会触发 `'exit'` 事件\r\n\r\n方法：\r\n\r\n- `setupMaster`：用于修改默认的 'fork' 行为，只能主进程调用\r\n- `fork`：衍生出一个新的工作进程，只能主进程调用\r\n\r\n可以通过 `setupMaster` 方法将主进程和子进程在代码上分开。\r\n\r\n```javascript\r\nconst { setupMaster, fork } = require('cluster');\r\nconst cpus = require('os').cpus().length;\r\nsetupMaster({\r\n    exec: 'worker.js'\r\n});\r\nfor (let i = 0; i \u003c cpus; i++) {\r\n    fork();\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","meta":{"size":7989,"birthTime":1663496641396.0278,"updateTime":1663496641396.124}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["JavaScript","NodeJS","进程"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
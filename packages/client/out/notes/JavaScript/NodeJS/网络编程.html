<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>网络编程 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#TCP" data-target-id="h1-TCP-0">TCP</a><ul><li><a href="#服务端" data-target-id="h2-服务端-0">服务端</a></li><li><a href="#客户端" data-target-id="h2-客户端-1">客户端</a></li></ul></li><li><a href="#UDP" data-target-id="h1-UDP-1">UDP</a></li><li><a href="#HTTP" data-target-id="h1-HTTP-2">HTTP</a><ul><li><a href="#服务器" data-target-id="h2-服务器-2">服务器</a></li><li><a href="#客户端请求" data-target-id="h2-客户端请求-3">客户端请求</a></li><li><a href="#代理" data-target-id="h2-代理-4">代理</a></li></ul></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">网络编程</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h1>TCP</h1>
<p><code>net</code> 模块用于创建基于流的 TCP 或 IPC 的服务器与客户端。</p>
<h2>服务端</h2>
<p>服务端对应的实例是 <code>net.Server</code> 类型，创建方式：</p>
<ul>
<li><code>new net.Server</code></li>
<li><code>net.createServer</code></li>
</ul>
<pre><code class="language-javascript">const net = require(&#x27;net&#x27;);

// 传入的回调对应的是 connection 事件对应的处理函数
// 可以不传递，通过 connection 事件绑定
const server = net.createServer(socket =&gt; {
  socket.on(&#x27;data&#x27;, data =&gt; socket.write(data));
  socket.on(&#x27;end&#x27;, () =&gt; console.log(&#x27;连接已经断开&#x27;));
  socket.write(&#x27;已连接&#x27;);
});

server.listen(9527, () =&gt; console.log(&#x27;server is listening 9527&#x27;));
</code></pre>
<p><code>net.Server</code> 的事件：</p>
<ul>
<li><code>close</code>：当服务器关闭的时候触发， 如果有连接存在，直到所有的连接结束才会触发这个事件</li>
<li><code>connection</code>：当一个新的连接建立的时候触发，参数为 <code>net.Socket</code> 实例，对应的是客户端套接字</li>
<li><code>error</code>：当错误出现的时候触发，<code>&#x27;close&#x27;</code> 事件不会在这之后继续触发，除非手动调用 <code>close</code> 方法</li>
<li><code>listening</code>：当调用 <code>listen</code> 方法监听端口之后触发</li>
</ul>
<p><code>net.Server</code> 的一些方法：</p>
<ul>
<li><code>close</code>：阻止服务器接受新的连接并保持现有的连接，在所有连接结束后触发 <code>&#x27;close&#x27;</code> 事件</li>
<li><code>listen</code>：启动服务器来监听连接</li>
<li><code>getConnections</code>：异步的获取连接的客户端数量，回调函数的参数是 <code>err</code> 和 <code>count</code></li>
</ul>
<h2>客户端</h2>
<p>客户端对应的实例是 <code>net.Socket</code> 类型，继承自 <code>stream.Duplex</code>，创建方式：</p>
<ol>
<li><code>new net.Socket</code></li>
<li><code>net.createConnection</code></li>
<li><code>net.connect</code></li>
<li><code>net.Server</code> 的 <code>&#x27;connection&#x27;</code> 事件处理中的参数，由 Node.js 创建</li>
</ol>
<p><code>net.createConnect</code> 和 <code>net.connect</code> 方法都会先创建 <code>net.Socket</code> 实例并立即调用 <code>connect()</code> 方法初始化连接</p>
<pre><code class="language-javascript">const net = require(&#x27;net&#x27;);

const client = net.connect(9527);

client.on(&#x27;connect&#x27;, () =&gt; {
    console.log(&#x27;已连接到服务器&#x27;);
    client.write(&#x27;hello&#x27;);
});

client.on(&#x27;data&#x27;, data =&gt; {
    console.log(&#x27;接收到服务器数据&#x27;, data);
    client.write(data);
});

client.on(&#x27;end&#x27;, () =&gt; console.log(&#x27;连接已经断开&#x27;));
</code></pre>
<p><code>net.Socket</code> 的事件类型：</p>
<ul>
<li><code>connect</code>：当和服务器的连接成功建立时触发</li>
<li><code>data</code>：当接收到数据的时触发该事件，通过 <code>socket.setEncoding()</code> 可设置数据的编码</li>
<li><code>drain</code>：当写入缓冲区变为空时触发，可以用来做上传节流</li>
<li><code>end</code>：当服务端发送一个 FIN 包的时候触发</li>
<li><code>error</code>：当错误发生时触发，<code>&#x27;close&#x27;</code> 事件也会紧接着该事件被触发</li>
</ul>
<p><code>net.Socket</code> 的一些方法：</p>
<ul>
<li><code>connect</code>：给当前的套接字启动连接</li>
<li><code>write</code>：如果全部数据进入内核的缓冲区返回 <code>true</code>，当缓冲再次空闲的时候触发 <code>&#x27;drain&#x27;</code> 事件</li>
<li><code>setEncoding</code>：设置可读流的编码</li>
<li><code>setKeepAlive</code>：启用/禁用长连接功能</li>
</ul>
<h1>UDP</h1>
<p><code>dgram</code> 模块提供了 UDP 套接字的实现：<code>dgram.Socket</code> 类型实例。</p>
<p>不同于 TCP 需要为每一个连接创建一个套接字，一个 UDP 套接字可以和多个 UDP 服务器通信，UDP 套接字一旦创建，既可以作为客户端，也可以作为服务端。</p>
<p>通过 <code>dgram.createSocket</code> 可以创建 UDP 套接字：</p>
<pre><code class="language-javascript">const dgram = require(&#x27;dgram&#x27;);

// 可以传递第二个参数（一个回调），对应于 message 事件处理函数
const server = dgram.createSocket(&#x27;udp4&#x27;);

server.on(&#x27;message&#x27;, (msg, rinfo) =&gt; {
    console.log(&#x27;server get&#x27;, msg.toString(&#x27;utf-8&#x27;), &#x27;from&#x27;, rinfo.address, &#x27;:&#x27;, rinfo.port);
});

server.on(&#x27;listening&#x27;, () =&gt; {
    console.log(&#x27;server listening&#x27;, server.address.address, &#x27;:&#x27;, server.address.port);
});

// 开始监听端口
server.bind(8080);
</code></pre>
<p><code>dgram.Socket</code> 事件：</p>
<ul>
<li>
<p><code>message</code>：当接收到新的数据包时触发，<code>msg</code> 和 <code>rinfo</code> 会作为参数传递到该事件的处理函数中</p>
</li>
<li>
<p><code>close</code>：在调用 <code>close()</code> 关闭套接字之后触发， 该事件触发之后不会再触发新的 <code>&#x27;message&#x27;</code> 事件</p>
</li>
<li>
<p><code>connect</code>：调用 <code>connect()</code> 方法而使 socket 与远程地址关联之后触发</p>
</li>
<li>
<p><code>error</code>：当有任何错误发生时触发，事件处理函数仅会接收到一个 <code>Error</code> 对象</p>
</li>
<li>
<p><code>listening</code>：当套接字可被寻址且可接收数据时触发，发生在显式地使用 <code>socket.bind()</code>、隐式的使用 <code>socket.send()</code> 第一次发送数据</p>
</li>
</ul>
<p><code>dgram.Socket</code> 一些方法：</p>
<ul>
<li><code>bind</code>：在指定的 <code>port</code> 和可选的 <code>address</code> 上监听数据包信息</li>
<li><code>send</code>：发送数据包，对于无连接的 socket，必须指定目标的 <code>port</code> 和 <code>address</code>；对于连接的 socket，则将会使用其关联的远程端点</li>
<li><code>close</code>：关闭该 socket 并停止监听，如果提供了一个回调函数，它就相当于为 <code>&#x27;close&#x27;</code> 事件添加了一个监听器</li>
<li><code>connect</code>：为 <code>dgram.Socket</code> 关联一个远程地址和端口，这个 socket 句柄发送的任何消息都会被发送到关联的远程地址</li>
<li><code>disconnect</code>：将相连的 <code>dgram.Socket</code> 与远程地址断掉</li>
</ul>
<h1>HTTP</h1>
<p><code>http</code> 模块可以方便的创建 http 服务器和客户端</p>
<h2>服务器</h2>
<p>通过 <code>http.createServer</code> 方法创建 HTTP 服务器，返回一个 <code>http.Server</code> 实例。</p>
<p>每当有 HTTP 请求到来都会触发 <code>request</code> 事件，<code>createServer</code> 方法可以传递一个回调自动注册 <code>requset</code> 事件：</p>
<pre><code class="language-javascript">const http = require(&#x27;http&#x27;);

const server = http.createServer((request, response) =&gt; {
    request.pipe(response);
});

server.listen(8080);
</code></pre>
<p><code>request</code> 事件的处理函数接收两个参数：<code>requset</code>、<code>response</code>，分别为 <code>http.IncomingMessage</code> 和 <code>http.ServerResponse</code> 实例</p>
<p>请求和响应对象分别为可读、可写流，请求体可能很大需要通过流的方式读取，而请求头可以直接通过 <code>request.headers</code> 获取。</p>
<p><code>http.Server</code> 一些事件：</p>
<ul>
<li>
<p><code>connection</code>：当建立新的 TCP 连接时会触发此事件，一般用于手动触发该事件并注入 TCP socket</p>
</li>
<li>
<p><code>request</code>：每次有请求时触发</p>
</li>
<li>
<p><code>close</code>：服务器关闭时触发</p>
</li>
</ul>
<p><code>http.Server</code> 一些方法：</p>
<ul>
<li>
<p><code>listen</code>：启动服务器监听某个端口</p>
</li>
<li>
<p><code>close</code>：关闭服务器</p>
</li>
</ul>
<h2>客户端请求</h2>
<p>通过 <code>http.request</code> 创建 <code>http.ClientRequest</code> 实例（<code>ClientRequest</code> 继承自可写流），该对象可以作为客户端发起 HTTP 请求。</p>
<p>通过监听 <code>response</code> 事件即可获取服务器的返回，使用 <code>http.request</code> 函数传递的回调会自动注册为 <code>response</code> 事件处理函数。</p>
<pre><code class="language-javascript">const http = require(&#x27;http&#x27;);

const req = http.request(&#x27;http://localhost:8080&#x27;, resp =&gt; {
  resp.pipe(process.stdout);
});

req.write(&#x27;xxxx&#x27;);

req.end();
</code></pre>
<p><code>response</code> 事件处理函数接收一个 <code>http.IncomingMessage</code> 类型参数，是一个可读流。</p>
<p><code>http.ClientRequest</code> 一些方法：</p>
<ul>
<li><code>end</code>：完成发送请求， 如果正文的任何部分未发送，则会将它们刷新到流中。</li>
<li><code>write</code>：发送一块正文，和 <code>net.Socket</code> 的 <code>write</code> 方法相同</li>
<li><code>setHeader</code>：设置单个请求头的值</li>
</ul>
<h2>代理</h2>
<p>http 模块包含一个默认的代理对象 <code>http.globalAgent</code>，它会对与每个服务器（host+port）的连接进行管理。</p>
<p>默认通过 <code>http.request</code> 对同一个服务器发起的 HTTP 请求会被限制在 5 个，和浏览器对同一域名下的连接限制相同。</p>
<p>每一个 <code>http.request</code> 默认都会创建一个 TCP 连接，代理所做的事就是将对同一个服务器的请求 TCP 连接限制在 5 个，多余的请求复用 TCP 连接。</p>
<p>本质上就是代理维护一个待处理请求队列，为每个请求重用单个套接字连接，直到队列为空。套接字要么被销毁，要么放入池中， 是销毁还是池化取决于 <code>keepAlive</code> 或者说 TCP 连接是否断开。</p>
<p>由于实际上在对相同的服务器请求时最多只有5个请求在并发执行，如果需要改变限制有两种方法：</p>
<ol>
<li>
<p>针对请求不采用默认的全局代理对象，使用自己构造的代理对象</p>
<pre><code class="language-javascript">const http = require(&#x27;http&#x27;);

const maxSockets = 10;

const agent = new http.Agent({ maxSockets});

const client = http.request({
    agent,
    port: 8080,
});
</code></pre>
</li>
<li>
<p>不使用代理，脱离连接池的管理</p>
<pre><code class="language-javascript">const client = http.request({
    agent: false,
    port: 8080,
});
</code></pre>
</li>
</ol><div><a href="/notes/JavaScript/NodeJS">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"网络编程","article":{"title":"网络编程","content":"# TCP\r\n\r\n`net` 模块用于创建基于流的 TCP 或 IPC 的服务器与客户端。\r\n\r\n## 服务端\r\n\r\n服务端对应的实例是 `net.Server` 类型，创建方式：\r\n\r\n- `new net.Server`\r\n- `net.createServer`\r\n\r\n```javascript\r\nconst net = require('net');\r\n\r\n// 传入的回调对应的是 connection 事件对应的处理函数\r\n// 可以不传递，通过 connection 事件绑定\r\nconst server = net.createServer(socket =\u003e {\r\n  socket.on('data', data =\u003e socket.write(data));\r\n  socket.on('end', () =\u003e console.log('连接已经断开'));\r\n  socket.write('已连接');\r\n});\r\n\r\nserver.listen(9527, () =\u003e console.log('server is listening 9527'));\r\n```\r\n\r\n`net.Server` 的事件：\r\n\r\n- `close`：当服务器关闭的时候触发， 如果有连接存在，直到所有的连接结束才会触发这个事件\r\n- `connection`：当一个新的连接建立的时候触发，参数为 `net.Socket` 实例，对应的是客户端套接字\r\n- `error`：当错误出现的时候触发，`'close'` 事件不会在这之后继续触发，除非手动调用 `close` 方法\r\n- `listening`：当调用 `listen` 方法监听端口之后触发\r\n\r\n`net.Server` 的一些方法：\r\n\r\n- `close`：阻止服务器接受新的连接并保持现有的连接，在所有连接结束后触发 `'close'` 事件 \r\n- `listen`：启动服务器来监听连接\r\n- `getConnections`：异步的获取连接的客户端数量，回调函数的参数是 `err` 和 `count`\r\n\r\n## 客户端\r\n\r\n客户端对应的实例是 `net.Socket` 类型，继承自 `stream.Duplex`，创建方式：\r\n\r\n1. `new net.Socket`\r\n2. `net.createConnection`\r\n3. `net.connect`\r\n4. `net.Server` 的 `'connection'` 事件处理中的参数，由 Node.js 创建\r\n\r\n`net.createConnect` 和 `net.connect` 方法都会先创建 `net.Socket` 实例并立即调用 `connect()` 方法初始化连接\r\n\r\n```javascript\r\nconst net = require('net');\r\n\r\nconst client = net.connect(9527);\r\n\r\nclient.on('connect', () =\u003e {\r\n    console.log('已连接到服务器');\r\n    client.write('hello');\r\n});\r\n\r\nclient.on('data', data =\u003e {\r\n    console.log('接收到服务器数据', data);\r\n    client.write(data);\r\n});\r\n\r\nclient.on('end', () =\u003e console.log('连接已经断开'));\r\n```\r\n\r\n`net.Socket` 的事件类型：\r\n\r\n- `connect`：当和服务器的连接成功建立时触发\r\n- `data`：当接收到数据的时触发该事件，通过 `socket.setEncoding()` 可设置数据的编码\r\n- `drain`：当写入缓冲区变为空时触发，可以用来做上传节流\r\n- `end`：当服务端发送一个 FIN 包的时候触发\r\n- `error`：当错误发生时触发，`'close'` 事件也会紧接着该事件被触发\r\n\r\n`net.Socket` 的一些方法：\r\n\r\n- `connect`：给当前的套接字启动连接\r\n- `write`：如果全部数据进入内核的缓冲区返回 `true`，当缓冲再次空闲的时候触发 `'drain'` 事件\r\n- `setEncoding`：设置可读流的编码\r\n- `setKeepAlive`：启用/禁用长连接功能\r\n\r\n# UDP\r\n\r\n`dgram` 模块提供了 UDP 套接字的实现：`dgram.Socket` 类型实例。\r\n\r\n不同于 TCP 需要为每一个连接创建一个套接字，一个 UDP 套接字可以和多个 UDP 服务器通信，UDP 套接字一旦创建，既可以作为客户端，也可以作为服务端。\r\n\r\n通过 `dgram.createSocket` 可以创建 UDP 套接字：\r\n\r\n```javascript\r\nconst dgram = require('dgram');\r\n\r\n// 可以传递第二个参数（一个回调），对应于 message 事件处理函数\r\nconst server = dgram.createSocket('udp4');\r\n\r\nserver.on('message', (msg, rinfo) =\u003e {\r\n    console.log('server get', msg.toString('utf-8'), 'from', rinfo.address, ':', rinfo.port);\r\n});\r\n\r\nserver.on('listening', () =\u003e {\r\n    console.log('server listening', server.address.address, ':', server.address.port);\r\n});\r\n\r\n// 开始监听端口\r\nserver.bind(8080);\r\n```\r\n\r\n`dgram.Socket` 事件：\r\n\r\n- `message`：当接收到新的数据包时触发，`msg` 和 `rinfo` 会作为参数传递到该事件的处理函数中\r\n\r\n- `close`：在调用 `close()` 关闭套接字之后触发， 该事件触发之后不会再触发新的 `'message'` 事件\r\n- `connect`：调用 `connect()` 方法而使 socket 与远程地址关联之后触发\r\n- `error`：当有任何错误发生时触发，事件处理函数仅会接收到一个 `Error` 对象\r\n- `listening`：当套接字可被寻址且可接收数据时触发，发生在显式地使用 `socket.bind()`、隐式的使用 `socket.send()` 第一次发送数据\r\n\r\n`dgram.Socket` 一些方法：\r\n\r\n- `bind`：在指定的 `port` 和可选的 `address` 上监听数据包信息\r\n- `send`：发送数据包，对于无连接的 socket，必须指定目标的 `port` 和 `address`；对于连接的 socket，则将会使用其关联的远程端点\r\n- `close`：关闭该 socket 并停止监听，如果提供了一个回调函数，它就相当于为 `'close'` 事件添加了一个监听器\r\n- `connect`：为 `dgram.Socket` 关联一个远程地址和端口，这个 socket 句柄发送的任何消息都会被发送到关联的远程地址\r\n- `disconnect`：将相连的 `dgram.Socket` 与远程地址断掉\r\n\r\n# HTTP\r\n\r\n`http` 模块可以方便的创建 http 服务器和客户端\r\n\r\n\r\n## 服务器\r\n\r\n通过 `http.createServer` 方法创建 HTTP 服务器，返回一个 `http.Server` 实例。\r\n\r\n每当有 HTTP 请求到来都会触发 `request` 事件，`createServer` 方法可以传递一个回调自动注册 `requset` 事件：\r\n\r\n```javascript\r\nconst http = require('http');\r\n\r\nconst server = http.createServer((request, response) =\u003e {\r\n    request.pipe(response);\r\n});\r\n\r\nserver.listen(8080);\r\n```\r\n\r\n`request` 事件的处理函数接收两个参数：`requset`、`response`，分别为 `http.IncomingMessage` 和 `http.ServerResponse` 实例\r\n\r\n请求和响应对象分别为可读、可写流，请求体可能很大需要通过流的方式读取，而请求头可以直接通过 `request.headers` 获取。\r\n\r\n`http.Server` 一些事件：\r\n\r\n- `connection`：当建立新的 TCP 连接时会触发此事件，一般用于手动触发该事件并注入 TCP socket\r\n- `request`：每次有请求时触发\r\n\r\n- `close`：服务器关闭时触发\r\n\r\n`http.Server` 一些方法：\r\n\r\n- `listen`：启动服务器监听某个端口\r\n\r\n- `close`：关闭服务器\r\n\r\n## 客户端请求\r\n\r\n通过 `http.request` 创建 `http.ClientRequest` 实例（`ClientRequest` 继承自可写流），该对象可以作为客户端发起 HTTP 请求。\r\n\r\n通过监听 `response` 事件即可获取服务器的返回，使用 `http.request` 函数传递的回调会自动注册为 `response` 事件处理函数。\r\n\r\n```javascript\r\nconst http = require('http');\r\n\r\nconst req = http.request('http://localhost:8080', resp =\u003e {\r\n  resp.pipe(process.stdout);\r\n});\r\n\r\nreq.write('xxxx');\r\n\r\nreq.end();\r\n```\r\n\r\n`response` 事件处理函数接收一个 `http.IncomingMessage` 类型参数，是一个可读流。\r\n\r\n`http.ClientRequest` 一些方法：\r\n\r\n- `end`：完成发送请求， 如果正文的任何部分未发送，则会将它们刷新到流中。\r\n- `write`：发送一块正文，和 `net.Socket` 的 `write` 方法相同\r\n- `setHeader`：设置单个请求头的值\r\n\r\n## 代理\r\n\r\nhttp 模块包含一个默认的代理对象 `http.globalAgent`，它会对与每个服务器（host+port）的连接进行管理。\r\n\r\n默认通过 `http.request` 对同一个服务器发起的 HTTP 请求会被限制在 5 个，和浏览器对同一域名下的连接限制相同。\r\n\r\n每一个 `http.request` 默认都会创建一个 TCP 连接，代理所做的事就是将对同一个服务器的请求 TCP 连接限制在 5 个，多余的请求复用 TCP 连接。\r\n\r\n本质上就是代理维护一个待处理请求队列，为每个请求重用单个套接字连接，直到队列为空。套接字要么被销毁，要么放入池中， 是销毁还是池化取决于 `keepAlive` 或者说 TCP 连接是否断开。\r\n\r\n由于实际上在对相同的服务器请求时最多只有5个请求在并发执行，如果需要改变限制有两种方法：\r\n\r\n1. 针对请求不采用默认的全局代理对象，使用自己构造的代理对象\r\n\r\n\t```javascript\r\n\tconst http = require('http');\r\n\t\r\n\tconst maxSockets = 10;\r\n\t\r\n\tconst agent = new http.Agent({ maxSockets});\r\n\t\r\n\tconst client = http.request({\r\n\t    agent,\r\n\t    port: 8080,\r\n\t});\r\n\t```\r\n\r\n2. 不使用代理，脱离连接池的管理\r\n\r\n\t```javascript\r\n\tconst client = http.request({\r\n\t    agent: false,\r\n\t    port: 8080,\r\n\t});\r\n\t```\r\n","meta":{"size":8491,"birthTime":1663496641395.7998,"updateTime":1663496641395.957}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["JavaScript","NodeJS","网络编程"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
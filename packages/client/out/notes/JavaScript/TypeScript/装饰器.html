<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>装饰器 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#装饰器种类" data-target-id="h2-装饰器种类-0">装饰器种类</a><ul><li><a href="#类装饰器" data-target-id="h3-类装饰器-0">类装饰器</a></li><li><a href="#属性装饰器" data-target-id="h3-属性装饰器-1">属性装饰器</a></li><li><a href="#方法装饰器" data-target-id="h3-方法装饰器-2">方法装饰器</a></li><li><a href="#参数装饰器" data-target-id="h3-参数装饰器-3">参数装饰器</a></li></ul></li><li><a href="#执行时机" data-target-id="h2-执行时机-1">执行时机</a></li><li><a href="#装饰器组合" data-target-id="h2-装饰器组合-2">装饰器组合</a></li><li><a href="#元数据" data-target-id="h2-元数据-3">元数据</a></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">装饰器</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h2>装饰器种类</h2>
<p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上</p>
<p>装饰器本身就是一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入</p>
<p>装饰器工厂是一个返回一个装饰器的函数，它用于定制一个修饰器</p>
<h3>类装饰器</h3>
<p>类装饰器是一个对类进行装饰的函数，该函数接收一个参数：要装饰类本身</p>
<p>类装饰器可以返回一个新的类，将会替换掉装饰的类</p>
<p>基本上，类装饰器的行为就是下面这样：</p>
<pre><code class="language-javascript">@decorator
class A {}

// 等同于

class A {}
A = decorator(A) || A
</code></pre>
<h3>属性装饰器</h3>
<p>属性装饰器接受两个参数：</p>
<ol>
<li>
<p>如果是静态属性，则为类本身；如果是实例属性，则为类的原型</p>
</li>
<li>
<p>属性名</p>
</li>
</ol>
<pre><code class="language-typescript">function propertyDes(target: object, prop: string) {
  console.log(target, prop)
}

class Test {
  @propertyDes
  static des: string = &#x27;default&#x27;

  @propertyDes
  des: string = &#x27;default&#x27;
}

// {} des
// [class Test] { des: &#x27;default&#x27; } des
</code></pre>
<h3>方法装饰器</h3>
<p>方法装饰器会被应用到方法的<strong>属性描述符</strong>上，可以用来监视，修改或者替换方法定义</p>
<p>方法装饰器接收三个参数：</p>
<ol>
<li>
<p>如果是静态方法，则为类本身；如果是实例方法，则为类的原型</p>
</li>
<li>
<p>方法名</p>
</li>
<li>
<p>方法的属性描述符</p>
</li>
</ol>
<p>如果方法装饰器返回一个值，则该值会被用来替换掉方法原本的属性描述符</p>
<pre><code class="language-typescript">function log(proto: any, key: string, descriptor: PropertyDescriptor) {
  const method = descriptor.value
  descriptor.value = function (...args: any[]) {
    console.log(&#x27;log:&#x27;, key, &#x27;execute&#x27;)
    return method.apply(this, args)
  }
}

class Test {
  @log
  print(val: string) {
    console.log(val)
  }
}

new Test().print(&#x27;helle world&#x27;)

// log: print execute
// helle world
</code></pre>
<h3>参数装饰器</h3>
<p>参数装饰器可以应用于类构造函数或方法声明，参数装饰器只能用来监视一个方法的参数是否被传入（需要使用元数据）</p>
<p>参数装饰器接收三个参数：</p>
<ol>
<li>
<p>如果方法是静态的，则为类本身；如果方法是实例方法，则为类的原型</p>
</li>
<li>
<p>该参数所属的方法名</p>
</li>
<li>
<p>参数在函数参数列表中的索引</p>
</li>
</ol>
<pre><code class="language-typescript">function paramDes(target: object, name: string, index: number) {
  console.log(target, name, index)
}

class Test {
  print(@paramDes val: string) {
    console.log(val)
  }
}

new Test().print(&#x27;helle world&#x27;)
// {} print 0
</code></pre>
<h2>执行时机</h2>
<p>类装饰器函数会在类定义后直接运行，当然规范中装饰器的运行时机是在编译阶段</p>
<pre><code class="language-typescript">function classDes(target: new () =&gt; object) {
  console.log(target.name)
}

@classDes
class A { }
console.log(&#x27;finish&#x27;)
// A
// finish
</code></pre>
<p>类中不同声明上的装饰器将按以下规定的顺序应用：</p>
<ol>
<li><strong>实例成员</strong>的参数装饰器，然后依次是方法装饰器，访问符装饰器，属性装饰器</li>
<li><strong>静态成员</strong>的参数装饰器，然后依次是方法装饰器，访问符装饰器，属性装饰器</li>
<li>参数装饰器应用到构造函数</li>
<li>类装饰器应用到类</li>
</ol>
<h2>装饰器组合</h2>
<p>多个装饰器可以同时应用到一个声明上，这些装饰器的运行顺序：</p>
<ol>
<li>由上至下依次对<strong>装饰器表达式</strong>求值，如果本身就是装饰器的话则不需要这一步</li>
<li>由下至上依次应用装饰器</li>
</ol>
<pre><code class="language-typescript">function classDes(des: string) {
  console.log(&#x27;evaluated&#x27;, des)
  return (target: new () =&gt; object) =&gt; {
    console.log(&#x27;executed&#x27;, des, target)
    return class Test {
      static des = des
    }
  }
}

@classDes(&#x27;1&#x27;)
@classDes(&#x27;2&#x27;)
@classDes(&#x27;3&#x27;)
class Test {
  static des: string = &#x27;default&#x27;
}

console.log(Test)

// evaluated 1
// evaluated 2
// evaluated 3
// executed 3 [class Test] { des: &#x27;default&#x27; }
// executed 2 [class Test] { des: &#x27;3&#x27; }
// executed 1 [class Test] { des: &#x27;2&#x27; }
// [class Test] { des: &#x27;1&#x27; }
</code></pre>
<p>多个装饰器的行为等价于：</p>
<pre><code class="language-javascript">const classDes1 = classDes(&#x27;1&#x27;)
const classDes2 = classDes(&#x27;2&#x27;)
const classDes3 = classDes(&#x27;3&#x27;)

Test = classDes3(Test) ?? Test
Test = classDes2(Test) ?? Test
Test = classDes1(Test) ?? Test
</code></pre>
<h2>元数据</h2>
<p>元数据：用来描述数据的数据</p>
<p>Reflect Metadata 是 ES7 新增的一个提案，通过装饰器来给类添加一些元数据，然后通过反射将这些信息提取出来</p>
<p>也就是 Reflect Metadata 可以对类、属性或方法等进行<strong>元数据</strong>的读写</p><div><a href="/notes/JavaScript/TypeScript">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"装饰器","article":{"title":"装饰器","content":"## 装饰器种类\n\n装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上\n\n装饰器本身就是一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入\n\n装饰器工厂是一个返回一个装饰器的函数，它用于定制一个修饰器\n\n### 类装饰器\n\n类装饰器是一个对类进行装饰的函数，该函数接收一个参数：要装饰类本身\n\n类装饰器可以返回一个新的类，将会替换掉装饰的类\n\n基本上，类装饰器的行为就是下面这样：\n\n```javascript\n@decorator\nclass A {}\n\n// 等同于\n\nclass A {}\nA = decorator(A) || A\n```\n\n### 属性装饰器\n\n属性装饰器接受两个参数：\n\n1. 如果是静态属性，则为类本身；如果是实例属性，则为类的原型\n\n2. 属性名\n\n```typescript\nfunction propertyDes(target: object, prop: string) {\n  console.log(target, prop)\n}\n\nclass Test {\n  @propertyDes\n  static des: string = 'default'\n\n  @propertyDes\n  des: string = 'default'\n}\n\n// {} des\n// [class Test] { des: 'default' } des\n```\n\n### 方法装饰器\n\n方法装饰器会被应用到方法的**属性描述符**上，可以用来监视，修改或者替换方法定义\n\n方法装饰器接收三个参数：\n\n1. 如果是静态方法，则为类本身；如果是实例方法，则为类的原型\n\n2. 方法名\n\n3. 方法的属性描述符\n\n如果方法装饰器返回一个值，则该值会被用来替换掉方法原本的属性描述符\n\n```typescript\nfunction log(proto: any, key: string, descriptor: PropertyDescriptor) {\n  const method = descriptor.value\n  descriptor.value = function (...args: any[]) {\n    console.log('log:', key, 'execute')\n    return method.apply(this, args)\n  }\n}\n\nclass Test {\n  @log\n  print(val: string) {\n    console.log(val)\n  }\n}\n\nnew Test().print('helle world')\n\n// log: print execute\n// helle world\n```\n\n### 参数装饰器\n\n参数装饰器可以应用于类构造函数或方法声明，参数装饰器只能用来监视一个方法的参数是否被传入（需要使用元数据）\n\n参数装饰器接收三个参数：\n\n1. 如果方法是静态的，则为类本身；如果方法是实例方法，则为类的原型\n\n2. 该参数所属的方法名\n\n3. 参数在函数参数列表中的索引\n\n```typescript\nfunction paramDes(target: object, name: string, index: number) {\n  console.log(target, name, index)\n}\n\nclass Test {\n  print(@paramDes val: string) {\n    console.log(val)\n  }\n}\n\nnew Test().print('helle world')\n// {} print 0\n```\n\n## 执行时机\n\n类装饰器函数会在类定义后直接运行，当然规范中装饰器的运行时机是在编译阶段\n\n```typescript\nfunction classDes(target: new () =\u003e object) {\n  console.log(target.name)\n}\n\n@classDes\nclass A { }\nconsole.log('finish')\n// A\n// finish\n```\n\n类中不同声明上的装饰器将按以下规定的顺序应用：\n\n1. **实例成员**的参数装饰器，然后依次是方法装饰器，访问符装饰器，属性装饰器\n2. **静态成员**的参数装饰器，然后依次是方法装饰器，访问符装饰器，属性装饰器\n3. 参数装饰器应用到构造函数\n4. 类装饰器应用到类\n\n## 装饰器组合\n\n多个装饰器可以同时应用到一个声明上，这些装饰器的运行顺序：\n\n1. 由上至下依次对**装饰器表达式**求值，如果本身就是装饰器的话则不需要这一步\n2. 由下至上依次应用装饰器\n\n```typescript\nfunction classDes(des: string) {\n  console.log('evaluated', des)\n  return (target: new () =\u003e object) =\u003e {\n    console.log('executed', des, target)\n    return class Test {\n      static des = des\n    }\n  }\n}\n\n@classDes('1')\n@classDes('2')\n@classDes('3')\nclass Test {\n  static des: string = 'default'\n}\n\nconsole.log(Test)\n\n// evaluated 1\n// evaluated 2\n// evaluated 3\n// executed 3 [class Test] { des: 'default' }\n// executed 2 [class Test] { des: '3' }\n// executed 1 [class Test] { des: '2' }\n// [class Test] { des: '1' }\n```\n\n多个装饰器的行为等价于：\n\n```javascript\nconst classDes1 = classDes('1')\nconst classDes2 = classDes('2')\nconst classDes3 = classDes('3')\n\nTest = classDes3(Test) ?? Test\nTest = classDes2(Test) ?? Test\nTest = classDes1(Test) ?? Test\n```\n\n## 元数据\n\n元数据：用来描述数据的数据\n\nReflect Metadata 是 ES7 新增的一个提案，通过装饰器来给类添加一些元数据，然后通过反射将这些信息提取出来\n\n也就是 Reflect Metadata 可以对类、属性或方法等进行**元数据**的读写\n\n","meta":{"size":4507,"birthTime":1663496641396.498,"updateTime":1663496641396.6084}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["JavaScript","TypeScript","装饰器"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
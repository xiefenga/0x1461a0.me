<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>CRUD | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#基础查询" data-target-id="h1-基础查询-0">基础查询</a><ul><li><a href="#字段查询" data-target-id="h2-字段查询-0">字段查询</a></li><li><a href="#去重查询" data-target-id="h2-去重查询-1">去重查询</a></li><li><a href="#查询别名" data-target-id="h2-查询别名-2">查询别名</a></li><li><a href="#完全限定" data-target-id="h2-完全限定-3">完全限定</a></li><li><a href="#其他查询" data-target-id="h2-其他查询-4">其他查询</a></li></ul></li><li><a href="#分页查询" data-target-id="h1-分页查询-1">分页查询</a></li><li><a href="#过滤数据" data-target-id="h1-过滤数据-2">过滤数据</a><ul><li><a href="#范围操作符" data-target-id="h2-范围操作符-5">范围操作符</a></li><li><a href="#空值查询" data-target-id="h2-空值查询-6">空值查询</a></li><li><a href="#逻辑操作符" data-target-id="h2-逻辑操作符-7">逻辑操作符</a></li><li><a href="#IN操作符" data-target-id="h2-IN操作符-8">IN操作符</a></li><li><a href="#LIKE操作符" data-target-id="h2-LIKE操作符-9">LIKE操作符</a></li><li><a href="#正则查询" data-target-id="h2-正则查询-10">正则查询</a></li></ul></li><li><a href="#排序查询" data-target-id="h1-排序查询-3">排序查询</a><ul><li><a href="#按单个字段排序" data-target-id="h2-按单个字段排序-11">按单个字段排序</a></li><li><a href="#按表达式排序" data-target-id="h2-按表达式排序-12">按表达式排序</a></li><li><a href="#按别名排序" data-target-id="h2-按别名排序-13">按别名排序</a></li><li><a href="#按函数排序" data-target-id="h2-按函数排序-14">按函数排序</a></li><li><a href="#按多个字段排序" data-target-id="h2-按多个字段排序-15">按多个字段排序</a></li></ul></li><li><a href="#CASE语句" data-target-id="h1-CASE语句-4">CASE语句</a></li><li><a href="#分组查询" data-target-id="h1-分组查询-5">分组查询</a><ul><li><a href="#简单分组" data-target-id="h2-简单分组-16">简单分组</a></li><li><a href="#过滤分组" data-target-id="h2-过滤分组-17">过滤分组</a></li><li><a href="#多个字段分组" data-target-id="h2-多个字段分组-18">多个字段分组</a></li></ul></li><li><a href="#子句顺序" data-target-id="h1-子句顺序-6">子句顺序</a></li><li><a href="#连接查询" data-target-id="h1-连接查询-7">连接查询</a><ul><li><a href="#笛卡尔积" data-target-id="h2-笛卡尔积-19">笛卡尔积</a></li><li><a href="#内连接" data-target-id="h2-内连接-20">内连接</a><ul><li><a href="#SQL92" data-target-id="h3-SQL92-0">SQL92</a></li><li><a href="#SQL99" data-target-id="h3-SQL99-1">SQL99</a></li></ul></li><li><a href="#自然连接" data-target-id="h2-自然连接-21">自然连接</a></li><li><a href="#自连接" data-target-id="h2-自连接-22">自连接</a></li><li><a href="#外连接" data-target-id="h2-外连接-23">外连接</a><ul><li><a href="#左外连接" data-target-id="h3-左外连接-2">左外连接</a></li><li><a href="#右外连接" data-target-id="h3-右外连接-3">右外连接</a></li><li><a href="#全外连接" data-target-id="h3-全外连接-4">全外连接</a></li></ul></li><li><a href="#交叉连接" data-target-id="h2-交叉连接-24">交叉连接</a></li></ul></li><li><a href="#子查询" data-target-id="h1-子查询-8">子查询</a><ul><li><a href="#相关子查询" data-target-id="h2-相关子查询-25">相关子查询</a></li><li><a href="#EXISTS" data-target-id="h2-EXISTS-26">EXISTS</a></li><li><a href="#ANY/SOME/ALL" data-target-id="h2-ANY/SOME/ALL-27">ANY/SOME/ALL</a></li></ul></li><li><a href="#联合查询" data-target-id="h1-联合查询-9">联合查询</a></li><li><a href="#插入数据" data-target-id="h1-插入数据-10">插入数据</a><ul><li><a href="#多行插入" data-target-id="h2-多行插入-28">多行插入</a></li><li><a href="#检索插入" data-target-id="h2-检索插入-29">检索插入</a></li></ul></li><li><a href="#更新数据" data-target-id="h1-更新数据-11">更新数据</a><ul><li><a href="#更新多个列" data-target-id="h2-更新多个列-30">更新多个列</a></li><li><a href="#IGNORE" data-target-id="h2-IGNORE-31">IGNORE</a></li><li><a href="#更新多表" data-target-id="h2-更新多表-32">更新多表</a></li></ul></li><li><a href="#删除数据" data-target-id="h1-删除数据-12">删除数据</a><ul><li><a href="#删除多表" data-target-id="h2-删除多表-33">删除多表</a></li><li><a href="#更快的删除" data-target-id="h2-更快的删除-34">更快的删除</a></li></ul></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">CRUD</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h1>基础查询</h1>
<p>通过 <code>SELECT</code> 语句进行查询：</p>
<pre><code class="language-mysql">SELECT
	prod_name
FROM
	products;
</code></pre>
<ul>
<li>查询列表可以是：表中的字段、常量值、表达式、函数</li>
<li>查询的结果是一个虚拟的表格</li>
</ul>
<h2>字段查询</h2>
<p>查询多个字段，使用 <code>,</code> 分隔</p>
<pre><code class="language-mysql">SELECT
	prod_id,
	prod_name,
	prod_price 
FROM
	products;
</code></pre>
<p>使用通配符 <code>*</code> 查询所有字段</p>
<pre><code class="language-mysql">SELECT * FROM products;
</code></pre>
<h2>去重查询</h2>
<p>使用关键字 <code>DISTINCT</code>，将其直接放在列名之前。</p>
<pre><code class="language-mysql">SELECT DISTINCT vend_id FROM products;
</code></pre>
<p>不能部分使用 <code>DISTINCT</code>，该关键字应用于<strong>所有列</strong>而不仅仅是前置它的列。</p>
<p>所以如果给出了多个列，只有这些列都相同才好使，但是不会报错会列出所有的行。</p>
<h2>查询别名</h2>
<p>使用 <code>AS</code> 关键词起别名，<code>AS</code> 也可省略用空格代替。</p>
<pre><code class="language-mysql">SELECT
  prod_name AS 名称,
  prod_price  AS 价格
FROM
  products;
</code></pre>
<h2>完全限定</h2>
<ol>
<li>
<p>完全限定列</p>
<p>可以使用完全限定的名字来引用列，也就是同时使用表名和列名</p>
<pre><code class="language-mysql">SELECT
	products.prod_name 
FROM
	products;
</code></pre>
</li>
<li>
<p>完全限定表</p>
<p>表名也是可以完全限定的，即使用数据库名和表名</p>
<pre><code class="language-mysql">SELECT
	products.prod_name 
FROM
	crashcourse.products;
</code></pre>
</li>
</ol>
<h2>其他查询</h2>
<ol>
<li>查询常量</li>
<li>查询表达式</li>
<li>查询函数</li>
</ol>
<pre><code class="language-mysql">-- 常量
SELECT 100;
-- 表达式
SELECT 100 % 98;
-- 函数
SELECT VERSION();
</code></pre>
<h1>分页查询</h1>
<p>使用 <code>LIMIT</code> 子句进行对于查询的结果数量进行限制：</p>
<pre><code class="language-mysql">SELECT
	prod_name
FROM
	products
LIMIT 5;
</code></pre>
<ul>
<li>
<p>查询结果的行数是从第 0 行开始计算</p>
</li>
<li>
<p><code>LIMIT 5</code> 指示返回的结果不多于 5 行</p>
</li>
<li>
<p><code>LIMIT 5, 5</code> 指示返回从第 5 行开始 5 行的数据</p>
</li>
<li>
<p>MySQL 5 添加了 <code>LIMIT 4 OFFSET 3</code> 的语法，相当于 <code>LIMIT 3, 4</code></p>
</li>
</ul>
<h1>过滤数据</h1>
<p>使用 <code>WHERE</code> 子句进行数据过滤：</p>
<pre><code class="language-mysql">SELECT
	prod_name,
	prod_price 
FROM
	products 
WHERE
	prod_price = 2.50;
</code></pre>
<h2>范围操作符</h2>
<ul>
<li>
<p><code>&gt;</code>、<code> =</code>、<code>!=</code>、<code>&lt;&gt;</code>、<code>&lt;=&gt;</code>、<code>&gt;=</code>、<code>&lt;=</code></p>
<ul>
<li><code>&lt;&gt;</code> 和 <code>!=</code> 相同，没有区别，都是不等于</li>
<li><code>&lt;=&gt;</code> 安全等于，<code>!=</code> 和 <code>=</code> 无法判断 <code>null</code>，<code>&lt;=&gt;</code> 可以判断 <code>null</code></li>
<li>执行匹配时默认不区分大小写（字符串）</li>
</ul>
</li>
<li>
<p><code>BETWEEN ... AND ...</code></p>
</li>
<li>
<p>相当于 <code>&gt;= ... AND  &lt;= ...</code></p>
<ul>
<li>可以用于日期类型数据</li>
</ul>
</li>
</ul>
<h2>空值查询</h2>
<p>使用 <code>IS</code>、<code>IS NOT</code> 操作符来判空 <code>NULL</code>，<code>=</code> 无法判断 <code>NULL</code></p>
<pre><code class="language-mysql">SELECT
	prod_name 
FROM
	products 
WHERE
	prod_price IS NULL;
</code></pre>
<h2>逻辑操作符</h2>
<p><code>AND</code>、<code>OR</code>、<code>NOT</code></p>
<pre><code class="language-mysql">SELECT
	last_name,
	salary,
	commission_pct 
FROM
	employees 
WHERE
	salary &gt;= 10000 AND salary &lt;= 20000;
</code></pre>
<p>优先级：<code>AND</code> 优先级比 <code>OR</code> 高，判断比较复杂的时候可以加上 <code>()</code></p>
<h2>IN操作符</h2>
<p>判断某字段的值是否属于 <code>IN</code> 列表中的某一项，列表的值类型必须一致或兼容，列表中不支持通配符</p>
<pre><code class="language-mysql">SELECT
	prod_name,
	prod_price 
FROM
	products 
WHERE
	vend_id IN ( 1002, 1003 );
</code></pre>
<ul>
<li>语法更清晰直观</li>
<li>查询速度更快</li>
<li>可以包含其他 <code>SELECT</code> 语句</li>
</ul>
<h2>LIKE操作符</h2>
<p>使用 <code>LIKE</code> 可以进行模糊查询，<code>%</code> 表示任意个字符（包括0个），<code>_</code> 表示单个任意字符</p>
<pre><code class="language-mysql">SELECT
	prod_id,
	prod_name 
FROM
	products 
WHERE
	prod_name LIKE &#x27;jet%&#x27;
</code></pre>
<h2>正则查询</h2>
<p>使用 <code>REGEXP</code> 关键字代替 <code>LIKE</code> 可以使用正则表达式匹配来进行数据过滤。</p>
<p>MySQL 仅支持多数正则表达式实现的一个<strong>很小</strong>的子集。</p>
<pre><code class="language-mysql">SELECT
	prod_name 
FROM
	products 
WHERE
	prod_name REGEXP &#x27;1000&#x27;;
</code></pre>
<p>MySQL 中正则表达式的匹配不区分大小写，需要区分大小写需要使用 <code>REGEXP BINAR</code> 关键字</p>
<h1>排序查询</h1>
<p>使用 <code>ORDER BY</code> 语句进行排序：</p>
<pre><code class="language-mysql">SELECT
	prod_name 
FROM
	products 
ORDER BY
	prod_name ASC;
</code></pre>
<ul>
<li><code>ASC</code> 升序，<code>DESC</code> 降序，默认升序</li>
<li><code>ORDER BY</code> 子句支持单个字段、别名、表达式、函数、多个字段排序</li>
<li><code>ORDER BY</code> 子句在查询语句的最后面，除了 <code>LIMIT</code> 子句</li>
</ul>
<h2>按单个字段排序</h2>
<pre><code class="language-mysql">SELECT
	* 
FROM
	employees 
ORDER BY
	salary DESC;
</code></pre>
<h2>按表达式排序</h2>
<pre><code class="language-mysql">SELECT
	salary * 12 * ( 1 + IFNULL( commission_pct, 0 ) ) AS 年薪 
FROM
	employees 
ORDER BY
	salary * 12 *( 1 + IFNULL( commission_pct, 0 ) ) DESC;
</code></pre>
<h2>按别名排序</h2>
<pre><code class="language-mysql">SELECT
	salary * 12 * ( 1 + IFNULL( commission_pct, 0 ) ) AS 年薪
FROM
	employees 
ORDER BY
	年薪 ASC;
</code></pre>
<h2>按函数排序</h2>
<pre><code class="language-mysql">SELECT
	last_name 
FROM
	employees 
ORDER BY
	LENGTH( last_name ) DESC;
</code></pre>
<h2>按多个字段排序</h2>
<pre><code class="language-mysql">SELECT
	* 
FROM
	employees 
ORDER BY
	salary DESC,
	employee_id ASC;
</code></pre>
<h1>CASE语句</h1>
<p>条件可以写在 <code>CASE</code> 后面也可以写在 <code>WHEN</code> 后面，<code>END</code> 代表这个 <code>CASE</code> 结束了，可以在 <code>END</code> 后使用别名</p>
<p>两种用法类似于 <code>switch..case..</code> 和 <code>if..else if ..</code> 的区别</p>
<p><strong>第一种用法</strong></p>
<pre><code class="language-mysql">SELECT salary AS 原始工资, department_id,
	CASE department_id 
		WHEN 30 THEN salary * 1.1 
		WHEN 40 THEN salary * 1.2 
		WHEN 50 THEN salary * 1.3
		ELSE salary 
	END AS 新工资 
FROM
	employees;
</code></pre>
<p><strong>第二种用法</strong></p>
<pre><code class="language-mysql">SELECT salary,
	CASE
		WHEN salary &gt; 20000 THEN &#x27;A&#x27; 
		WHEN salary &gt; 15000 THEN &#x27;B&#x27; 
		WHEN salary &gt; 10000 THEN &#x27;C&#x27;
		ELSE &#x27;D&#x27; 
	END AS 工资级别 
FROM
	employees;
</code></pre>
<h1>分组查询</h1>
<p>使用 <code>GROUP BY</code> 子句进行分组：</p>
<pre><code class="language-mysql">SELECT 查询列表
FROM 表
WHERE 筛选条件
GROUP BY 分组的依据
ORDER BY 排序的字段;
</code></pre>
<ul>
<li><code>GROUP BY</code> 子句指示 MySQL 分组数据，然后对每个组而不是整个结果进行聚集</li>
<li><code>GROUP BY</code> 子句必须在 <code>WHERE</code> 子句之后，<code>ORDER BY</code> 子句之前</li>
</ul>
<h2>简单分组</h2>
<pre><code class="language-mysql">SELECT
	MAX( salary ) 
FROM
	employees 
WHERE
	email LIKE &#x27;%a%&#x27; 
GROUP BY
	department_id;
</code></pre>
<h2>过滤分组</h2>
<p>当分组查询后需要继续过滤数据，就需要用到 <code>HAVING</code> 语句：</p>
<pre><code class="language-mysql">-- 查询部门员工数量大于5的部门id和员工数量
SELECT
	COUNT(*),
	department_id 
FROM
	employees 
GROUP BY
	department_id 
HAVING
	COUNT(*)&gt; 5;
</code></pre>
<p><code>HAVING</code> 子句和 <code>WHERE</code> 子句的区别：</p>
<ul>
<li><code>WHERE</code> 过滤行，<code>HAVING</code> 过滤分组</li>
<li><code>WHERE</code> 分组前过滤，<code>HAVING</code> 分组后过滤</li>
</ul>
<h2>多个字段分组</h2>
<p>将多个字段都相同的分为一组</p>
<pre><code class="language-mysql">SELECT
	MIN( salary ) 
FROM
	employees 
GROUP BY
	department_id,
	job_id 
ORDER BY
	MIN( salary ) DESC;
</code></pre>
<h1>子句顺序</h1>
<p><code>SELECT</code> 子句使用顺序：</p>
<ol>
<li><code>SELECT</code></li>
<li><code>FROM</code></li>
<li><code>WHERE</code></li>
<li><code>GROUP BY</code></li>
<li><code>HAVING</code></li>
<li><code>ORDER BY</code></li>
<li><code>LIMIT</code></li>
</ol>
<h1>连接查询</h1>
<p>当查询的字段来自于多个表时，就可以使用连接查询。</p>
<h2>笛卡尔积</h2>
<p>在连接两个表时，实际上做的是将第一个表的每一行与第二个表中的每一行配对。</p>
<p><code>WHERE</code> 子句可以将不需要的行过滤掉，在连接查询时这个条件叫做连接条件。</p>
<p>当没有连接条件时连接查询返回的结果就是<strong>笛卡尔积</strong>，检索出的行数时两表行数的乘积。</p>
<p>为了避免笛卡尔集，可以在 <code>WHERE</code> 加入有效的连接条件。</p>
<h2>内连接</h2>
<p>内连接查询操作只列出与连接条件匹配的数据行，也就是交集</p>
<ul>
<li>
<p>根据所使用的<strong>比较方式</strong>不同，分为等值连接、非等值连接。</p>
</li>
<li>
<p>n表连接，至少需要n-1个连接条件</p>
</li>
<li>
<p>一般需要为表起别名</p>
</li>
</ul>
<h3>SQL92</h3>
<p>将连接条件写在 <code>WHERE</code> 后进行过滤的是 SQL92 语法</p>
<pre><code class="language-mysql">SELECT
	vend_name,
	prod_name,
	prod_price 
FROM
	vendors,
	products 
WHERE
	vendors.vend_id = products.vend_id;
</code></pre>
<h3>SQL99</h3>
<p>SQL99 语法使用 <code>INNER JOIN</code> 语法来实现表的内连接</p>
<pre><code class="language-mysql">SELECT
	vend_name,
	prod_name,
	prod_price 
FROM
	vendors
	INNER JOIN products ON vendors.vend_id = products.vend_id;
</code></pre>
<ul>
<li><code>INNER</code> 关键字可以省略</li>
<li>连接条件在 <code>ON</code> 后面</li>
<li>可以接着使用 <code>WHERE</code> 进行过滤</li>
<li>筛选条件放在 <code>WHERE</code> 后面，连接条件放在 <code>ON</code> 后面，提高分离性，便于阅读</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li><strong>WHERE 没有 ON 效率高</strong></li>
<li>ON 匹配到第一条成功的就结束，其他不匹配；若没有，不进行匹配</li>
<li>WHERE 会一直匹配，进行判断</li>
</ul>
<h2>自然连接</h2>
<p>在返回所有结果的等值连接中，必然至少有一个列是重复的，自然连接就是自己选择结果集合中所包括的列。</p>
<h2>自连接</h2>
<p>自连接就是同一张表和同一张表进行连接，当一张表中有两个以上的字段有一定的关系时就可能用到自连接。</p>
<pre><code class="language-mysql">-- mysql92
SELECT
	e.last_name,
	m.last_name 
FROM
	employees e,
	employees m 
WHERE
	e.`manager_id` = m.`employee_id`;

-- mysql99
SELECT
	e.last_name,
	m.last_name 
FROM
	employees e
	JOIN employees m ON e.`manager_id` = m.`employee_id`;
</code></pre>
<h2>外连接</h2>
<p>外连接不只列出与连接条件相匹配的行，而且还加上左表(左外连接时)或右表(右外连接时)或两个表(全外连接时)中所有符合搜索条件的数据行</p>
<p>外连接只有 SQL99 支持，SQL92 不支持。</p>
<h3>左外连接</h3>
<p>左外连接从左边表（<code>FROM</code>）中选择所有行，另一个表中没有的数据则显示 <code>NULL</code></p>
<pre><code class="language-mysql">SELECT
	customers.cust_id,
	orders.order_num 
FROM
	customers
	LEFT OUTER JOIN orders ON customers.cust_id = orders.cust_id;
</code></pre>
<ul>
<li><code>OUTER</code> 关键字可以省略</li>
<li>可以多表连接</li>
<li>多表连接时先连接成一个大表再和后面的表依次进行连接，主表在左边</li>
</ul>
<h3>右外连接</h3>
<p>右外连接从右边表（<code>FROM</code>）中选择所有行，另一个表中没有的数据则显示 <code>NULL</code></p>
<pre><code class="language-mysql">SELECT
	customers.cust_id,
	orders.order_num 
FROM
	orders
	RIGHT OUTER JOIN customers ON customers.cust_id = orders.cust_id;
</code></pre>
<h3>全外连接</h3>
<p>全外连接就是两个表中的行都有，每一个表中不匹配的行列的数据为 <code>NULL</code></p>
<p>全外连接使用 <code>FULL OUTER JOIN</code> 关键字MySQL 不支持全外连接</p>
<pre><code class="language-mysql">SELECT
	b.*,
	bo.* 
FROM
	beauty b
	FULL OUTER JOIN boys bo ON b.`boyfriend_id` = bo.id;
</code></pre>
<h2>交叉连接</h2>
<p>交叉连接就是笛卡尔积，交叉连接使用 <code>CROSS JOIN</code> 关键字</p>
<pre><code class="language-mysql">SELECT
	b.*,
	bo.* 
FROM
	beauty b
	CROSS JOIN boys bo;
</code></pre>
<h1>子查询</h1>
<p>子查询就是嵌套在其他查询中的查询（出现在其他语句中的 <code>SELECT</code>语句）</p>
<p>子查询可以出现的位置：</p>
<ul>
<li><code>SELECT</code> 之后</li>
<li><code>FROM</code> 之后</li>
<li><code>WHERE</code> 之后</li>
<li><code>HAVING</code> 之后</li>
<li><code>EXISTS</code> 之后</li>
</ul>
<p>子查询的结果的行和列的数量必须要合法，要和使用的位置所需要的格式相匹配。</p>
<pre><code class="language-mysql">SELECT
	cust_id 
FROM
	orders 
WHERE
	order_num IN ( SELECT order_num FROM orderitems WHERE prod_id = &#x27;TNT2&#x27; );
</code></pre>
<p>在 <code>SELECT</code> 语句中，子查询总是由内向外处理，先运行子查询再运行主查询。</p>
<p>对于 <code>IN</code> 操作符内部的子查询，查询出来的多行单列的结果会以 <code>IN</code> 操作符要求的逗号分隔的格式传递给外部。</p>
<h2>相关子查询</h2>
<p>当<strong>子查询中</strong>涉及到<strong>外部查询</strong>的子查询称之为相关子查询</p>
<p><code>SELECT</code> 之后的子查询会在检索每一行时都会执行一遍，对于每个 customer 都会在执行一边子查询。</p>
<pre><code class="language-mysql">SELECT
	cust_name,
	cust_state,
	( SELECT count(*) FROM orders WHERE orders.cust_id = customers.cust_id ) AS orders 
FROM
	customers 
ORDER BY
	cust_name;
</code></pre>
<h2>EXISTS</h2>
<p>当 <code>EXISTS</code> 子句中的子查询有结果返回 1，否则返回 0</p>
<pre><code class="language-mysql">SELECT EXISTS ( SELECT * FROM products WHERE vend_id IS NULL );
</code></pre>
<h2>ANY/SOME/ALL</h2>
<p><code>ANY</code>、<code>SOME</code> 和 <code>ALL</code>  中只能放子查询，和 <code>IN</code>、<code>NOT IN</code> 子句一样后面放的是多行单列的子查询</p>
<ul>
<li>
<p><code>ANY</code>、<code>SOME</code> 是一样的，只要和其中的任意一个数据比较满足就可以。</p>
</li>
<li>
<p><code>ALL</code> 则是和其中所有的进行比较满足才可以。</p>
</li>
</ul>
<pre><code class="language-mysql">SELECT
	prod_name,
	vend_id 
FROM
	products 
WHERE
	vend_id &gt; ALL ( SELECT DISTINCT vend_id FROM products WHERE vend_id IN ( 1001, 1002 ) );
</code></pre>
<h1>联合查询</h1>
<p>联合查询就是将多条查询语句的结果合并成一个结果。</p>
<pre><code class="language-mysql">SELECT
	vend_id,
	prod_id,
	prod_price 
FROM
	products 
WHERE
	prod_price &lt;= 5
UNION
SELECT
	vend_id,
	prod_id,
	prod_price 
FROM
	products 
WHERE
	vend_id IN ( 1001, 1002 );
</code></pre>
<ul>
<li><code>UNION</code> 必须由两条或两条以上的 <code>SELECT</code> 语句组成</li>
<li><code>UNION</code> 中的每个查询必须包含<strong>相同的列</strong></li>
<li><code>UNION</code> 从查询结果中自动去除了的<strong>重复的行</strong></li>
<li>想返回所有匹配的行，使用 <code>UNION ALL</code></li>
<li>只能使用一条 <code>ORDER BY</code> 子句，必须出现在最后一条 <code>SELECT</code> 语句之后，MySQL 使用它来给整个结果排序</li>
<li><code>UNION</code> 几乎总是完成与多个 <code>WHERE</code> 条件相同的工作</li>
</ul>
<h1>插入数据</h1>
<p>使用 <code>SELECT INTO</code> + 表名向表中插入一行数据：</p>
<pre><code class="language-mysql">INSERT INTO customers
VALUES
	( NULL, &#x27;Prp E. LaPew&#x27;, &#x27;100 Main Street&#x27;, &#x27;Los Angeles&#x27;, &#x27;CA&#x27;, &#x27;90046&#x27;, &#x27;USA&#x27;, NULL, NULL );
</code></pre>
<ul>
<li>这种方式需要传入所有的字段，以及顺序高度依赖表中列定义的次序</li>
<li><code>NULL</code> 可以传递给主键，MySQL 会忽略该值自动插入递增的值</li>
</ul>
<p>比较安全的 <code>INSERT</code> 语句是写出插入的字段：</p>
<pre><code class="language-mysql">INSERT INTO customers ( cust_name, 
	cust_address, 
	cust_city, 
	cust_state,
	cust_zip, 
	cust_country, 
	cust_contact, 
	cust_email )
VALUES
	( &#x27;Prp E. LaPew&#x27;, &#x27;100 Main Street&#x27;, &#x27;Los Angeles&#x27;, &#x27;CA&#x27;, &#x27;90046&#x27;, &#x27;USA&#x27;, NULL, NULL );
</code></pre>
<ul>
<li>可以省略允许定义为 <code>NULL</code> 或有默认值的列</li>
<li>列的顺序随意</li>
</ul>
<h2>多行插入</h2>
<p>插入多行可以使用多条 <code>INSERT</code> 语句，也可以使用 <code>,</code> 分隔多组值：</p>
<pre><code class="language-mysql">INSERT INTO customers ( cust_name, 
	cust_address, 
	cust_city, 
	cust_state,
	cust_zip, 
	cust_country, 
	cust_contact, 
	cust_email )
VALUES
	( &#x27;Prp E. LaPew&#x27;, &#x27;100 Main Street&#x27;, &#x27;Los Angeles&#x27;, &#x27;CA&#x27;, &#x27;90046&#x27;, &#x27;USA&#x27;, NULL, NULL ),
	( &#x27;M. Martain&#x27;, &#x27;42 Galaxy Way&#x27;, &#x27;New York&#x27;, &#x27;NY&#x27;, &#x27;11213&#x27;, &#x27;USA&#x27; );
</code></pre>
<h2>检索插入</h2>
<p>可以使用 <code>INSERT SELECT</code> 插入查询出来的数据：</p>
<pre><code class="language-mysql">INSERT INTO customers ( cust_contact, 
	cust_email, 
	cust_name, 
	cust_address, 
	cust_city, 
	cust_state, 
	cust_zip, 
	cust_country ) 
SELECT
    cust_contact,
    cust_email,
    cust_name,
    cust_address,
    cust_city,
    cust_state,
    cust_zip,
    cust_country 
FROM
	customers 
WHERE
	cust_contact IS NOT NULL;
</code></pre>
<p><code>INSERT</code> 和 <code>SELECT</code> 中的列名不要求相同，MySQL 不关心列名只关心位置</p>
<h1>更新数据</h1>
<p>使用 <code>UPDATE</code> 语句更新表中的数据，</p>
<pre><code class="language-mysql">UPDATE customers 
SET cust_email = &#x27;elmer@fudd.com&#x27; 
WHERE
	cust_id = 10005;
</code></pre>
<ul>
<li><code>UPDATE</code> 会更新符合条件的行，没有条件则会更行所有行</li>
<li>通过 <code>SET</code> 改变字段的值</li>
</ul>
<h2>更新多个列</h2>
<p>在更新多个列时只需要使用单个 <code>SET</code> ，每个 <code>列=值</code> 之间使用 <code>,</code> 分隔，最后一列不需要。</p>
<pre><code class="language-mysql">UPDATE customers 
SET cust_email = &#x27;elmer@fudd.com&#x27;,
	cust_name = &#x27;The Fudds&#x27; 
WHERE
	cust_id = 10005;
</code></pre>
<h2>IGNORE</h2>
<p>当使用 <code>UPDATE</code> 语句更新多个行时，当在更新过程中出现错误，则整个 <code>UPDATE</code> 操作会被取消，数据会恢复到之前的值。</p>
<p>使用 <code>IGNORE</code> 关键字可以即使发生错误也继续更新。</p>
<pre><code class="language-mysql">UPDATE IGNORE customers ...
</code></pre>
<h2>更新多表</h2>
<pre><code class="language-mysql">UPDATE products
INNER JOIN vendors ON products.vend_id = vendors.vend_id 
SET vendors.vend_name = &#x27;The Fudds&#x27;,
	products.prod_name = &#x27;Wascals&#x27; 
WHERE
	products.prod_id = &#x27;FC&#x27;;
</code></pre>
<h1>删除数据</h1>
<p>使用 <code>DELETE</code> 语句删除特定的行：</p>
<pre><code class="language-mysql">DELETE 
FROM
	customers 
WHERE
	cust_id = 10006;
</code></pre>
<ul>
<li><code>DELETE</code> 会删除符合条件的行，没有条件则会删除所有行</li>
<li><code>DELETE FROM</code> 指定删除数据的表名</li>
<li>可以和 <code>UPDATE</code> 一样删除多个表</li>
</ul>
<h2>删除多表</h2>
<p><code>DELETE</code> 后面跟的是要删除的表，<code>FROME</code> 后面跟的是连接的主表</p>
<pre><code class="language-mysql">DELETE b, bo 
FROM
	beauty b
	INNER JOIN boys bo ON b.`boyfriend_id` = bo.`id` 
WHERE
	bo.`boyName` = &#x27;黄晓明&#x27;;
</code></pre>
<h2>更快的删除</h2>
<p>如果要从表中删除所有的行，使用 <code>TRUNCATE TABLE</code> 语句更合适：</p>
<pre><code class="language-mysql">TRUNCATE TABLE customers ;
</code></pre>
<ul>
<li><code>TRUNCATE TABLE</code> 的速度比 <code>DELETE</code> 更快</li>
<li><code>TRUNCATE</code> 的本质是删除原来的表然后重新创建一个表</li>
</ul><div><a href="/notes/MySQL">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"CRUD","article":{"title":"CRUD","content":"# 基础查询\r\n\r\n通过 `SELECT` 语句进行查询：\r\n\r\n```mysql\r\nSELECT\r\n\tprod_name\r\nFROM\r\n\tproducts;\r\n```\r\n\r\n- 查询列表可以是：表中的字段、常量值、表达式、函数\r\n- 查询的结果是一个虚拟的表格\r\n\r\n## 字段查询\r\n\r\n查询多个字段，使用 `,` 分隔\r\n\r\n```mysql\r\nSELECT\r\n\tprod_id,\r\n\tprod_name,\r\n\tprod_price \r\nFROM\r\n\tproducts;\r\n```\r\n\r\n使用通配符 `*` 查询所有字段\r\n\r\n```mysql\r\nSELECT * FROM products;\r\n```\r\n\r\n## 去重查询\r\n\r\n使用关键字 `DISTINCT`，将其直接放在列名之前。\r\n\r\n```mysql\r\nSELECT DISTINCT vend_id FROM products;\r\n```\r\n\r\n不能部分使用 `DISTINCT`，该关键字应用于**所有列**而不仅仅是前置它的列。\r\n\r\n所以如果给出了多个列，只有这些列都相同才好使，但是不会报错会列出所有的行。\r\n\r\n## 查询别名\r\n\r\n使用 `AS` 关键词起别名，`AS` 也可省略用空格代替。\r\n\r\n  ```mysql\r\nSELECT\r\n\tprod_name AS 名称,\r\n\tprod_price  AS 价格\r\nFROM\r\n\tproducts;\r\n  ```\r\n\r\n## 完全限定\r\n\r\n1. 完全限定列\r\n\r\n\t可以使用完全限定的名字来引用列，也就是同时使用表名和列名\r\n\r\n\t```mysql\r\n\tSELECT\r\n\t\tproducts.prod_name \r\n\tFROM\r\n\t\tproducts;\r\n\t```\r\n\r\n2. 完全限定表\r\n\r\n\t表名也是可以完全限定的，即使用数据库名和表名\r\n\r\n\t```mysql\r\n\tSELECT\r\n\t\tproducts.prod_name \r\n\tFROM\r\n\t\tcrashcourse.products;\r\n\t```\r\n\r\n## 其他查询\r\n\r\n1. 查询常量\r\n2. 查询表达式\r\n3. 查询函数\r\n\r\n```mysql\r\n-- 常量\r\nSELECT 100;\r\n-- 表达式\r\nSELECT 100 % 98;\r\n-- 函数\r\nSELECT VERSION();\r\n```\r\n\r\n# 分页查询\r\n\r\n使用 `LIMIT` 子句进行对于查询的结果数量进行限制：\r\n\r\n```mysql\r\nSELECT\r\n\tprod_name\r\nFROM\r\n\tproducts\r\nLIMIT 5;\r\n```\r\n\r\n- 查询结果的行数是从第 0 行开始计算\r\n\r\n- `LIMIT 5` 指示返回的结果不多于 5 行\r\n- `LIMIT 5, 5` 指示返回从第 5 行开始 5 行的数据\r\n- MySQL 5 添加了 `LIMIT 4 OFFSET 3` 的语法，相当于 `LIMIT 3, 4`\r\n\r\n# 过滤数据\r\n\r\n使用 `WHERE` 子句进行数据过滤：\r\n\r\n```mysql\r\nSELECT\r\n\tprod_name,\r\n\tprod_price \r\nFROM\r\n\tproducts \r\nWHERE\r\n\tprod_price = 2.50;\r\n```\r\n\r\n## 范围操作符\r\n\r\n- `\u003e`、` =`、`!=`、`\u003c\u003e`、`\u003c=\u003e`、`\u003e=`、`\u003c=`\r\n\r\n  - `\u003c\u003e` 和 `!=` 相同，没有区别，都是不等于\r\n  - `\u003c=\u003e` 安全等于，`!=` 和 `=` 无法判断 `null`，`\u003c=\u003e` 可以判断 `null`\r\n  - 执行匹配时默认不区分大小写（字符串）\r\n\r\n- `BETWEEN ... AND ...`\r\n- 相当于 `\u003e= ... AND  \u003c= ...`\r\n  - 可以用于日期类型数据\r\n\r\n## 空值查询\r\n\r\n使用 `IS`、`IS NOT` 操作符来判空 `NULL`，`=` 无法判断 `NULL` \r\n\r\n```mysql\r\nSELECT\r\n\tprod_name \r\nFROM\r\n\tproducts \r\nWHERE\r\n\tprod_price IS NULL;\r\n```\r\n\r\n## 逻辑操作符\r\n\r\n`AND`、`OR`、`NOT`\r\n\r\n```mysql\r\nSELECT\r\n\tlast_name,\r\n\tsalary,\r\n\tcommission_pct \r\nFROM\r\n\temployees \r\nWHERE\r\n\tsalary \u003e= 10000 AND salary \u003c= 20000;\r\n```\r\n\r\n优先级：`AND` 优先级比 `OR` 高，判断比较复杂的时候可以加上 `()`\r\n\r\n## IN操作符\r\n\r\n判断某字段的值是否属于 `IN` 列表中的某一项，列表的值类型必须一致或兼容，列表中不支持通配符\r\n\r\n```mysql\r\nSELECT\r\n\tprod_name,\r\n\tprod_price \r\nFROM\r\n\tproducts \r\nWHERE\r\n\tvend_id IN ( 1002, 1003 );\r\n```\r\n\r\n- 语法更清晰直观\r\n- 查询速度更快\r\n- 可以包含其他 `SELECT` 语句\r\n\r\n## LIKE操作符\r\n\r\n使用 `LIKE` 可以进行模糊查询，`%` 表示任意个字符（包括0个），`_` 表示单个任意字符\r\n\r\n```mysql\r\nSELECT\r\n\tprod_id,\r\n\tprod_name \r\nFROM\r\n\tproducts \r\nWHERE\r\n\tprod_name LIKE 'jet%'\r\n```\r\n\r\n## 正则查询\r\n\r\n使用 `REGEXP` 关键字代替 `LIKE` 可以使用正则表达式匹配来进行数据过滤。\r\n\r\nMySQL 仅支持多数正则表达式实现的一个**很小**的子集。\r\n\r\n```mysql\r\nSELECT\r\n\tprod_name \r\nFROM\r\n\tproducts \r\nWHERE\r\n\tprod_name REGEXP '1000';\r\n```\r\n\r\nMySQL 中正则表达式的匹配不区分大小写，需要区分大小写需要使用 `REGEXP BINAR` 关键字\r\n\r\n# 排序查询\r\n\r\n使用 `ORDER BY` 语句进行排序：\r\n\r\n```mysql\r\nSELECT\r\n\tprod_name \r\nFROM\r\n\tproducts \r\nORDER BY\r\n\tprod_name ASC;\r\n```\r\n\r\n- `ASC` 升序，`DESC` 降序，默认升序\r\n- `ORDER BY` 子句支持单个字段、别名、表达式、函数、多个字段排序\r\n- `ORDER BY` 子句在查询语句的最后面，除了 `LIMIT` 子句\r\n\r\n## 按单个字段排序\r\n\r\n```mysql\r\nSELECT\r\n\t* \r\nFROM\r\n\temployees \r\nORDER BY\r\n\tsalary DESC;\r\n```\r\n\r\n## 按表达式排序\r\n\r\n```mysql\r\nSELECT\r\n\tsalary * 12 * ( 1 + IFNULL( commission_pct, 0 ) ) AS 年薪 \r\nFROM\r\n\temployees \r\nORDER BY\r\n\tsalary * 12 *( 1 + IFNULL( commission_pct, 0 ) ) DESC;\r\n```\r\n\r\n## 按别名排序\r\n\r\n```mysql\r\nSELECT\r\n\tsalary * 12 * ( 1 + IFNULL( commission_pct, 0 ) ) AS 年薪\r\nFROM\r\n\temployees \r\nORDER BY\r\n\t年薪 ASC;\r\n```\r\n\r\n## 按函数排序\r\n\r\n```mysql\r\nSELECT\r\n\tlast_name \r\nFROM\r\n\temployees \r\nORDER BY\r\n\tLENGTH( last_name ) DESC;\r\n```\r\n\r\n## 按多个字段排序\r\n\r\n```mysql\r\nSELECT\r\n\t* \r\nFROM\r\n\temployees \r\nORDER BY\r\n\tsalary DESC,\r\n\temployee_id ASC;\r\n```\r\n\r\n# CASE语句\r\n\r\n条件可以写在 `CASE` 后面也可以写在 `WHEN` 后面，`END` 代表这个 `CASE` 结束了，可以在 `END` 后使用别名\r\n\r\n两种用法类似于 `switch..case..` 和 `if..else if ..` 的区别\r\n\r\n**第一种用法**\r\n\r\n```mysql\r\nSELECT salary AS 原始工资, department_id,\r\n\tCASE department_id \r\n\t\tWHEN 30 THEN salary * 1.1 \r\n\t\tWHEN 40 THEN salary * 1.2 \r\n\t\tWHEN 50 THEN salary * 1.3\r\n\t\tELSE salary \r\n\tEND AS 新工资 \r\nFROM\r\n\temployees;\r\n```\r\n\r\n**第二种用法**\r\n\r\n```mysql\r\nSELECT salary,\r\n\tCASE\r\n\t\tWHEN salary \u003e 20000 THEN 'A' \r\n\t\tWHEN salary \u003e 15000 THEN 'B' \r\n\t\tWHEN salary \u003e 10000 THEN 'C'\r\n\t\tELSE 'D' \r\n\tEND AS 工资级别 \r\nFROM\r\n\temployees;\r\n```\r\n\r\n# 分组查询\r\n\r\n使用 `GROUP BY` 子句进行分组：\r\n\r\n```mysql\r\nSELECT 查询列表\r\nFROM 表\r\nWHERE 筛选条件\r\nGROUP BY 分组的依据\r\nORDER BY 排序的字段;\r\n```\r\n\r\n- `GROUP BY` 子句指示 MySQL 分组数据，然后对每个组而不是整个结果进行聚集\r\n- `GROUP BY` 子句必须在 `WHERE` 子句之后，`ORDER BY` 子句之前\r\n\r\n## 简单分组\r\n\r\n```mysql\r\nSELECT\r\n\tMAX( salary ) \r\nFROM\r\n\temployees \r\nWHERE\r\n\temail LIKE '%a%' \r\nGROUP BY\r\n\tdepartment_id;\r\n```\r\n\r\n## 过滤分组\r\n\r\n当分组查询后需要继续过滤数据，就需要用到 `HAVING` 语句：\r\n\r\n```mysql\r\n-- 查询部门员工数量大于5的部门id和员工数量\r\nSELECT\r\n\tCOUNT(*),\r\n\tdepartment_id \r\nFROM\r\n\temployees \r\nGROUP BY\r\n\tdepartment_id \r\nHAVING\r\n\tCOUNT(*)\u003e 5;\r\n```\r\n\r\n`HAVING` 子句和 `WHERE` 子句的区别：\r\n\r\n- `WHERE` 过滤行，`HAVING` 过滤分组\r\n- `WHERE` 分组前过滤，`HAVING` 分组后过滤\r\n\r\n## 多个字段分组\r\n\r\n将多个字段都相同的分为一组\r\n\r\n```mysql\r\nSELECT\r\n\tMIN( salary ) \r\nFROM\r\n\temployees \r\nGROUP BY\r\n\tdepartment_id,\r\n\tjob_id \r\nORDER BY\r\n\tMIN( salary ) DESC;\r\n```\r\n\r\n# 子句顺序\r\n\r\n`SELECT` 子句使用顺序：\r\n\r\n1. `SELECT`\r\n2. `FROM`\r\n3. `WHERE`\r\n4. `GROUP BY`\r\n5. `HAVING`\r\n6. `ORDER BY`\r\n7. `LIMIT`\r\n\r\n# 连接查询\r\n\r\n当查询的字段来自于多个表时，就可以使用连接查询。\r\n\r\n## 笛卡尔积\r\n\r\n在连接两个表时，实际上做的是将第一个表的每一行与第二个表中的每一行配对。\r\n\r\n`WHERE` 子句可以将不需要的行过滤掉，在连接查询时这个条件叫做连接条件。\r\n\r\n当没有连接条件时连接查询返回的结果就是**笛卡尔积**，检索出的行数时两表行数的乘积。\r\n\r\n为了避免笛卡尔集，可以在 `WHERE` 加入有效的连接条件。\r\n\r\n## 内连接\r\n\r\n内连接查询操作只列出与连接条件匹配的数据行，也就是交集\r\n\r\n- 根据所使用的**比较方式**不同，分为等值连接、非等值连接。\r\n\r\n- n表连接，至少需要n-1个连接条件\r\n- 一般需要为表起别名\r\n\r\n### SQL92\r\n\r\n将连接条件写在 `WHERE` 后进行过滤的是 SQL92 语法\r\n\r\n```mysql\r\nSELECT\r\n\tvend_name,\r\n\tprod_name,\r\n\tprod_price \r\nFROM\r\n\tvendors,\r\n\tproducts \r\nWHERE\r\n\tvendors.vend_id = products.vend_id;\r\n```\r\n\r\n### SQL99\r\n\r\nSQL99 语法使用 `INNER JOIN` 语法来实现表的内连接\r\n\r\n```mysql\r\nSELECT\r\n\tvend_name,\r\n\tprod_name,\r\n\tprod_price \r\nFROM\r\n\tvendors\r\n\tINNER JOIN products ON vendors.vend_id = products.vend_id;\r\n```\r\n\r\n- `INNER` 关键字可以省略\r\n- 连接条件在 `ON` 后面\r\n- 可以接着使用 `WHERE` 进行过滤\r\n- 筛选条件放在 `WHERE` 后面，连接条件放在 `ON` 后面，提高分离性，便于阅读\r\n\r\n**区别**\r\n\r\n- **WHERE 没有 ON 效率高**\r\n- ON 匹配到第一条成功的就结束，其他不匹配；若没有，不进行匹配\r\n-  WHERE 会一直匹配，进行判断\r\n\r\n## 自然连接\r\n\r\n在返回所有结果的等值连接中，必然至少有一个列是重复的，自然连接就是自己选择结果集合中所包括的列。\r\n\r\n## 自连接\r\n\r\n自连接就是同一张表和同一张表进行连接，当一张表中有两个以上的字段有一定的关系时就可能用到自连接。\r\n\r\n```mysql\r\n-- mysql92\r\nSELECT\r\n\te.last_name,\r\n\tm.last_name \r\nFROM\r\n\temployees e,\r\n\temployees m \r\nWHERE\r\n\te.`manager_id` = m.`employee_id`;\r\n\r\n-- mysql99\r\nSELECT\r\n\te.last_name,\r\n\tm.last_name \r\nFROM\r\n\temployees e\r\n\tJOIN employees m ON e.`manager_id` = m.`employee_id`;\r\n```\r\n\r\n## 外连接\r\n\r\n外连接不只列出与连接条件相匹配的行，而且还加上左表(左外连接时)或右表(右外连接时)或两个表(全外连接时)中所有符合搜索条件的数据行\r\n\r\n外连接只有 SQL99 支持，SQL92 不支持。\r\n\r\n### 左外连接\r\n\r\n左外连接从左边表（`FROM`）中选择所有行，另一个表中没有的数据则显示 `NULL`\r\n\r\n```mysql\r\nSELECT\r\n\tcustomers.cust_id,\r\n\torders.order_num \r\nFROM\r\n\tcustomers\r\n\tLEFT OUTER JOIN orders ON customers.cust_id = orders.cust_id;\r\n```\r\n\r\n- `OUTER` 关键字可以省略\r\n- 可以多表连接\r\n- 多表连接时先连接成一个大表再和后面的表依次进行连接，主表在左边\r\n\r\n### 右外连接\r\n\r\n右外连接从右边表（`FROM`）中选择所有行，另一个表中没有的数据则显示 `NULL` \r\n\r\n```mysql\r\nSELECT\r\n\tcustomers.cust_id,\r\n\torders.order_num \r\nFROM\r\n\torders\r\n\tRIGHT OUTER JOIN customers ON customers.cust_id = orders.cust_id;\r\n```\r\n\r\n### 全外连接\r\n\r\n全外连接就是两个表中的行都有，每一个表中不匹配的行列的数据为 `NULL`\r\n\r\n全外连接使用 `FULL OUTER JOIN` 关键字MySQL 不支持全外连接\r\n\r\n```mysql\r\nSELECT\r\n\tb.*,\r\n\tbo.* \r\nFROM\r\n\tbeauty b\r\n\tFULL OUTER JOIN boys bo ON b.`boyfriend_id` = bo.id;\r\n```\r\n\r\n## 交叉连接\r\n\r\n交叉连接就是笛卡尔积，交叉连接使用 `CROSS JOIN` 关键字\r\n\r\n```mysql\r\nSELECT\r\n\tb.*,\r\n\tbo.* \r\nFROM\r\n\tbeauty b\r\n\tCROSS JOIN boys bo;\r\n```\r\n\r\n# 子查询\r\n\r\n子查询就是嵌套在其他查询中的查询（出现在其他语句中的 `SELECT`语句）\r\n\r\n子查询可以出现的位置：\r\n\r\n- `SELECT` 之后\r\n- `FROM` 之后\r\n- `WHERE` 之后\r\n- `HAVING` 之后\r\n- `EXISTS` 之后\r\n\r\n子查询的结果的行和列的数量必须要合法，要和使用的位置所需要的格式相匹配。\r\n\r\n```mysql\r\nSELECT\r\n\tcust_id \r\nFROM\r\n\torders \r\nWHERE\r\n\torder_num IN ( SELECT order_num FROM orderitems WHERE prod_id = 'TNT2' );\r\n```\r\n\r\n在 `SELECT` 语句中，子查询总是由内向外处理，先运行子查询再运行主查询。\r\n\r\n对于 `IN` 操作符内部的子查询，查询出来的多行单列的结果会以 `IN` 操作符要求的逗号分隔的格式传递给外部。\r\n\r\n## 相关子查询\r\n\r\n当**子查询中**涉及到**外部查询**的子查询称之为相关子查询\r\n\r\n`SELECT` 之后的子查询会在检索每一行时都会执行一遍，对于每个 customer 都会在执行一边子查询。\r\n\r\n```mysql\r\nSELECT\r\n\tcust_name,\r\n\tcust_state,\r\n\t( SELECT count(*) FROM orders WHERE orders.cust_id = customers.cust_id ) AS orders \r\nFROM\r\n\tcustomers \r\nORDER BY\r\n\tcust_name;\r\n```\r\n\r\n## EXISTS\r\n\r\n当 `EXISTS` 子句中的子查询有结果返回 1，否则返回 0\r\n\r\n```mysql\r\nSELECT EXISTS ( SELECT * FROM products WHERE vend_id IS NULL );\r\n```\r\n\r\n## ANY/SOME/ALL\r\n\r\n`ANY`、`SOME` 和 `ALL`  中只能放子查询，和 `IN`、`NOT IN` 子句一样后面放的是多行单列的子查询\r\n\r\n- `ANY`、`SOME` 是一样的，只要和其中的任意一个数据比较满足就可以。\r\n\r\n- `ALL` 则是和其中所有的进行比较满足才可以。\r\n\r\n```mysql\r\nSELECT\r\n\tprod_name,\r\n\tvend_id \r\nFROM\r\n\tproducts \r\nWHERE\r\n\tvend_id \u003e ALL ( SELECT DISTINCT vend_id FROM products WHERE vend_id IN ( 1001, 1002 ) );\r\n```\r\n\r\n# 联合查询\r\n\r\n联合查询就是将多条查询语句的结果合并成一个结果。\r\n\r\n```mysql\r\nSELECT\r\n\tvend_id,\r\n\tprod_id,\r\n\tprod_price \r\nFROM\r\n\tproducts \r\nWHERE\r\n\tprod_price \u003c= 5\r\nUNION\r\nSELECT\r\n\tvend_id,\r\n\tprod_id,\r\n\tprod_price \r\nFROM\r\n\tproducts \r\nWHERE\r\n\tvend_id IN ( 1001, 1002 );\r\n```\r\n\r\n- `UNION` 必须由两条或两条以上的 `SELECT` 语句组成\r\n- `UNION` 中的每个查询必须包含**相同的列**\r\n- `UNION` 从查询结果中自动去除了的**重复的行**\r\n- 想返回所有匹配的行，使用 `UNION ALL`\r\n- 只能使用一条 `ORDER BY` 子句，必须出现在最后一条 `SELECT` 语句之后，MySQL 使用它来给整个结果排序\r\n- `UNION` 几乎总是完成与多个 `WHERE` 条件相同的工作\r\n\r\n# 插入数据\r\n\r\n使用 `SELECT INTO` + 表名向表中插入一行数据：\r\n\r\n```mysql\r\nINSERT INTO customers\r\nVALUES\r\n\t( NULL, 'Prp E. LaPew', '100 Main Street', 'Los Angeles', 'CA', '90046', 'USA', NULL, NULL );\r\n```\r\n\r\n- 这种方式需要传入所有的字段，以及顺序高度依赖表中列定义的次序\r\n- `NULL` 可以传递给主键，MySQL 会忽略该值自动插入递增的值\r\n\r\n比较安全的 `INSERT` 语句是写出插入的字段：\r\n\r\n```mysql\r\nINSERT INTO customers ( cust_name, \r\n\tcust_address, \r\n\tcust_city, \r\n\tcust_state,\r\n\tcust_zip, \r\n\tcust_country, \r\n\tcust_contact, \r\n\tcust_email )\r\nVALUES\r\n\t( 'Prp E. LaPew', '100 Main Street', 'Los Angeles', 'CA', '90046', 'USA', NULL, NULL );\r\n```\r\n\r\n- 可以省略允许定义为 `NULL` 或有默认值的列\r\n- 列的顺序随意\r\n\r\n## 多行插入\r\n\r\n插入多行可以使用多条 `INSERT` 语句，也可以使用 `,` 分隔多组值：\r\n\r\n```mysql\r\nINSERT INTO customers ( cust_name, \r\n\tcust_address, \r\n\tcust_city, \r\n\tcust_state,\r\n\tcust_zip, \r\n\tcust_country, \r\n\tcust_contact, \r\n\tcust_email )\r\nVALUES\r\n\t( 'Prp E. LaPew', '100 Main Street', 'Los Angeles', 'CA', '90046', 'USA', NULL, NULL ),\r\n\t( 'M. Martain', '42 Galaxy Way', 'New York', 'NY', '11213', 'USA' );\r\n```\r\n\r\n## 检索插入\r\n\r\n可以使用 `INSERT SELECT` 插入查询出来的数据：\r\n\r\n```mysql\r\nINSERT INTO customers ( cust_contact, \r\n\tcust_email, \r\n\tcust_name, \r\n\tcust_address, \r\n\tcust_city, \r\n\tcust_state, \r\n\tcust_zip, \r\n\tcust_country ) \r\nSELECT\r\n    cust_contact,\r\n    cust_email,\r\n    cust_name,\r\n    cust_address,\r\n    cust_city,\r\n    cust_state,\r\n    cust_zip,\r\n    cust_country \r\nFROM\r\n\tcustomers \r\nWHERE\r\n\tcust_contact IS NOT NULL;\r\n```\r\n\r\n`INSERT` 和 `SELECT` 中的列名不要求相同，MySQL 不关心列名只关心位置\r\n\r\n# 更新数据\r\n\r\n使用 `UPDATE` 语句更新表中的数据，\r\n\r\n```mysql\r\nUPDATE customers \r\nSET cust_email = 'elmer@fudd.com' \r\nWHERE\r\n\tcust_id = 10005;\r\n```\r\n\r\n- `UPDATE` 会更新符合条件的行，没有条件则会更行所有行\r\n- 通过 `SET` 改变字段的值\r\n\r\n## 更新多个列\r\n\r\n在更新多个列时只需要使用单个 `SET` ，每个 `列=值` 之间使用 `,` 分隔，最后一列不需要。\r\n\r\n```mysql\r\nUPDATE customers \r\nSET cust_email = 'elmer@fudd.com',\r\n\tcust_name = 'The Fudds' \r\nWHERE\r\n\tcust_id = 10005;\r\n```\r\n\r\n## IGNORE\r\n\r\n当使用 `UPDATE` 语句更新多个行时，当在更新过程中出现错误，则整个 `UPDATE` 操作会被取消，数据会恢复到之前的值。\r\n\r\n使用 `IGNORE` 关键字可以即使发生错误也继续更新。\r\n\r\n```mysql\r\nUPDATE IGNORE customers ...\r\n```\r\n\r\n## 更新多表\r\n\r\n```mysql\r\nUPDATE products\r\nINNER JOIN vendors ON products.vend_id = vendors.vend_id \r\nSET vendors.vend_name = 'The Fudds',\r\n\tproducts.prod_name = 'Wascals' \r\nWHERE\r\n\tproducts.prod_id = 'FC';\r\n```\r\n\r\n# 删除数据\r\n\r\n使用 `DELETE` 语句删除特定的行：\r\n\r\n```mysql\r\nDELETE \r\nFROM\r\n\tcustomers \r\nWHERE\r\n\tcust_id = 10006;\r\n```\r\n\r\n- `DELETE` 会删除符合条件的行，没有条件则会删除所有行\r\n- `DELETE FROM` 指定删除数据的表名\r\n- 可以和 `UPDATE` 一样删除多个表\r\n\r\n## 删除多表\r\n\r\n`DELETE` 后面跟的是要删除的表，`FROME` 后面跟的是连接的主表\r\n\r\n```mysql\r\nDELETE b, bo \r\nFROM\r\n\tbeauty b\r\n\tINNER JOIN boys bo ON b.`boyfriend_id` = bo.`id` \r\nWHERE\r\n\tbo.`boyName` = '黄晓明';\r\n```\r\n\r\n## 更快的删除\r\n\r\n如果要从表中删除所有的行，使用 `TRUNCATE TABLE` 语句更合适：\r\n\r\n```mysql\r\nTRUNCATE TABLE customers ;\r\n```\r\n\r\n- `TRUNCATE TABLE` 的速度比 `DELETE` 更快\r\n- `TRUNCATE` 的本质是删除原来的表然后重新创建一个表\r\n\r\n\r\n\r\n","meta":{"size":16857,"birthTime":1663496641411.9246,"updateTime":1663496641412.2349}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["MySQL","CRUD"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
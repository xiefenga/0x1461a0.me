<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>地址线和数据线 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#地址线" data-target-id="h1-地址线-0">地址线</a></li><li><a href="#数据线" data-target-id="h1-数据线-1">数据线</a></li><li><a href="#寻址" data-target-id="h1-寻址-2">寻址</a><ul><li><a href="#按字节寻址" data-target-id="h2-按字节寻址-0">按字节寻址</a></li><li><a href="#按字寻址" data-target-id="h2-按字寻址-1">按字寻址</a></li><li><a href="#按字寻址和按字节寻址相同处" data-target-id="h2-按字寻址和按字节寻址相同处-2">按字寻址和按字节寻址相同处</a></li></ul></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">地址线和数据线</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h1>地址线</h1>
<p>地址线是用来传输地址信息用的。CPU在内存或硬盘里面寻找一个数据时，先通过地址线找到地址，然后再通过数据线将数据取出来。</p>
<p>地址线一次确定一个存储单元，地址线上值的所有可能取值等于存储单元的个数。</p>
<p>存储单元个数 = 2^地址线条数</p>
<p>存储单元：</p>
<p>一般应具有存储数据和读写数据的功能，以8位二进制作为一个存储单元，也就是一个字节。</p>
<h1>数据线</h1>
<p>字（word）是用于表示其自然的数据单位的术语，是用来表示一次性处理事务的固定长度。一个字的位数，即<strong>字长</strong>，是计算机系统结构中的一个重要特性。</p>
<p>数据线确定存储字长，数据线有多少条，字长就是多少位。</p>
<p>字长是32位，则1字=32bit=4B，则表明处理器一次可以处理4个存储单元，指令长度为4个存储单元。</p>
<h1>寻址</h1>
<p>寻址：CPU 请求数据时获得该数据在内存上的位置的过程。内存上存储的所有数据都会有一个可以区分的地址，这与其存放的位置相对应，当CPU请求数据时，内存中的电路会根据CPU的地址线上的信号利用数据总线向CPU返回数据。</p>
<p>内存每一个存储位置的最小单元都可以储存0或1，即一个位的内容，而内存将8个位设定为一个存储空间的基本单位。而在地址线上每一个地址的编号便对应的是一个存储位置的最小的基本单位。</p>
<h2>按字节寻址</h2>
<p><strong>按字节寻址指一个地址线表示的数与一个字节地址相对应</strong>。比如一台机器有30根地址线，如果按字节寻址，其寻址范围是 $2^{30}$ = 1GB。</p>
<h2>按字寻址</h2>
<p><strong>计算机以此方式寻址时，每一个地址值指向了一个字</strong>，这里指向的不是按字节寻址中的字节了。一个字里面有任意个字节，那么计算机如何知道其地址指向的到底是字中的第几个字节呢？这便需要地址线中分出一部分标出其所指的到底是字中的第一个字节，还是第二个，亦或是其他。比如一个计算机有 30 根地址线，如果按字寻址，其字的字长为 64 位的话，那么每个字长有4个字节，4个字节用二进制编码需要两位来区分（比如第1、2、3、4个字节分别为00，01，10，11）因此真正用来表示字的位置的地址线有 30-2=28 根，其寻址范围是 $2^{28}$ = 256MW。注意这里单位为W表示一个字。</p>
<h2>按字寻址和按字节寻址相同处</h2>
<p>不难发现，不论哪种方式，其编码内存中存储基本单位（即B）的数量是一样的。拿上述两个例子来说，按字节寻址可编码1GB，按字寻址编码256MW，而根据例子中对字长的约定1W=4B，即其用来表示字中到底要第几个字节的两根地址线的值共可编码4个不同，其最终可编码的字节数：256M×4B=1GB，因此寻址方式不同只是定义上的差异，其实际上搜索的地址范围内的字节数是一样的。</p><div><a href="/notes/%E8%AE%A1%E7%BB%84">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"地址线和数据线","article":{"title":"地址线和数据线","content":"# 地址线\r\n\r\n地址线是用来传输地址信息用的。CPU在内存或硬盘里面寻找一个数据时，先通过地址线找到地址，然后再通过数据线将数据取出来。\r\n\r\n地址线一次确定一个存储单元，地址线上值的所有可能取值等于存储单元的个数。\r\n\r\n存储单元个数 = 2^地址线条数\r\n\r\n存储单元：\r\n\r\n一般应具有存储数据和读写数据的功能，以8位二进制作为一个存储单元，也就是一个字节。\r\n\r\n# 数据线\r\n\r\n字（word）是用于表示其自然的数据单位的术语，是用来表示一次性处理事务的固定长度。一个字的位数，即**字长**，是计算机系统结构中的一个重要特性。\r\n\r\n数据线确定存储字长，数据线有多少条，字长就是多少位。\r\n\r\n字长是32位，则1字=32bit=4B，则表明处理器一次可以处理4个存储单元，指令长度为4个存储单元。\r\n\r\n# 寻址\r\n\r\n寻址：CPU 请求数据时获得该数据在内存上的位置的过程。内存上存储的所有数据都会有一个可以区分的地址，这与其存放的位置相对应，当CPU请求数据时，内存中的电路会根据CPU的地址线上的信号利用数据总线向CPU返回数据。\r\n\r\n内存每一个存储位置的最小单元都可以储存0或1，即一个位的内容，而内存将8个位设定为一个存储空间的基本单位。而在地址线上每一个地址的编号便对应的是一个存储位置的最小的基本单位。\r\n\r\n## 按字节寻址\r\n\r\n**按字节寻址指一个地址线表示的数与一个字节地址相对应**。比如一台机器有30根地址线，如果按字节寻址，其寻址范围是 $2^{30}$ = 1GB。\r\n\r\n## 按字寻址\r\n\r\n**计算机以此方式寻址时，每一个地址值指向了一个字**，这里指向的不是按字节寻址中的字节了。一个字里面有任意个字节，那么计算机如何知道其地址指向的到底是字中的第几个字节呢？这便需要地址线中分出一部分标出其所指的到底是字中的第一个字节，还是第二个，亦或是其他。比如一个计算机有 30 根地址线，如果按字寻址，其字的字长为 64 位的话，那么每个字长有4个字节，4个字节用二进制编码需要两位来区分（比如第1、2、3、4个字节分别为00，01，10，11）因此真正用来表示字的位置的地址线有 30-2=28 根，其寻址范围是 $2^{28}$ = 256MW。注意这里单位为W表示一个字。\r\n\r\n## 按字寻址和按字节寻址相同处\r\n\r\n不难发现，不论哪种方式，其编码内存中存储基本单位（即B）的数量是一样的。拿上述两个例子来说，按字节寻址可编码1GB，按字寻址编码256MW，而根据例子中对字长的约定1W=4B，即其用来表示字中到底要第几个字节的两根地址线的值共可编码4个不同，其最终可编码的字节数：256M×4B=1GB，因此寻址方式不同只是定义上的差异，其实际上搜索的地址范围内的字节数是一样的。","meta":{"size":3037,"birthTime":1663496641454.057,"updateTime":1663496641454.153}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["计组","地址线和数据线"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>并查集 | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#并查集" data-target-id="h1-并查集-0">并查集</a><ul><li><a href="#Quick Find" data-target-id="h2-Quick Find-0">Quick Find</a></li><li><a href="#Quick Union" data-target-id="h2-Quick Union-1">Quick Union</a></li></ul></li><li><a href="#优化" data-target-id="h1-优化-1">优化</a><ul><li><a href="#路径压缩" data-target-id="h2-路径压缩-2">路径压缩</a></li><li><a href="#路径分裂" data-target-id="h2-路径分裂-3">路径分裂</a></li><li><a href="#路径减半" data-target-id="h2-路径减半-4">路径减半</a></li></ul></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">并查集</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h1>并查集</h1>
<p>并查集用于处理一些<strong>不相交集合</strong>的合并及查询问题，核心操作就是：</p>
<ul>
<li><strong>查询（find）</strong>：查询两个元素是否在同一个集合中</li>
<li><strong>合并（union）</strong>：把两个不相交的集合合并为一个集合</li>
</ul>
<p>并查集的重要思想在于，<strong>用集合中的一个元素代表集合</strong>，一个有趣的比喻是把集合看成<strong>帮派</strong>，<strong>帮主</strong>则是代表</p>
<p>一开始每个集合只有自己一个元素，当合并时一个集合则会由多个元素代表元素则为其中一个元素</p>
<p>实现思路：</p>
<ol>
<li>Quick Find：<!-- -->
<ul>
<li>查找的时间复杂度：O(1)</li>
<li>合并的时间复杂度：O(n)</li>
</ul>
</li>
<li>Quick Union<!-- -->
<ul>
<li>查找的时间复杂度：O(lgn)</li>
<li>合并的时间复杂度：O(lgn)</li>
<li>Quick Union 的查找和合并操作都可以优化至 O(α(n))，α(n) &lt; 5</li>
</ul>
</li>
</ol>
<h2>Quick Find</h2>
<p>Quick Find 实现让每个元素都指向自己所在集合的代表元素：</p>
<p><img src="https://oss.xiefeng.tech/img/20210818214448.png" alt=""/></p>
<pre><code class="language-typescript">public find(v: number): number {
    this.checkIndex(v)
    return this.parents[v]
}

public union(v1: number, v2: number): void {
    const p1 = this.find(v1)
    const p2 = this.find(v2)
    if (p1 !== p2) {
        this.parents = this.parents.map(p =&gt; p === p1 ? p2 : p)
    }
}
</code></pre>
<h2>Quick Union</h2>
<p>Quick Union 实现在合并时让一个集合的代表指向另一个集合的代表</p>
<p><img src="https://oss.xiefeng.tech/img/20210818214342.png" alt=""/></p>
<pre><code class="language-typescript">public find(v: number): number {
    this.checkIndex(v)
    while (v !== this.parents[v]) {
        v = this.parents[v]
    }
    return v
}

public union(v1: number, v2: number): void {
    const p1 = this.find(v1)
    const p2 = this.find(v2)
    if (p1 !== p2) {
        this.parents[p1] = p2
    }
}
</code></pre>
<h1>优化</h1>
<p>在 union 的过程中，会出现树不平衡的情况，最差会变成链表</p>
<p>有两种常见的优化f方式：</p>
<ul>
<li>基于 size 优化：union 时元素少的合并到元素多的集合上</li>
<li>基于 rank 优化：union 时树矮的集合合并到高的集合上</li>
</ul>
<pre><code class="language-typescript">public override union(v1: number, v2: number): void {
    const p1 = this.find(v1)
    const p2 = this.find(v2)
    if (p1 !== p2) {
        const rank1 = this.rank[v1]
        const rank2 = this.rank[v2]
        if (rank1 &lt; rank2) {
            this.parents[p1] = p2
        } else if (rank1 &gt; rank2) {
            this.parents[p2] = p1
        } else {
            this.parents[p1] = p2
            this.rank[p2] = rank2 + 1
        }
    }
}
</code></pre>
<p>基于 size 的优化也会存在树不平衡的问题：</p>
<p><img src="https://oss.xiefeng.tech/img/20210818220048.png" alt=""/></p>
<p>基于 rank 的优化树会相对平衡一点，但是随着 union 的次数增多，树依旧会越来越高</p>
<p>find 操作就会变慢，因为底层节点需要一层一层往上找</p>
<h2>路径压缩</h2>
<p>路径压缩就是在执行 find 操作时，顺便让路径上所有的节点都指向根节点，从而减低树的高度：</p>
<p><img src="https://oss.xiefeng.tech/img/20210818220418.png" alt=""/></p>
<pre><code class="language-typescript">public override find(v: number): number {
    this.checkIndex(v)
    if (this.parents[v] !== v) {
        this.parents[v] = this.find(this.parents[v])
    }
    return this.parents[v]
}
</code></pre>
<h2>路径分裂</h2>
<p>路径分裂就是将路径上的每一个节点都指向其祖先节点：</p>
<pre><code class="language-typescript">public override find(v: number): number {
    this.checkIndex(v)
    const parents = this.parents
    while (v !== parents[v]) {
        const p = parents[v];
        parents[v] = parents[parents[v]];
        v = p;
    }
    return v;
}
</code></pre>
<h2>路径减半</h2>
<p>路径减半就是使路径上每隔一个节点就指向其祖父节点：</p>
<pre><code class="language-typescript">public override find(v: number): number {
    this.checkIndex(v)
    const parents = this.parents
    while (v !== parents[v]) {
        parents[v] = parents[parents[v]];
        v = parents[v];
    }
    return v;
}
</code></pre>
<p>使用路径压缩、分裂或减半 + 基于 rank 或者 size 的优化，可以确保每个操作的均摊时间复杂度为  O(α(n))</p><div><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"并查集","article":{"title":"并查集","content":"# 并查集\n\n并查集用于处理一些**不相交集合**的合并及查询问题，核心操作就是：\n\n- **查询（find）**：查询两个元素是否在同一个集合中\n- **合并（union）**：把两个不相交的集合合并为一个集合\n\n并查集的重要思想在于，**用集合中的一个元素代表集合**，一个有趣的比喻是把集合看成**帮派**，**帮主**则是代表\n\n一开始每个集合只有自己一个元素，当合并时一个集合则会由多个元素代表元素则为其中一个元素\n\n实现思路：\n\n1. Quick Find：\n\t- 查找的时间复杂度：O(1)\n\t- 合并的时间复杂度：O(n)\n2. Quick Union\n\t- 查找的时间复杂度：O(lgn)\n\t- 合并的时间复杂度：O(lgn)\n\t- Quick Union 的查找和合并操作都可以优化至 O(α(n))，α(n) \u003c 5\n\n## Quick Find\n\nQuick Find 实现让每个元素都指向自己所在集合的代表元素：\n\n![](https://oss.xiefeng.tech/img/20210818214448.png)\n\n```typescript\npublic find(v: number): number {\n    this.checkIndex(v)\n    return this.parents[v]\n}\n\npublic union(v1: number, v2: number): void {\n    const p1 = this.find(v1)\n    const p2 = this.find(v2)\n    if (p1 !== p2) {\n        this.parents = this.parents.map(p =\u003e p === p1 ? p2 : p)\n    }\n}\n```\n\n## Quick Union\n\nQuick Union 实现在合并时让一个集合的代表指向另一个集合的代表\n\n![](https://oss.xiefeng.tech/img/20210818214342.png)\n\n```typescript\npublic find(v: number): number {\n    this.checkIndex(v)\n    while (v !== this.parents[v]) {\n        v = this.parents[v]\n    }\n    return v\n}\n\npublic union(v1: number, v2: number): void {\n    const p1 = this.find(v1)\n    const p2 = this.find(v2)\n    if (p1 !== p2) {\n        this.parents[p1] = p2\n    }\n}\n```\n\n# 优化\n\n在 union 的过程中，会出现树不平衡的情况，最差会变成链表\n\n有两种常见的优化f方式：\n\n- 基于 size 优化：union 时元素少的合并到元素多的集合上\n- 基于 rank 优化：union 时树矮的集合合并到高的集合上\n\n```typescript\npublic override union(v1: number, v2: number): void {\n    const p1 = this.find(v1)\n    const p2 = this.find(v2)\n    if (p1 !== p2) {\n        const rank1 = this.rank[v1]\n        const rank2 = this.rank[v2]\n        if (rank1 \u003c rank2) {\n            this.parents[p1] = p2\n        } else if (rank1 \u003e rank2) {\n            this.parents[p2] = p1\n        } else {\n            this.parents[p1] = p2\n            this.rank[p2] = rank2 + 1\n        }\n    }\n}\n```\n\n基于 size 的优化也会存在树不平衡的问题：\n\n![](https://oss.xiefeng.tech/img/20210818220048.png)\n\n基于 rank 的优化树会相对平衡一点，但是随着 union 的次数增多，树依旧会越来越高\n\nfind 操作就会变慢，因为底层节点需要一层一层往上找\n\n## 路径压缩\n\n路径压缩就是在执行 find 操作时，顺便让路径上所有的节点都指向根节点，从而减低树的高度：\n\n![](https://oss.xiefeng.tech/img/20210818220418.png)\n\n```typescript\npublic override find(v: number): number {\n    this.checkIndex(v)\n    if (this.parents[v] !== v) {\n        this.parents[v] = this.find(this.parents[v])\n    }\n    return this.parents[v]\n}\n```\n\n## 路径分裂\n\n路径分裂就是将路径上的每一个节点都指向其祖先节点：\n\n```typescript\npublic override find(v: number): number {\n    this.checkIndex(v)\n    const parents = this.parents\n    while (v !== parents[v]) {\n        const p = parents[v];\n        parents[v] = parents[parents[v]];\n        v = p;\n    }\n    return v;\n}\n```\n\n## 路径减半\n\n路径减半就是使路径上每隔一个节点就指向其祖父节点：\n\n```typescript\npublic override find(v: number): number {\n    this.checkIndex(v)\n    const parents = this.parents\n    while (v !== parents[v]) {\n        parents[v] = parents[parents[v]];\n        v = parents[v];\n    }\n    return v;\n}\n```\n\n使用路径压缩、分裂或减半 + 基于 rank 或者 size 的优化，可以确保每个操作的均摊时间复杂度为  O(α(n))\n\n","meta":{"size":4002,"birthTime":1663496641431.0193,"updateTime":1663496641431.193}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["数据结构和算法","并查集"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>MVX | 0X1461A0</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5db4aa1edde4971b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5db4aa1edde4971b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/38c642bc88044b6e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/38c642bc88044b6e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2c644d3580cecc35.js" defer=""></script><script src="/_next/static/chunks/framework-325eacbb81921a43.js" defer=""></script><script src="/_next/static/chunks/main-c87967b003e3efc2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-111c29f79e705983.js" defer=""></script><script src="/_next/static/chunks/542-e750f8bef0aa06d2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B%5B...param%5D%5D-4c9f87d1f418ba6e.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_buildManifest.js" defer=""></script><script src="/_next/static/OyucwIrXZRgWNxoAUA9lF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="pb-10 pt-12 text-center shrink-0"><a class="uppercase tracking-widest text-gray-600" href="/">0x1461a0</a></header><main class="flex-auto mb-12"><div class="TOC_table-of-content__KyR_J"><ul><li><a href="#MVC" data-target-id="h1-MVC-0">MVC</a><ul><li><a href="#特点" data-target-id="h2-特点-0">特点</a></li><li><a href="#弊端" data-target-id="h2-弊端-1">弊端</a></li></ul></li><li><a href="#MVP" data-target-id="h1-MVP-1">MVP</a><ul><li><a href="#特点" data-target-id="h2-特点-2">特点</a></li><li><a href="#区别" data-target-id="h2-区别-3">区别</a></li><li><a href="#优缺" data-target-id="h2-优缺-4">优缺</a></li></ul></li><li><a href="#MVVM" data-target-id="h1-MVVM-2">MVVM</a><ul><li><a href="#特点" data-target-id="h2-特点-5">特点</a></li><li><a href="#区别" data-target-id="h2-区别-6">区别</a></li><li><a href="#优缺" data-target-id="h2-优缺-7">优缺</a></li></ul></li></ul></div><div class="article_article-container__yUBmR"><div class="mb-8"><h1 data-title="true" class="mb-0">MVX</h1><p class="opacity-50 !-mt-2"><span>Post: <!-- -->2022.09.18</span><span class="font-bold">·</span><span>Update: <!-- -->2022.09.18</span></p></div><h1>MVC</h1>
<p>View：放置视图相关的代码，原则上里面不应该有任何业务逻辑</p>
<p>Model：封装和应用程序的业务逻辑相关的<strong>数据</strong>以及对<strong>数据的处理</strong>方法</p>
<p>Controller：放置视图与模型之间的映射，原则上这里应该很薄，他只放一些事件绑定相关的代码，但并不实现真正的功能</p>
<h2>特点</h2>
<p>Model 和 View 之间使用了观察者模式，View 事先在此 Model 上注册，在 Model 的值变更时收到通知</p>
<ol>
<li>控制器负责对模型中的数据进行更新，而视图向模型中请求数据</li>
<li>当触发事件时，控制器更新模型，模型通知视图进行更新，这时视图向模型请求新的数据</li>
</ol>
<p><img src="https://oss.xiefeng.tech/images/20210917104854.png" alt=""/></p>
<h2>弊端</h2>
<ol>
<li>当每个事件都流经 Controller 时，这层会变得十分臃肿</li>
<li>View 和 Controller 一般是一一对应的，View 与 Controller 过于紧密的连接让 Controller 的复用性成了问题</li>
<li>Controller 测试困难：因为视图同步操作是由 View 自己执行，而 View只能在有 UI 的环境下运行</li>
<li>View 无法组件化：View 是强依赖特定的 Model 的，将一个 View 抽出来作为另外一个应用程序可复用的组件比较困难</li>
</ol>
<h1>MVP</h1>
<p>MVP（model-view-Presenter）是经典 MVC 设计模式的一种衍生模式</p>
<h2>特点</h2>
<ol>
<li>用户对 View 的操作都会从 View 交移给 Presenter，Presenter 会执行相应的应用程序逻辑，并且对 Model 进行相应的操作</li>
<li>Model 执行完业务逻辑以后，通过观察者模式把自己变更的消息传递给 Presenter 而不是 View</li>
<li>Presenter 获取到 Model 变更的消息以后，通过 View 提供的接口更新界面</li>
</ol>
<p><img src="http://oss.xiefeng.tech/img/20210321203306.png" alt=""/></p>
<h2>区别</h2>
<ol>
<li>在 MVC 中， Controller 是不能操作 View 的， View 也没有提供相应的接口</li>
<li>在 MVP 中， Presenter 可以操作 View，View 需要提供一组对界面操作的接口给 Presenter 进行调用</li>
<li>Model 仍然通过事件广播自己的变更，但由 Presenter 监听而不是 View</li>
</ol>
<h2>优缺</h2>
<p>优点：</p>
<ol>
<li>
<p>便于测试</p>
<p>Presenter 对 View 是通过接口进行，在对 Presenter 进行不依赖 UI 环境的单元测试的时候，可以 Mock 一个 View对象</p>
</li>
<li>
<p>View 可以进行组件化</p>
<p>View 不依赖 Model，这样就可以让 View 从特定的业务场景中脱离出来，它只需要提供一系列接口提供给上层操作</p>
</li>
</ol>
<p>缺点：</p>
<p>Presenter 中除了应用逻辑以外，还有大量的 View 和 Model 之间的手动同步逻辑，导致 Presenter 比较笨重，维护起来会比较困难</p>
<h1>MVVM</h1>
<p>MVVM 是 MVC 模式的另一个变种，MVVM 即 Model-View-ViewModel</p>
<h2>特点</h2>
<p>MVVM 在 MVP 的基础上进行了改良，将 presenter 改良成 ViewModel，实现了 View 和 Model 的同步逻辑自动化</p>
<p>ViewModel 中有一个 Binder，进行了数据的绑定，自动的处理 View 和 Model 的数据同步逻辑</p>
<ul>
<li>Model：包含了业务和验证逻辑的数据模型</li>
<li>View：定义屏幕中 View 的结构，布局和外观</li>
<li>ViewModel：扮演 View 和 Model 之间的使者，帮忙处理 View 的全部逻辑</li>
</ul>
<p><img src="http://oss.xiefeng.tech/img/20210321203749.png" alt=""/></p>
<ol>
<li>MVVM 将 View 的状态和行为抽象化，让我们可以将 UI 和业务逻辑分开</li>
<li>这些工作 ViewModel 由完成，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑</li>
<li>ViewModel 是由我们组织生成和维护的视图数据层，在这一层对从后端获取的 Model 数据进行转换处理，以生成符合 View 层使用预期的视图数据模型</li>
<li>ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的</li>
</ol>
<h2>区别</h2>
<p>在 MVC 中：</p>
<ol>
<li>View 在 Controller 的顶端，而 Model 在 Controller 的底部</li>
<li>Controller 需要同时关注 View 和 Model</li>
<li>View 只能知道 Model 的存在并且能在 Model 的值变更时收到通知</li>
</ol>
<p>MVVM 模式和 MVC 有些类似，但有些不同:</p>
<ol>
<li>ViewModel 替换了 Controller，在 UI 层之下</li>
<li>ViewModel 向 View 暴露它所需要的数据和指令对象</li>
<li>ViewModel 接收来自 Model 的数据</li>
</ol>
<h2>优缺</h2>
<p>优点：提高可维护性、简化测试</p>
<p>缺点：简单 GUI应用会产生额外的性能损耗、复杂 GUI的 ViewModel 构建和维护成本高</p><div><a href="/notes/%E6%A8%A1%E5%BC%8F">cd ..</a></div></div></main><footer class="pb-2 pt-12 text-center shrink-0"><div class="capitalize">copyright <span class="text-2xl align-middle">©</span> <!-- -->2022<!-- --> xie feng</div><div class="text-sm">Powered by NextJS</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaTitle":"MVX","article":{"title":"MVX","content":"# MVC\r\n\r\nView：放置视图相关的代码，原则上里面不应该有任何业务逻辑\r\n\r\nModel：封装和应用程序的业务逻辑相关的**数据**以及对**数据的处理**方法\r\n\r\nController：放置视图与模型之间的映射，原则上这里应该很薄，他只放一些事件绑定相关的代码，但并不实现真正的功能\r\n\r\n## 特点\r\n\r\nModel 和 View 之间使用了观察者模式，View 事先在此 Model 上注册，在 Model 的值变更时收到通知\r\n\r\n1. 控制器负责对模型中的数据进行更新，而视图向模型中请求数据\r\n2. 当触发事件时，控制器更新模型，模型通知视图进行更新，这时视图向模型请求新的数据\r\n\r\n![](https://oss.xiefeng.tech/images/20210917104854.png)\r\n\r\n## 弊端\r\n\r\n1. 当每个事件都流经 Controller 时，这层会变得十分臃肿\r\n2. View 和 Controller 一般是一一对应的，View 与 Controller 过于紧密的连接让 Controller 的复用性成了问题\r\n3. Controller 测试困难：因为视图同步操作是由 View 自己执行，而 View只能在有 UI 的环境下运行\r\n4. View 无法组件化：View 是强依赖特定的 Model 的，将一个 View 抽出来作为另外一个应用程序可复用的组件比较困难\r\n\r\n# MVP\r\n\r\nMVP（model-view-Presenter）是经典 MVC 设计模式的一种衍生模式\r\n\r\n## 特点\r\n\r\n1. 用户对 View 的操作都会从 View 交移给 Presenter，Presenter 会执行相应的应用程序逻辑，并且对 Model 进行相应的操作\r\n2. Model 执行完业务逻辑以后，通过观察者模式把自己变更的消息传递给 Presenter 而不是 View\r\n3. Presenter 获取到 Model 变更的消息以后，通过 View 提供的接口更新界面\r\n\r\n![](http://oss.xiefeng.tech/img/20210321203306.png)\r\n\r\n## 区别\r\n\r\n1. 在 MVC 中， Controller 是不能操作 View 的， View 也没有提供相应的接口\r\n2. 在 MVP 中， Presenter 可以操作 View，View 需要提供一组对界面操作的接口给 Presenter 进行调用\r\n3. Model 仍然通过事件广播自己的变更，但由 Presenter 监听而不是 View\r\n\r\n## 优缺\r\n\r\n优点：\r\n\r\n1. 便于测试\r\n\r\n   Presenter 对 View 是通过接口进行，在对 Presenter 进行不依赖 UI 环境的单元测试的时候，可以 Mock 一个 View对象\r\n\r\n2. View 可以进行组件化\r\n\r\n    View 不依赖 Model，这样就可以让 View 从特定的业务场景中脱离出来，它只需要提供一系列接口提供给上层操作\r\n\r\n缺点：\r\n\r\nPresenter 中除了应用逻辑以外，还有大量的 View 和 Model 之间的手动同步逻辑，导致 Presenter 比较笨重，维护起来会比较困难\r\n\r\n# MVVM\r\n\r\nMVVM 是 MVC 模式的另一个变种，MVVM 即 Model-View-ViewModel\r\n\r\n## 特点\r\n\r\nMVVM 在 MVP 的基础上进行了改良，将 presenter 改良成 ViewModel，实现了 View 和 Model 的同步逻辑自动化\r\n\r\nViewModel 中有一个 Binder，进行了数据的绑定，自动的处理 View 和 Model 的数据同步逻辑\r\n\r\n- Model：包含了业务和验证逻辑的数据模型\r\n- View：定义屏幕中 View 的结构，布局和外观\r\n- ViewModel：扮演 View 和 Model 之间的使者，帮忙处理 View 的全部逻辑\r\n\r\n![](http://oss.xiefeng.tech/img/20210321203749.png)\r\n\r\n1. MVVM 将 View 的状态和行为抽象化，让我们可以将 UI 和业务逻辑分开\r\n2. 这些工作 ViewModel 由完成，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑\r\n3. ViewModel 是由我们组织生成和维护的视图数据层，在这一层对从后端获取的 Model 数据进行转换处理，以生成符合 View 层使用预期的视图数据模型\r\n4. ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的\r\n\r\n## 区别\r\n\r\n在 MVC 中：\r\n\r\n1. View 在 Controller 的顶端，而 Model 在 Controller 的底部\r\n2. Controller 需要同时关注 View 和 Model\r\n3. View 只能知道 Model 的存在并且能在 Model 的值变更时收到通知 \r\n\r\nMVVM 模式和 MVC 有些类似，但有些不同:\r\n\r\n1. ViewModel 替换了 Controller，在 UI 层之下\r\n2. ViewModel 向 View 暴露它所需要的数据和指令对象\r\n3. ViewModel 接收来自 Model 的数据\r\n\r\n## 优缺\r\n\r\n优点：提高可维护性、简化测试\r\n\r\n缺点：简单 GUI应用会产生额外的性能损耗、复杂 GUI的 ViewModel 构建和维护成本高","meta":{"size":4460,"birthTime":1663496641431.3843,"updateTime":1663496641431.657}}},"__N_SSG":true},"page":"/notes/[[...param]]","query":{"param":["模式","MVX"]},"buildId":"OyucwIrXZRgWNxoAUA9lF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>